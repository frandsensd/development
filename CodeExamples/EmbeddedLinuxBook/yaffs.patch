diff -uprN linux-3.1.5-orig/arch/arm/boot/compressed/lib1funcs.S linux-3.1.5/arch/arm/boot/compressed/lib1funcs.S
--- linux-3.1.5-orig/arch/arm/boot/compressed/lib1funcs.S	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/arch/arm/boot/compressed/lib1funcs.S	2012-10-25 20:18:03.570840240 -0600
@@ -0,0 +1,363 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/unwind.h>
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+	
+#else
+
+	@ Initially shift the divisor left 3 bits if possible,
+	@ set curbit accordingly.  This allows for curbit to be located
+	@ at the left end of each 4 bit nibbles in the division loop
+	@ to save one loop in most cases.
+	tst	\divisor, #0xe0000000
+	moveq	\divisor, \divisor, lsl #3
+	moveq	\curbit, #8
+	movne	\curbit, #1
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	movlo	\curbit, \curbit, lsl #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	movlo	\curbit, \curbit, lsl #1
+	blo	1b
+
+	mov	\result, #0
+
+#endif
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+
+#else
+
+	cmp	\divisor, #(1 << 16)
+	movhs	\divisor, \divisor, lsr #16
+	movhs	\order, #16
+	movlo	\order, #0
+
+	cmp	\divisor, #(1 << 8)
+	movhs	\divisor, \divisor, lsr #8
+	addhs	\order, \order, #8
+
+	cmp	\divisor, #(1 << 4)
+	movhs	\divisor, \divisor, lsr #4
+	addhs	\order, \order, #4
+
+	cmp	\divisor, #(1 << 2)
+	addhi	\order, \order, #3
+	addls	\order, \order, \divisor, lsr #1
+
+#endif
+
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+#else
+
+	mov	\order, #0
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	addlo	\order, \order, #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	addlo	\order, \order, #1
+	blo	1b
+
+#endif
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+
+ENTRY(__udivsi3)
+ENTRY(__aeabi_uidiv)
+UNWIND(.fnstart)
+
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__udivsi3)
+ENDPROC(__aeabi_uidiv)
+
+ENTRY(__umodsi3)
+UNWIND(.fnstart)
+
+	subs	r2, r1, #1			@ compare divisor with 1
+	bcc	Ldiv0
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq   r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	movls	pc, lr
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__umodsi3)
+
+ENTRY(__divsi3)
+ENTRY(__aeabi_idiv)
+UNWIND(.fnstart)
+
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__divsi3)
+ENDPROC(__aeabi_idiv)
+
+ENTRY(__modsi3)
+UNWIND(.fnstart)
+
+	cmp	r1, #0
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	movs	ip, r0				@ preserve sign of dividend
+	rsbmi	r0, r0, #0			@ if negative make positive
+	subs	r2, r1, #1			@ compare divisor with 1
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq	r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	bls	10f
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+10:	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__modsi3)
+
+#ifdef CONFIG_AEABI
+
+ENTRY(__aeabi_uidivmod)
+UNWIND(.fnstart)
+UNWIND(.save {r0, r1, ip, lr}	)
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__aeabi_uidivmod)
+
+ENTRY(__aeabi_idivmod)
+UNWIND(.fnstart)
+UNWIND(.save {r0, r1, ip, lr}	)
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+UNWIND(.fnend)
+ENDPROC(__aeabi_idivmod)
+
+#endif
+
+Ldiv0:
+UNWIND(.fnstart)
+UNWIND(.pad #4)
+UNWIND(.save {lr})
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+UNWIND(.fnend)
+ENDPROC(Ldiv0)
Binary files linux-3.1.5-orig/arch/arm/boot/compressed/piggy.gzip and linux-3.1.5/arch/arm/boot/compressed/piggy.gzip differ
Binary files linux-3.1.5-orig/arch/arm/boot/compressed/vmlinux and linux-3.1.5/arch/arm/boot/compressed/vmlinux differ
diff -uprN linux-3.1.5-orig/arch/arm/boot/compressed/vmlinux.lds linux-3.1.5/arch/arm/boot/compressed/vmlinux.lds
--- linux-3.1.5-orig/arch/arm/boot/compressed/vmlinux.lds	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/arch/arm/boot/compressed/vmlinux.lds	2012-10-25 20:14:16.523724121 -0600
@@ -0,0 +1,72 @@
+/*
+ *  linux/arch/arm/boot/compressed/vmlinux.lds.in
+ *
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+  /DISCARD/ : {
+    *(.ARM.exidx*)
+    *(.ARM.extab*)
+    /*
+     * Discard any r/w data - this produces a link error if we have any,
+     * which is required for PIC decompression.  Local data generates
+     * GOTOFF relocations, which prevents it being relocated independently
+     * of the text/got segments.
+     */
+    *(.data)
+  }
+
+  . = 0;
+  _text = .;
+
+  .text : {
+    _start = .;
+    *(.start)
+    *(.text)
+    *(.text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.glue_7t)
+    *(.glue_7)
+  }
+  .rodata : {
+    *(.rodata)
+    *(.rodata.*)
+  }
+  .piggydata : {
+    *(.piggydata)
+  }
+
+  . = ALIGN(4);
+  _etext = .;
+
+  .got.plt		: { *(.got.plt) }
+  _got_start = .;
+  .got			: { *(.got) }
+  _got_end = .;
+  _edata = .;
+
+  . = ALIGN(8);
+  __bss_start = .;
+  .bss			: { *(.bss) }
+  _end = .;
+
+  . = ALIGN(8);		/* the stack must be 64-bit aligned */
+  .stack		: { *(.stack) }
+
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+}
+
Binary files linux-3.1.5-orig/arch/arm/boot/Image and linux-3.1.5/arch/arm/boot/Image differ
Binary files linux-3.1.5-orig/arch/arm/boot/zImage and linux-3.1.5/arch/arm/boot/zImage differ
diff -uprN linux-3.1.5-orig/arch/arm/kernel/vmlinux.lds linux-3.1.5/arch/arm/kernel/vmlinux.lds
--- linux-3.1.5-orig/arch/arm/kernel/vmlinux.lds	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/arch/arm/kernel/vmlinux.lds	2012-10-25 20:03:33.916358328 -0600
@@ -0,0 +1,561 @@
+
+
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * Linux/arm 3.1.5 Kernel Configuration
+ *
+ */
+/*
+ * Helper macros to use CONFIG_ options in C expressions. Note that
+ * these only work with boolean and tristate options.
+ */
+/*
+ * IS_ENABLED(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'y' or 'm',
+ * 0 otherwise.
+ *
+ */
+
+
+
+/*
+ * IS_BUILTIN(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'y', 0
+ * otherwise. For boolean options, this is equivalent to
+ * IS_ENABLED(CONFIG_FOO).
+ */
+
+
+/*
+ * IS_MODULE(CONFIG_FOO) evaluates to 1 if CONFIG_FOO is set to 'm', 0
+ * otherwise.
+ */
+/* ld script to make ARM Linux kernel
+ * taken from the i386 version by Russell King
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+ */
+/*
+ * Helper macros to support writing architecture specific
+ * linker scripts.
+ *
+ * A minimal linker scripts has following content:
+ * [This is a sample, architectures may have special requiriements]
+ *
+ * OUTPUT_FORMAT(...)
+ * OUTPUT_ARCH(...)
+ * ENTRY(...)
+ * SECTIONS
+ * {
+ *	. = START;
+ *	__init_begin = .;
+ *	HEAD_TEXT_SECTION
+ *	INIT_TEXT_SECTION(PAGE_SIZE)
+ *	INIT_DATA_SECTION(...)
+ *	PERCPU_SECTION(CACHELINE_SIZE)
+ *	__init_end = .;
+ *
+ *	_stext = .;
+ *	TEXT_SECTION = 0
+ *	_etext = .;
+ *
+ *      _sdata = .;
+ *	RO_DATA_SECTION(PAGE_SIZE)
+ *	RW_DATA_SECTION(...)
+ *	_edata = .;
+ *
+ *	EXCEPTION_TABLE(...)
+ *	NOTES
+ *
+ *	BSS_SECTION(0, 0, 0)
+ *	_end = .;
+ *
+ *	STABS_DEBUG
+ *	DWARF_DEBUG
+ *
+ *	DISCARDS		// must be the last
+ * }
+ *
+ * [__init_begin, __init_end] is the init section that may be freed after init
+ * [_stext, _etext] is the text section
+ * [_sdata, _edata] is the data section
+ *
+ * Some of the included output section have their own set of constants.
+ * Examples are: [__initramfs_start, __initramfs_end] for initramfs and
+ *               [__nosave_begin, __nosave_end] for the nosave data
+ */
+/* Align . to a 8 byte boundary equals to maximum function alignment. */
+/*
+ * Align to a 32 byte boundary equal to the
+ * alignment gcc 4.5 uses for a struct
+ */
+/* The actual configuration determine if the init/exit sections
+ * are handled as text/data or they can be discarded (which
+ * often happens at runtime)
+ */
+/* .data section */
+/*
+ * Data section helpers
+ */
+/*
+ * Read only Data
+ */
+/* RODATA & RO_DATA provided for backward compatibility.
+ * All archs are supposed to use RO_DATA() */
+/* .text section. Map to function alignment to avoid address changes
+ * during second ld run in second ld pass when generating System.map */
+/* sched.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+/* spinlock.text is aling to function alignment to secure we have same
+ * address even at second ld pass when generating System.map */
+/* Section used for early init (in .S files) */
+/*
+ * Exception table
+ */
+/*
+ * Init task
+ */
+/* init and exit section handling */
+/*
+ * bss (Block Started by Symbol) - uninitialized data
+ * zeroed during startup
+ */
+/*
+ * DWARF debug sections.
+ * Symbols in the DWARF debugging sections are relative to
+ * the beginning of the section so we begin them at 0.
+ */
+  /* Stabs debugging sections.  */
+/*
+ * Default discarded sections.
+ *
+ * Some archs want to discard exit text/data at runtime rather than
+ * link time due to cross-section references such as alt instructions,
+ * bug table, eh_frame, etc.  DISCARDS must be the last of output
+ * section definitions so that such archs put those in earlier section
+ * definitions.
+ */
+/**
+ * PERCPU_INPUT - the percpu input sections
+ * @cacheline: cacheline size
+ *
+ * The core percpu section names and core symbols which do not rely
+ * directly upon load addresses.
+ *
+ * @cacheline is used to align subsections to avoid false cacheline
+ * sharing between subsections for different purposes.
+ */
+/**
+ * PERCPU_VADDR - define output section for percpu area
+ * @cacheline: cacheline size
+ * @vaddr: explicit base address (optional)
+ * @phdr: destination PHDR (optional)
+ *
+ * Macro which expands to output section for percpu area.
+ *
+ * @cacheline is used to align subsections to avoid false cacheline
+ * sharing between subsections for different purposes.
+ *
+ * If @vaddr is not blank, it specifies explicit base address and all
+ * percpu symbols will be offset from the given address.  If blank,
+ * @vaddr always equals @laddr + LOAD_OFFSET.
+ *
+ * @phdr defines the output PHDR to use if not blank.  Be warned that
+ * output PHDR is sticky.  If @phdr is specified, the next output
+ * section in the linker script will go there too.  @phdr should have
+ * a leading colon.
+ *
+ * Note that this macros defines __per_cpu_load as an absolute symbol.
+ * If there is no need to put the percpu section at a predetermined
+ * address, use PERCPU_SECTION.
+ */
+/**
+ * PERCPU_SECTION - define output section for percpu area, simple version
+ * @cacheline: cacheline size
+ *
+ * Align to PAGE_SIZE and outputs output section for percpu area.  This
+ * macro doesn't manipulate @vaddr or @phdr and __per_cpu_load and
+ * __per_cpu_start will be identical.
+ *
+ * This macro is equivalent to ALIGN(PAGE_SIZE); PERCPU_VADDR(@cacheline,,)
+ * except that __per_cpu_load is defined as a relative symbol against
+ * .data..percpu which is required for relocatable x86_32 configuration.
+ */
+/*
+ * Definition of the high level *_SECTION macros
+ * They will fit only a subset of the architectures
+ */
+/*
+ * Writeable data.
+ * All sections are combined in a single .data section.
+ * The sections following CONSTRUCTORS are arranged so their
+ * typical alignment matches.
+ * A cacheline is typical/always less than a PAGE_SIZE so
+ * the sections that has this restriction (or similar)
+ * is located before the ones requiring PAGE_SIZE alignment.
+ * NOSAVE_DATA starts and ends with a PAGE_SIZE alignment which
+ * matches the requirement of PAGE_ALIGNED_DATA.
+ *
+ * use 0 as page_align if page_aligned data is not used */
+/*
+ *  arch/arm/include/asm/thread_info.h
+ *
+ *  Copyright (C) 2002 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * Allow us to mark functions as 'deprecated' and have gcc emit a nice
+ * warning for each use, in hopes of speeding the functions removal.
+ * Usage is:
+ * 		int __deprecated foo(void)
+ */
+/*
+ * Allow us to avoid 'defined but not used' warnings on functions and data,
+ * as well as force them to be emitted to the assembly file.
+ *
+ * As of gcc 3.4, static functions that are not marked with attribute((used))
+ * may be elided from the assembly file.  As of gcc 3.4, static data not so
+ * marked will not be elided, but this may change in a future gcc version.
+ *
+ * NOTE: Because distributions shipped with a backported unit-at-a-time
+ * compiler in gcc 3.3, we must define __used to be __attribute__((used))
+ * for gcc >=3.3 instead of 3.4.
+ *
+ * In prior versions of gcc, such functions and data would be emitted, but
+ * would be warned about except with attribute((unused)).
+ *
+ * Mark functions that are referenced only in inline assembly as __used so
+ * the code is emitted even though it appears to be unreferenced.
+ */
+/*
+ * Rather then using noinline to prevent stack consumption, use
+ * noinline_for_stack instead.  For documentaiton reasons.
+ */
+/*
+ * From the GCC manual:
+ *
+ * Many functions do not examine any values except their arguments,
+ * and have no effects except the return value.  Basically this is
+ * just slightly more strict class than the `pure' attribute above,
+ * since function is not allowed to read global memory.
+ *
+ * Note that a function that has pointer arguments and examines the
+ * data pointed to must _not_ be declared `const'.  Likewise, a
+ * function that calls a non-`const' function usually must not be
+ * `const'.  It does not make sense for a `const' function to return
+ * `void'.
+ */
+/*
+ * Tell gcc if a function is cold. The compiler will assume any path
+ * directly leading to the call is unlikely.
+ */
+/* Simple shorthand for a section definition */
+/* Are two types/vars the same type (ignoring qualifiers)? */
+/* Compile time object size, -1 for unknown */
+/*
+ * Prevent the compiler from merging or refetching accesses.  The compiler
+ * is also forbidden from reordering successive instances of ACCESS_ONCE(),
+ * but only when the compiler is aware of some particular ordering.  One way
+ * to make the compiler aware of ordering is to put the two invocations of
+ * ACCESS_ONCE() in different C statements.
+ *
+ * This macro does absolutely -nothing- to prevent the CPU from reordering,
+ * merging, or refetching absolutely anything at any time.  Its main intended
+ * use is to mediate communication between process-level code and irq/NMI
+ * handlers, all running on the same CPU.
+ */
+/*
+ *  arch/arm/include/asm/fpstate.h
+ *
+ *  Copyright (C) 1995 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * We use bit 30 of the preempt_count to indicate that kernel
+ * preemption is occurring.  See <asm/hardirq.h>.
+ */
+/*
+ * thread information flags:
+ *  TIF_SYSCALL_TRACE	- syscall trace active
+ *  TIF_SIGPENDING	- signal pending
+ *  TIF_NEED_RESCHED	- rescheduling necessary
+ *  TIF_NOTIFY_RESUME	- callback before returning to user
+ *  TIF_USEDFPU		- FPU was used by this task this quantum (SMP)
+ *  TIF_POLLING_NRFLAG	- true if poll_idle() is polling TIF_NEED_RESCHED
+ */
+/*
+ * Change these and you break ASM code in entry-common.S
+ */
+/*
+ *  arch/arm/include/asm/memory.h
+ *
+ *  Copyright (C) 2000-2002 Russell King
+ *  modification for nommu, Hyok S. Choi, 2004
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Note: this file should not be included by non-asm/.h files
+ */
+/* const.h: Macros for dealing with constants.  */
+/* Some constant macros are used in both assembler and
+ * C code.  Therefore we cannot annotate them always with
+ * 'UL' and other type specifiers unilaterally.  We
+ * use the following macros to deal with this.
+ *
+ * Similarly, _AT() will cast an expression with a type in C, but
+ * leave it unchanged in asm.
+ */
+/*
+ * asm-generic/int-ll64.h
+ *
+ * Integer declarations for architectures which use "long long"
+ * for 64-bit types.
+ */
+/*
+ * There seems to be no way of detecting this automatically from user
+ * space, so 64 bit architectures should override this in their
+ * bitsperlong.h. In particular, an architecture that supports
+ * both 32 and 64 bit user space must not rely on CONFIG_64BIT
+ * to decide it, but rather check a compiler provided macro.
+ */
+/*
+ * FIXME: The check currently breaks x86-64 build, so it's
+ * temporarily disabled. Please fix x86-64 and reenable
+ */
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+/* arch/arm/mach-s3c2410/include/mach/memory.h
+ *  from arch/arm/mach-rpc/include/mach/memory.h
+ *
+ *  Copyright (C) 1996,1997,1998 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+/*
+ * linux/include/asm-generic/sizes.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/*
+ * Allow for constants defined here to be used from assembly code
+ * by prepending the UL suffix only with actual C code compilation.
+ */
+/*
+ * PAGE_OFFSET - the virtual address of the start of the kernel image
+ * TASK_SIZE - the maximum size of a user space task.
+ * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area
+ */
+/*
+ * The maximum size of a 26-bit user space task.
+ */
+/*
+ * The module space lives between the addresses given by TASK_SIZE
+ * and PAGE_OFFSET - it must be within 32MB of the kernel text.
+ */
+/*
+ * The highmem pkmap virtual space shares the end of the module area.
+ */
+/*
+ * The XIP kernel gets mapped at the bottom of the module vm area.
+ * Since we use sections to map it, this macro replaces the physical address
+ * with its virtual address while keeping offset from the base section.
+ */
+/*
+ * Allow 16MB-aligned ioremap pages
+ */
+/*
+ * Size of DMA-consistent memory region.  Must be multiple of 2M,
+ * between 2MB and 14MB inclusive.
+ */
+/*
+ * We fix the TCM memories max 32 KiB ITCM resp DTCM at these
+ * locations
+ */
+/*
+ * Convert a physical address to a Page Frame Number and back
+ */
+/*
+ * Convert a page to/from a physical address
+ */
+/*
+ *  arch/arm/include/asm/page.h
+ *
+ *  Copyright (C) 1995-2003 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/* PAGE_SHIFT determines the page size */
+OUTPUT_ARCH(arm)
+ENTRY(stext)
+jiffies = jiffies_64;
+SECTIONS
+{
+ /*
+	 * XXX: The linker does not define how output sections are
+	 * assigned to input sections when there are multiple statements
+	 * matching the same input section name.  There is no documented
+	 * order of matching.
+	 *
+	 * unwind exit sections must be discarded before the rest of the
+	 * unwind sections get included.
+	 */
+ /DISCARD/ : {
+  *(.ARM.exidx.exit.text)
+  *(.ARM.extab.exit.text)
+  *(.ARM.exidx.cpuexit.text)
+  *(.ARM.extab.cpuexit.text)
+  *(.exit.text) *(.cpuexit.text) *(.memexit.text)
+  *(.exit.data) *(.cpuexit.data) *(.cpuexit.rodata) *(.memexit.data) *(.memexit.rodata)
+  *(.exitcall.exit)
+  *(.alt.smp.init)
+  *(.discard)
+  *(.discard.*)
+ }
+ . = 0xC0000000 + 0x00008000;
+ .head.text : {
+  _text = .;
+  *(.head.text)
+ }
+ .text : { /* Real text segment		*/
+  _stext = .; /* Text and read-only data	*/
+   __exception_text_start = .;
+   *(.exception.text)
+   __exception_text_end = .;
+  
+   . = ALIGN(8); *(.text.hot) *(.text) *(.ref.text) *(.devinit.text) *(.devexit.text) *(.text.unlikely)
+   . = ALIGN(8); __sched_text_start = .; *(.sched.text) __sched_text_end = .;
+   . = ALIGN(8); __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
+   . = ALIGN(8); __kprobes_text_start = .; *(.kprobes.text) __kprobes_text_end = .;
+   *(.fixup)
+   *(.gnu.warning)
+   *(.glue_7)
+   *(.glue_7t)
+  . = ALIGN(4);
+  *(.got) /* Global offset table		*/
+  
+ }
+ . = ALIGN(((1 << 12))); .rodata : AT(ADDR(.rodata) - 0) { __start_rodata = .; *(.rodata) *(.rodata.*) *(__vermagic) . = ALIGN(8); __start___tracepoints_ptrs = .; *(__tracepoints_ptrs) __stop___tracepoints_ptrs = .; *(__markers_strings) *(__tracepoints_strings) } .rodata1 : AT(ADDR(.rodata1) - 0) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; __start_pci_fixups_resume = .; *(.pci_fixup_resume) __end_pci_fixups_resume = .; __start_pci_fixups_resume_early = .; *(.pci_fixup_resume_early) __end_pci_fixups_resume_early = .; __start_pci_fixups_suspend = .; *(.pci_fixup_suspend) __end_pci_fixups_suspend = .; } .builtin_fw : AT(ADDR(.builtin_fw) - 0) { __start_builtin_fw = .; *(.builtin_fw) __end_builtin_fw = .; } .rio_ops : AT(ADDR(.rio_ops) - 0) { __start_rio_switch_ops = .; *(.rio_switch_ops) __end_rio_switch_ops = .; } __ksymtab : AT(ADDR(__ksymtab) - 0) { __start___ksymtab = .; *(SORT(___ksymtab+*)) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0) { __start___ksymtab_gpl = .; *(SORT(___ksymtab_gpl+*)) __stop___ksymtab_gpl = .; } __ksymtab_unused : AT(ADDR(__ksymtab_unused) - 0) { __start___ksymtab_unused = .; *(SORT(___ksymtab_unused+*)) __stop___ksymtab_unused = .; } __ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - 0) { __start___ksymtab_unused_gpl = .; *(SORT(___ksymtab_unused_gpl+*)) __stop___ksymtab_unused_gpl = .; } __ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - 0) { __start___ksymtab_gpl_future = .; *(SORT(___ksymtab_gpl_future+*)) __stop___ksymtab_gpl_future = .; } __kcrctab : AT(ADDR(__kcrctab) - 0) { __start___kcrctab = .; *(SORT(___kcrctab+*)) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0) { __start___kcrctab_gpl = .; *(SORT(___kcrctab_gpl+*)) __stop___kcrctab_gpl = .; } __kcrctab_unused : AT(ADDR(__kcrctab_unused) - 0) { __start___kcrctab_unused = .; *(SORT(___kcrctab_unused+*)) __stop___kcrctab_unused = .; } __kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - 0) { __start___kcrctab_unused_gpl = .; *(SORT(___kcrctab_unused_gpl+*)) __stop___kcrctab_unused_gpl = .; } __kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - 0) { __start___kcrctab_gpl_future = .; *(SORT(___kcrctab_gpl_future+*)) __stop___kcrctab_gpl_future = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0) { *(__ksymtab_strings) } __init_rodata : AT(ADDR(__init_rodata) - 0) { *(.ref.rodata) *(.devinit.rodata) *(.devexit.rodata) } __param : AT(ADDR(__param) - 0) { __start___param = .; *(__param) __stop___param = .; } __modver : AT(ADDR(__modver) - 0) { __start___modver = .; *(__modver) __stop___modver = .; . = ALIGN(((1 << 12))); __end_rodata = .; } . = ALIGN(((1 << 12)));
+ /*
+	 * Stack unwinding tables
+	 */
+ . = ALIGN(8);
+ .ARM.unwind_idx : {
+  __start_unwind_idx = .;
+  *(.ARM.exidx*)
+  __stop_unwind_idx = .;
+ }
+ .ARM.unwind_tab : {
+  __start_unwind_tab = .;
+  *(.ARM.extab*)
+  __stop_unwind_tab = .;
+ }
+ _etext = .; /* End of text and rodata section */
+ . = ALIGN((1 << 12));
+ __init_begin = .;
+ . = ALIGN(8); .init.text : AT(ADDR(.init.text) - 0) { _sinittext = .; *(.init.text) *(.cpuinit.text) *(.meminit.text) _einittext = .; }
+ .exit.text : {
+ 
+ }
+ .init.proc.info : {
+  __proc_info_begin = .; *(.proc.info.init) __proc_info_end = .;
+ }
+ .init.arch.info : {
+  __arch_info_begin = .;
+  *(.arch.info.init)
+  __arch_info_end = .;
+ }
+ .init.tagtable : {
+  __tagtable_begin = .;
+  *(.taglist.init)
+  __tagtable_end = .;
+ }
+ .init.pv_table : {
+  __pv_table_begin = .;
+  *(.pv_table)
+  __pv_table_end = .;
+ }
+ .init.data : {
+  *(.init.data) *(.cpuinit.data) *(.meminit.data) *(.init.rodata) *(.cpuinit.rodata) *(.meminit.rodata) . = ALIGN(32); __dtb_start = .; *(.dtb.init.rodata) __dtb_end = .;
+  . = ALIGN(16); __setup_start = .; *(.init.setup) __setup_end = .;
+  __initcall_start = .; *(.initcallearly.init) __early_initcall_end = .; *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init) *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) *(.initcall7.init) *(.initcall7s.init) __initcall_end = .;
+  __con_initcall_start = .; *(.con_initcall.init) __con_initcall_end = .;
+  __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .;
+  . = ALIGN(4); __initramfs_start = .; *(.init.ramfs) . = ALIGN(8); *(.init.ramfs.info)
+ }
+ .exit.data : {
+ 
+ }
+ . = ALIGN((1 << 12)); .data..percpu : AT(ADDR(.data..percpu) - 0) { __per_cpu_load = .; __per_cpu_start = .; *(.data..percpu..first) . = ALIGN((1 << 12)); *(.data..percpu..page_aligned) . = ALIGN(32); *(.data..percpu..readmostly) . = ALIGN(32); *(.data..percpu) *(.data..percpu..shared_aligned) __per_cpu_end = .; }
+ __init_end = .;
+ . = ALIGN(8192);
+ __data_loc = .;
+ .data : AT(__data_loc) {
+  _data = .; /* address in memory */
+  _sdata = .;
+  /*
+		 * first, the init task union, aligned
+		 * to an 8192 byte boundary.
+		 */
+  . = ALIGN(8192); *(.data..init_task)
+  . = ALIGN((1 << 12)); __nosave_begin = .; *(.data..nosave) . = ALIGN((1 << 12)); __nosave_end = .;
+  . = ALIGN(32); *(.data..cacheline_aligned)
+  . = ALIGN(32); *(.data..read_mostly) . = ALIGN(32);
+  /*
+		 * The exception fixup table (might need resorting at runtime)
+		 */
+  . = ALIGN(32);
+  __start___ex_table = .;
+  *(__ex_table)
+  __stop___ex_table = .;
+  /*
+		 * and the usual data section
+		 */
+  *(.data) *(.ref.data) *(.data..shared_aligned) *(.devinit.data) *(.devexit.data) . = ALIGN(32); *(__tracepoints) . = ALIGN(8); __start___jump_table = .; *(__jump_table) __stop___jump_table = .; . = ALIGN(8); __start___verbose = .; *(__verbose) __stop___verbose = .;
+  CONSTRUCTORS
+  _edata = .;
+ }
+ _edata_loc = __data_loc + SIZEOF(.data);
+ .notes : AT(ADDR(.notes) - 0) { __start_notes = .; *(.note.*) __stop_notes = .; }
+ . = ALIGN(0); __bss_start = .; . = ALIGN(0); .sbss : AT(ADDR(.sbss) - 0) { *(.sbss) *(.scommon) } . = ALIGN(0); .bss : AT(ADDR(.bss) - 0) { *(.bss..page_aligned) *(.dynbss) *(.bss) *(COMMON) } . = ALIGN(0); __bss_stop = .;
+ _end = .;
+ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) }
+ .comment 0 : { *(.comment) }
+}
+/*
+ * These must never be empty
+ * If you have to comment these two assert statements out, your
+ * binutils is too old (for other reasons as well)
+ */
+ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
+ASSERT((__arch_info_end - __arch_info_begin), "no machine record defined")
diff -uprN linux-3.1.5-orig/arch/arm/mach-s3c2440/mach-mini2440.c linux-3.1.5/arch/arm/mach-s3c2440/mach-mini2440.c
--- linux-3.1.5-orig/arch/arm/mach-s3c2440/mach-mini2440.c	2011-12-09 09:57:05.000000000 -0700
+++ linux-3.1.5/arch/arm/mach-s3c2440/mach-mini2440.c	2012-10-25 16:43:21.651044579 -0600
@@ -167,6 +167,24 @@ static struct s3c2410fb_display mini2440
 		.lcdcon5	= (S3C2410_LCDCON5_FRM565 |
 				   S3C2410_LCDCON5_HWSWP),
 	},
+    /* mini2440 + 3.5" TFT (LCD-W35i, LQ035Q1DG06 type) + touchscreen*/
+    [3] = {
+        _LCD_DECLARE(
+            /* clock */
+            7,
+            /* xres, margin_right, margin_left, hsync */
+            320, 68, 66, 4,
+            /* yres, margin_top, margin_bottom, vsync */
+            240, 4, 4, 9,
+            /* refresh rate */
+            60),
+        .lcdcon5    = (S3C2410_LCDCON5_FRM565 |
+                   S3C2410_LCDCON5_INVVDEN |
+                   S3C2410_LCDCON5_INVVFRAME |
+                   S3C2410_LCDCON5_INVVLINE |
+                   S3C2410_LCDCON5_INVVCLK |
+                   S3C2410_LCDCON5_HWSWP),
+    },
 };
 
 /* todo - put into gpio header */
diff -uprN linux-3.1.5-orig/.config linux-3.1.5/.config
--- linux-3.1.5-orig/.config	2012-10-25 16:26:54.541586283 -0600
+++ linux-3.1.5/.config	2012-10-25 20:02:49.440330895 -0600
@@ -33,9 +33,9 @@ CONFIG_HAVE_IRQ_WORK=y
 CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_LOCALVERSION="-FriendlyARM"
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_LZO=y
@@ -521,7 +521,6 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_NETFILTER_ADVANCED=y
-CONFIG_BRIDGE_NETFILTER=y
 
 #
 # Core Netfilter Configuration
@@ -539,22 +538,16 @@ CONFIG_BRIDGE_NETFILTER=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_L2TP is not set
-CONFIG_STP=m
-CONFIG_GARP=m
-CONFIG_BRIDGE=m
-CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE is not set
 # CONFIG_NET_DSA is not set
-CONFIG_VLAN_8021Q=m
-CONFIG_VLAN_8021Q_GVRP=y
+# CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
-CONFIG_LLC=m
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
@@ -576,58 +569,10 @@ CONFIG_NET_PKTGEN=m
 # CONFIG_HAMRADIO is not set
 # CONFIG_CAN is not set
 # CONFIG_IRDA is not set
-CONFIG_BT=m
-# CONFIG_BT_L2CAP is not set
-# CONFIG_BT_SCO is not set
-
-#
-# Bluetooth device drivers
-#
-CONFIG_BT_HCIBTUSB=m
-CONFIG_BT_HCIBTSDIO=m
-CONFIG_BT_HCIUART=m
-CONFIG_BT_HCIUART_H4=y
-CONFIG_BT_HCIUART_BCSP=y
-# CONFIG_BT_HCIUART_ATH3K is not set
-CONFIG_BT_HCIUART_LL=y
-CONFIG_BT_HCIBCM203X=m
-CONFIG_BT_HCIBPA10X=m
-CONFIG_BT_HCIBFUSB=m
-CONFIG_BT_HCIVHCI=m
-# CONFIG_BT_MRVL is not set
-# CONFIG_BT_ATH3K is not set
+# CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
 CONFIG_FIB_RULES=y
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_SPY=y
-CONFIG_WEXT_PRIV=y
-CONFIG_CFG80211=m
-# CONFIG_NL80211_TESTMODE is not set
-# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
-CONFIG_CFG80211_REG_DEBUG=y
-CONFIG_CFG80211_DEFAULT_PS=y
-# CONFIG_CFG80211_DEBUGFS is not set
-# CONFIG_CFG80211_INTERNAL_REGDB is not set
-CONFIG_CFG80211_WEXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-CONFIG_LIB80211=m
-CONFIG_LIB80211_CRYPT_WEP=m
-CONFIG_LIB80211_CRYPT_CCMP=m
-CONFIG_LIB80211_CRYPT_TKIP=m
-# CONFIG_LIB80211_DEBUG is not set
-CONFIG_MAC80211=m
-CONFIG_MAC80211_HAS_RC=y
-CONFIG_MAC80211_RC_MINSTREL=y
-CONFIG_MAC80211_RC_MINSTREL_HT=y
-CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
-CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
-CONFIG_MAC80211_MESH=y
-CONFIG_MAC80211_LEDS=y
-# CONFIG_MAC80211_DEBUGFS is not set
-# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIRELESS is not set
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
@@ -760,15 +705,13 @@ CONFIG_BLK_DEV_LOOP=m
 CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_DRBD is not set
-CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=65536
 # CONFIG_BLK_DEV_XIP is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
 # CONFIG_BLK_DEV_RBD is not set
@@ -781,50 +724,19 @@ CONFIG_HAVE_IDE=y
 #
 # SCSI device support
 #
-CONFIG_SCSI_MOD=m
+CONFIG_SCSI_MOD=y
 # CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=m
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
 # CONFIG_SCSI_NETLINK is not set
-# CONFIG_SCSI_PROC_FS is not set
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=m
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-CONFIG_CHR_DEV_SG=m
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-CONFIG_SCSI_WAIT_SCAN=m
-
-#
-# SCSI Transports
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_LOWLEVEL is not set
-# CONFIG_SCSI_DH is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
 # CONFIG_MD is not set
-# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_MACVLAN is not set
 # CONFIG_EQUALIZER is not set
-CONFIG_TUN=m
+# CONFIG_TUN is not set
 # CONFIG_VETH is not set
 CONFIG_MII=y
 # CONFIG_PHYLIB is not set
@@ -852,36 +764,7 @@ CONFIG_DM9000_DEBUGLEVEL=4
 # CONFIG_FTMAC100 is not set
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
-CONFIG_WLAN=y
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_RTL8187 is not set
-# CONFIG_MAC80211_HWSIM is not set
-# CONFIG_ATH_COMMON is not set
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-CONFIG_HOSTAP=m
-CONFIG_HOSTAP_FIRMWARE=y
-CONFIG_HOSTAP_FIRMWARE_NVRAM=y
-# CONFIG_IWM is not set
-CONFIG_LIBERTAS=m
-# CONFIG_LIBERTAS_USB is not set
-CONFIG_LIBERTAS_SDIO=m
-# CONFIG_LIBERTAS_SPI is not set
-# CONFIG_LIBERTAS_DEBUG is not set
-# CONFIG_LIBERTAS_MESH is not set
-# CONFIG_P54_COMMON is not set
-# CONFIG_RT2X00 is not set
-# CONFIG_RTL8192SE is not set
-# CONFIG_RTL8192DE is not set
-# CONFIG_RTL8192CU is not set
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX_MENU is not set
-CONFIG_ZD1211RW=m
-CONFIG_ZD1211RW_DEBUG=y
-# CONFIG_MWIFIEX is not set
+# CONFIG_WLAN is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -901,17 +784,8 @@ CONFIG_ZD1211RW_DEBUG=y
 #
 # CAIF transport drivers
 #
-CONFIG_PPP=m
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=m
-CONFIG_PPP_SYNC_TTY=m
-CONFIG_PPP_DEFLATE=m
-CONFIG_PPP_BSDCOMP=m
-CONFIG_PPP_MPPE=m
-# CONFIG_PPPOE is not set
+# CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-CONFIG_SLHC=m
 # CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
@@ -1035,6 +909,11 @@ CONFIG_LEGACY_PTY_COUNT=128
 # CONFIG_N_GSM is not set
 # CONFIG_TRACE_SINK is not set
 CONFIG_DEVKMEM=y
+# CONFIG_MINI2440_HELLO_MODULE is not set
+CONFIG_LEDS_MINI2440=y
+CONFIG_MINI2440_BUTTONS=y
+# CONFIG_MINI2440_BUZZER is not set
+CONFIG_MINI2440_ADC=y
 
 #
 # Serial drivers
@@ -1289,8 +1168,7 @@ CONFIG_SENSORS_LM75=y
 # CONFIG_SENSORS_W83L786NG is not set
 # CONFIG_SENSORS_W83627HF is not set
 # CONFIG_SENSORS_W83627EHF is not set
-CONFIG_THERMAL=m
-CONFIG_THERMAL_HWMON=y
+# CONFIG_THERMAL is not set
 CONFIG_WATCHDOG=y
 # CONFIG_WATCHDOG_CORE is not set
 # CONFIG_WATCHDOG_NOWAYOUT is not set
@@ -1432,7 +1310,7 @@ CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMAR
 CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
 CONFIG_FONTS=y
 CONFIG_FONT_8x8=y
-# CONFIG_FONT_8x16 is not set
+CONFIG_FONT_8x16=y
 # CONFIG_FONT_6x11 is not set
 # CONFIG_FONT_7x14 is not set
 # CONFIG_FONT_PEARL_8x8 is not set
@@ -1445,47 +1323,7 @@ CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_LOGO_LINUX_CLUT224=y
-CONFIG_SOUND=y
-CONFIG_SOUND_OSS_CORE=y
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
-CONFIG_SND=y
-CONFIG_SND_TIMER=y
-CONFIG_SND_PCM=y
-CONFIG_SND_HWDEP=m
-CONFIG_SND_RAWMIDI=m
-CONFIG_SND_JACK=y
-CONFIG_SND_SEQUENCER=m
-CONFIG_SND_SEQ_DUMMY=m
-CONFIG_SND_OSSEMUL=y
-CONFIG_SND_MIXER_OSS=m
-CONFIG_SND_PCM_OSS=m
-CONFIG_SND_PCM_OSS_PLUGINS=y
-CONFIG_SND_SEQUENCER_OSS=y
-CONFIG_SND_DYNAMIC_MINORS=y
-CONFIG_SND_SUPPORT_OLD_API=y
-CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VERBOSE_PRINTK is not set
-# CONFIG_SND_DEBUG is not set
-CONFIG_SND_RAWMIDI_SEQ=m
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_ARM is not set
-# CONFIG_SND_SPI is not set
-CONFIG_SND_USB=y
-CONFIG_SND_USB_AUDIO=m
-# CONFIG_SND_USB_UA101 is not set
-CONFIG_SND_USB_CAIAQ=m
-CONFIG_SND_USB_CAIAQ_INPUT=y
-# CONFIG_SND_USB_6FIRE is not set
-CONFIG_SND_SOC=y
-# CONFIG_SND_SOC_CACHE_LZO is not set
-# CONFIG_SND_SOC_SAMSUNG is not set
-CONFIG_SND_SOC_I2C_AND_SPI=y
-# CONFIG_SND_SOC_ALL_CODECS is not set
-# CONFIG_SOUND_PRIME is not set
+# CONFIG_SOUND is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
 CONFIG_HIDRAW=y
@@ -1506,7 +1344,6 @@ CONFIG_HID_APPLE=y
 CONFIG_HID_BELKIN=y
 CONFIG_HID_CHERRY=y
 CONFIG_HID_CHICONY=y
-# CONFIG_HID_PRODIKEYS is not set
 CONFIG_HID_CYPRESS=y
 # CONFIG_HID_DRAGONRISE is not set
 # CONFIG_HID_EMS_FF is not set
@@ -1584,9 +1421,9 @@ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 #
 # USB Device Class drivers
 #
-CONFIG_USB_ACM=m
+# CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
-CONFIG_USB_WDM=m
+# CONFIG_USB_WDM is not set
 # CONFIG_USB_TMC is not set
 
 #
@@ -1596,84 +1433,17 @@ CONFIG_USB_WDM=m
 #
 # also be needed; see USB_STORAGE Help for more info
 #
-CONFIG_USB_STORAGE=m
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-CONFIG_USB_STORAGE_DATAFAB=m
-# CONFIG_USB_STORAGE_FREECOM is not set
-CONFIG_USB_STORAGE_ISD200=m
-CONFIG_USB_STORAGE_USBAT=m
-CONFIG_USB_STORAGE_SDDR09=m
-CONFIG_USB_STORAGE_SDDR55=m
-CONFIG_USB_STORAGE_JUMPSHOT=m
-CONFIG_USB_STORAGE_ALAUDA=m
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_UAS is not set
 CONFIG_USB_LIBUSUAL=y
 
 #
 # USB Imaging devices
 #
 # CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
 
 #
 # USB port drivers
 #
-CONFIG_USB_SERIAL=m
-# CONFIG_USB_EZUSB is not set
-# CONFIG_USB_SERIAL_GENERIC is not set
-# CONFIG_USB_SERIAL_AIRCABLE is not set
-# CONFIG_USB_SERIAL_ARK3116 is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-CONFIG_USB_SERIAL_CP210X=m
-# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-CONFIG_USB_SERIAL_FTDI_SIO=m
-# CONFIG_USB_SERIAL_FUNSOFT is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_IPAQ is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
-# CONFIG_USB_SERIAL_GARMIN is not set
-# CONFIG_USB_SERIAL_IPW is not set
-# CONFIG_USB_SERIAL_IUU is not set
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-# CONFIG_USB_SERIAL_KLSI is not set
-# CONFIG_USB_SERIAL_KOBIL_SCT is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_MOS7720 is not set
-# CONFIG_USB_SERIAL_MOS7840 is not set
-# CONFIG_USB_SERIAL_MOTOROLA is not set
-# CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_OTI6858 is not set
-# CONFIG_USB_SERIAL_QCAUX is not set
-# CONFIG_USB_SERIAL_QUALCOMM is not set
-CONFIG_USB_SERIAL_SPCP8X5=m
-# CONFIG_USB_SERIAL_HP4X is not set
-# CONFIG_USB_SERIAL_SAFE is not set
-# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
-# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
-# CONFIG_USB_SERIAL_SYMBOL is not set
-# CONFIG_USB_SERIAL_TI is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_OPTION is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
-# CONFIG_USB_SERIAL_OPTICON is not set
-# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
-# CONFIG_USB_SERIAL_ZIO is not set
-# CONFIG_USB_SERIAL_SSU100 is not set
-# CONFIG_USB_SERIAL_DEBUG is not set
+# CONFIG_USB_SERIAL is not set
 
 #
 # USB Miscellaneous drivers
@@ -1710,7 +1480,6 @@ CONFIG_USB_GADGET_VBUS_DRAW=2
 # CONFIG_USB_NET2272 is not set
 # CONFIG_USB_DUMMY_HCD is not set
 CONFIG_USB_ZERO=m
-# CONFIG_USB_AUDIO is not set
 CONFIG_USB_ETH=m
 CONFIG_USB_ETH_RNDIS=y
 # CONFIG_USB_ETH_EEM is not set
@@ -1721,7 +1490,6 @@ CONFIG_USB_FILE_STORAGE=m
 # CONFIG_USB_FILE_STORAGE_TEST is not set
 # CONFIG_USB_MASS_STORAGE is not set
 CONFIG_USB_G_SERIAL=m
-# CONFIG_USB_MIDI_GADGET is not set
 # CONFIG_USB_G_PRINTER is not set
 CONFIG_USB_CDC_COMPOSITE=m
 # CONFIG_USB_G_MULTI is not set
@@ -1894,11 +1662,7 @@ CONFIG_IOMMU_SUPPORT=y
 #
 # File systems
 #
-CONFIG_EXT2_FS=m
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT2_FS is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
 CONFIG_EXT3_FS_XATTR=y
@@ -1969,17 +1733,19 @@ CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+CONFIG_YAFFS_XATTR=y
+# CONFIG_JFFS2_FS is not set
 # CONFIG_LOGFS is not set
 CONFIG_CRAMFS=y
 # CONFIG_SQUASHFS is not set
@@ -2044,44 +1810,44 @@ CONFIG_EFI_PARTITION=y
 # CONFIG_SYSV68_PARTITION is not set
 CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="cp437"
-CONFIG_NLS_CODEPAGE_437=m
-CONFIG_NLS_CODEPAGE_737=m
-CONFIG_NLS_CODEPAGE_775=m
-CONFIG_NLS_CODEPAGE_850=m
-CONFIG_NLS_CODEPAGE_852=m
-CONFIG_NLS_CODEPAGE_855=m
-CONFIG_NLS_CODEPAGE_857=m
-CONFIG_NLS_CODEPAGE_860=m
-CONFIG_NLS_CODEPAGE_861=m
-CONFIG_NLS_CODEPAGE_862=m
-CONFIG_NLS_CODEPAGE_863=m
-CONFIG_NLS_CODEPAGE_864=m
-CONFIG_NLS_CODEPAGE_865=m
-CONFIG_NLS_CODEPAGE_866=m
-CONFIG_NLS_CODEPAGE_869=m
-CONFIG_NLS_CODEPAGE_936=m
-CONFIG_NLS_CODEPAGE_950=m
-CONFIG_NLS_CODEPAGE_932=m
-CONFIG_NLS_CODEPAGE_949=m
-CONFIG_NLS_CODEPAGE_874=m
-CONFIG_NLS_ISO8859_8=m
-CONFIG_NLS_CODEPAGE_1250=m
-CONFIG_NLS_CODEPAGE_1251=m
-CONFIG_NLS_ASCII=m
-CONFIG_NLS_ISO8859_1=m
-CONFIG_NLS_ISO8859_2=m
-CONFIG_NLS_ISO8859_3=m
-CONFIG_NLS_ISO8859_4=m
-CONFIG_NLS_ISO8859_5=m
-CONFIG_NLS_ISO8859_6=m
-CONFIG_NLS_ISO8859_7=m
-CONFIG_NLS_ISO8859_9=m
-CONFIG_NLS_ISO8859_13=m
-CONFIG_NLS_ISO8859_14=m
-CONFIG_NLS_ISO8859_15=m
-CONFIG_NLS_KOI8_R=m
-CONFIG_NLS_KOI8_U=m
-CONFIG_NLS_UTF8=m
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
 # CONFIG_DLM is not set
 
 #
@@ -2189,103 +1955,99 @@ CONFIG_CRYPTO=y
 #
 CONFIG_CRYPTO_ALGAPI=y
 CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=m
 CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER=m
 CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH=m
 CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG=m
 CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_PCOMP=m
 CONFIG_CRYPTO_PCOMP2=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-CONFIG_CRYPTO_GF128MUL=m
-CONFIG_CRYPTO_NULL=m
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
 CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_CRYPTO_CRYPTD=m
-CONFIG_CRYPTO_AUTHENC=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Authenticated Encryption with Associated Data
 #
-CONFIG_CRYPTO_CCM=m
-CONFIG_CRYPTO_GCM=m
-CONFIG_CRYPTO_SEQIV=m
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
 
 #
 # Block modes
 #
 # CONFIG_CRYPTO_CBC is not set
-CONFIG_CRYPTO_CTR=m
-CONFIG_CRYPTO_CTS=m
-CONFIG_CRYPTO_ECB=y
-CONFIG_CRYPTO_LRW=m
-CONFIG_CRYPTO_PCBC=m
-CONFIG_CRYPTO_XTS=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
 
 #
 # Hash modes
 #
-CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_XCBC=m
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
 # CONFIG_CRYPTO_VMAC is not set
 
 #
 # Digest
 #
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_GHASH=m
-CONFIG_CRYPTO_MD4=m
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
 # CONFIG_CRYPTO_MD5 is not set
-CONFIG_CRYPTO_MICHAEL_MIC=y
-CONFIG_CRYPTO_RMD128=m
-CONFIG_CRYPTO_RMD160=m
-CONFIG_CRYPTO_RMD256=m
-CONFIG_CRYPTO_RMD320=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
 CONFIG_CRYPTO_SHA1=m
-CONFIG_CRYPTO_SHA256=m
-CONFIG_CRYPTO_SHA512=m
-CONFIG_CRYPTO_TGR192=m
-CONFIG_CRYPTO_WP512=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
 
 #
 # Ciphers
 #
-CONFIG_CRYPTO_AES=y
-CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
 CONFIG_CRYPTO_ARC4=y
-CONFIG_CRYPTO_BLOWFISH=m
-CONFIG_CRYPTO_CAMELLIA=m
-CONFIG_CRYPTO_CAST5=m
-CONFIG_CRYPTO_CAST6=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
 # CONFIG_CRYPTO_DES is not set
-CONFIG_CRYPTO_FCRYPT=m
-CONFIG_CRYPTO_KHAZAD=m
-CONFIG_CRYPTO_SALSA20=m
-CONFIG_CRYPTO_SEED=m
-CONFIG_CRYPTO_SERPENT=m
-CONFIG_CRYPTO_TEA=m
-CONFIG_CRYPTO_TWOFISH=m
-CONFIG_CRYPTO_TWOFISH_COMMON=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
 
 #
 # Compression
 #
-CONFIG_CRYPTO_DEFLATE=m
-CONFIG_CRYPTO_ZLIB=m
-CONFIG_CRYPTO_LZO=m
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
 
 #
 # Random Number Generation
 #
-CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
 # CONFIG_CRYPTO_USER_API_HASH is not set
 # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_HW is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
@@ -2301,8 +2063,6 @@ CONFIG_CRC7=y
 CONFIG_LIBCRC32C=m
 # CONFIG_CRC8 is not set
 CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_LZO_COMPRESS=m
 CONFIG_LZO_DECOMPRESS=y
 CONFIG_XZ_DEC=y
 CONFIG_XZ_DEC_X86=y
diff -uprN linux-3.1.5-orig/drivers/char/Kconfig linux-3.1.5/drivers/char/Kconfig
--- linux-3.1.5-orig/drivers/char/Kconfig	2011-12-09 09:57:05.000000000 -0700
+++ linux-3.1.5/drivers/char/Kconfig	2012-10-25 16:32:43.577698978 -0600
@@ -15,6 +15,43 @@ config DEVKMEM
 	  kind of kernel debugging operations.
 	  When in doubt, say "N".
 
+config MINI2440_HELLO_MODULE
+    tristate "Mini2440 module sample"
+    depends on MACH_MINI2440
+    default m if MACH_MINI2440
+    help
+      Mini2440 module sample.
+
+config LEDS_MINI2440
+    tristate "LED Support for Mini2440 GPIO LEDs"
+    depends on MACH_MINI2440
+    default y if MACH_MINI2440
+    help
+      This option enables support for LEDs connected to GPIO lines
+      on Mini2440 boards.
+
+config MINI2440_BUTTONS
+    tristate "Buttons driver for FriendlyARM Mini2440 development boards"
+    depends on MACH_MINI2440
+    default y if MACH_MINI2440
+    help
+      this is buttons driver for FriendlyARM Mini2440 development boards
+
+config MINI2440_BUZZER
+    tristate "Buzzer driver for FriendlyARM Mini2440 development boards"
+    depends on MACH_MINI2440
+    default y if MACH_MINI2440
+    help
+      this is buzzer driver for FriendlyARM Mini2440 development boards
+
+config MINI2440_ADC
+    bool "ADC driver for FriendlyARM Mini2440 development boards"
+    depends on MACH_MINI2440
+    default y if MACH_MINI2440
+    help
+      this is ADC driver for FriendlyARM Mini2440 development boards
+      Notes: the touch-screen-driver required this option
+
 config STALDRV
 	bool "Stallion multiport serial support"
 	depends on SERIAL_NONSTANDARD
diff -uprN linux-3.1.5-orig/drivers/char/Makefile linux-3.1.5/drivers/char/Makefile
--- linux-3.1.5-orig/drivers/char/Makefile	2011-12-09 09:57:05.000000000 -0700
+++ linux-3.1.5/drivers/char/Makefile	2012-10-25 16:31:18.911457609 -0600
@@ -64,4 +64,10 @@ obj-$(CONFIG_RAMOOPS)		+= ramoops.o
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_LEDS_MINI2440)	+= mini2440_leds.o
+obj-$(CONFIG_MINI2440_HELLO_MODULE) += mini2440_hello_module.o
+obj-$(CONFIG_MINI2440_BUTTONS)	+= mini2440_buttons.o
+obj-$(CONFIG_MINI2440_BUZZER)	+= mini2440_pwm.o
+obj-$(CONFIG_MINI2440_ADC)	+= mini2440_adc.o
+
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
diff -uprN linux-3.1.5-orig/drivers/char/mini2440_adc.c linux-3.1.5/drivers/char/mini2440_adc.c
--- linux-3.1.5-orig/drivers/char/mini2440_adc.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/mini2440_adc.c	2012-10-25 17:42:39.424861074 -0600
@@ -0,0 +1,201 @@
+/*
+ * Modified by Doug Abbott, 10/25/12, to replace semaphore with mutex
+ */
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <mach/regs-clock.h>
+#include <plat/regs-timer.h>
+	 
+#include <plat/regs-adc.h>
+#include <mach/regs-gpio.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+
+#include "s3c24xx-adc.h"
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINTK(x...) {printk(__FUNCTION__"(%d): ",__LINE__);printk(##x);}
+#else
+#define DPRINTK(x...) (void)(0)
+#endif
+
+#define DEVICE_NAME	"adc"
+
+static void __iomem *base_addr;
+
+typedef struct {
+	wait_queue_head_t wait;
+	int channel;
+	int prescale;
+}ADC_DEV;
+
+DEFINE_MUTEX(ADC_LOCK);
+static int OwnADC = 0;
+
+static ADC_DEV adcdev;
+static volatile int ev_adc = 0;
+static int adc_data;
+
+static struct clk	*adc_clock;
+
+#define ADCCON      (*(volatile unsigned long *)(base_addr + S3C2410_ADCCON))	//ADC control
+#define ADCTSC      (*(volatile unsigned long *)(base_addr + S3C2410_ADCTSC))	//ADC touch screen control
+#define ADCDLY      (*(volatile unsigned long *)(base_addr + S3C2410_ADCDLY))	//ADC start or Interval Delay
+#define ADCDAT0     (*(volatile unsigned long *)(base_addr + S3C2410_ADCDAT0))	//ADC conversion data 0
+#define ADCDAT1     (*(volatile unsigned long *)(base_addr + S3C2410_ADCDAT1))	//ADC conversion data 1
+#define ADCUPDN     (*(volatile unsigned long *)(base_addr + 0x14))	//Stylus Up/Down interrupt status
+
+#define PRESCALE_DIS        (0 << 14)
+#define PRESCALE_EN         (1 << 14)
+#define PRSCVL(x)           ((x) << 6)
+#define ADC_INPUT(x)        ((x) << 3)
+#define ADC_START           (1 << 0)
+#define ADC_ENDCVT          (1 << 15)
+
+#define START_ADC_AIN(ch, prescale) \
+	do{ \
+		ADCCON = PRESCALE_EN | PRSCVL(prescale) | ADC_INPUT((ch)) ; \
+		ADCCON |= ADC_START; \
+	}while(0)
+
+
+static irqreturn_t adcdone_int_handler(int irq, void *dev_id)
+{
+	if (OwnADC) {
+		adc_data = ADCDAT0 & 0x3ff;
+
+		ev_adc = 1;
+		wake_up_interruptible(&adcdev.wait);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static ssize_t s3c2410_adc_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	char str[20];
+	int value;
+	size_t len;
+	if (mutex_trylock(&ADC_LOCK)) {
+		OwnADC = 1;
+		START_ADC_AIN(adcdev.channel, adcdev.prescale);
+		wait_event_interruptible(adcdev.wait, ev_adc);
+
+		ev_adc = 0;
+
+		DPRINTK("AIN[%d] = 0x%04x, %d\n", adcdev.channel, adc_data, ADCCON & 0x80 ? 1:0);
+
+		value = adc_data;
+
+		OwnADC = 0;
+		mutex_unlock(&ADC_LOCK);
+	} else {
+		value = -1;
+	}
+
+	len = sprintf(str, "%d\n", value);
+	if (count >= len) {
+		int r = copy_to_user(buffer, str, len);
+		return r ? r : len;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static int s3c2410_adc_open(struct inode *inode, struct file *filp)
+{
+	init_waitqueue_head(&(adcdev.wait));
+
+	adcdev.channel=0;
+	adcdev.prescale=0xff;
+
+	DPRINTK( "adc opened\n");
+	return 0;
+}
+
+static int s3c2410_adc_release(struct inode *inode, struct file *filp)
+{
+	DPRINTK( "adc closed\n");
+	return 0;
+}
+
+
+static struct file_operations dev_fops = {
+	owner:	THIS_MODULE,
+	open:	s3c2410_adc_open,
+	read:	s3c2410_adc_read,	
+	release:	s3c2410_adc_release,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	base_addr=ioremap(S3C2410_PA_ADC,0x20);
+	if (base_addr == NULL) {
+		printk(KERN_ERR "Failed to remap register block\n");
+		return -ENOMEM;
+	}
+
+	adc_clock = clk_get(NULL, "adc");
+	if (!adc_clock) {
+		printk(KERN_ERR "failed to get adc clock source\n");
+		return -ENOENT;
+	}
+	clk_enable(adc_clock);
+	
+	/* normal ADC */
+	ADCTSC = 0;
+
+	ret = request_irq(IRQ_ADC, adcdone_int_handler, IRQF_SHARED, DEVICE_NAME, &adcdev);
+	if (ret) {
+		iounmap(base_addr);
+		return ret;
+	}
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	free_irq(IRQ_ADC, &adcdev);
+	iounmap(base_addr);
+
+	if (adc_clock) {
+		clk_disable(adc_clock);
+		clk_put(adc_clock);
+		adc_clock = NULL;
+	}
+
+	misc_deregister(&misc);
+}
+
+EXPORT_SYMBOL(ADC_LOCK);
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+
diff -uprN linux-3.1.5-orig/drivers/char/mini2440_buttons.c linux-3.1.5/drivers/char/mini2440_buttons.c
--- linux-3.1.5-orig/drivers/char/mini2440_buttons.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/mini2440_buttons.c	2009-12-31 01:39:22.000000000 -0700
@@ -0,0 +1,173 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <mach/regs-gpio.h>
+#include <mach/hardware.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+#include <linux/sched.h>
+#include <linux/gpio.h>
+
+#define DEVICE_NAME     "buttons"
+
+struct button_irq_desc {
+    int irq;
+    int pin;
+    int pin_setting;
+    int number;
+    char *name;	
+};
+
+static struct button_irq_desc button_irqs [] = {
+    {IRQ_EINT8 , S3C2410_GPG(0) ,  S3C2410_GPG0_EINT8  , 0, "KEY0"},
+    {IRQ_EINT11, S3C2410_GPG(3) ,  S3C2410_GPG3_EINT11 , 1, "KEY1"},
+    {IRQ_EINT13, S3C2410_GPG(5) ,  S3C2410_GPG5_EINT13 , 2, "KEY2"},
+    {IRQ_EINT14, S3C2410_GPG(6) ,  S3C2410_GPG6_EINT14 , 3, "KEY3"},
+    {IRQ_EINT15, S3C2410_GPG(7) ,  S3C2410_GPG7_EINT15 , 4, "KEY4"},
+    {IRQ_EINT19, S3C2410_GPG(11),  S3C2410_GPG11_EINT19, 5, "KEY5"},
+};
+static volatile char key_values [] = {'0', '0', '0', '0', '0', '0'};
+
+static DECLARE_WAIT_QUEUE_HEAD(button_waitq);
+
+static volatile int ev_press = 0;
+
+
+static irqreturn_t buttons_interrupt(int irq, void *dev_id)
+{
+    struct button_irq_desc *button_irqs = (struct button_irq_desc *)dev_id;
+    int down;
+
+    // udelay(0);
+    down = !s3c2410_gpio_getpin(button_irqs->pin);
+
+    if (down != (key_values[button_irqs->number] & 1)) { // Changed
+
+	key_values[button_irqs->number] = '0' + down;
+	
+        ev_press = 1;
+        wake_up_interruptible(&button_waitq);
+    }
+    
+    return IRQ_RETVAL(IRQ_HANDLED);
+}
+
+
+static int s3c24xx_buttons_open(struct inode *inode, struct file *file)
+{
+    int i;
+    int err = 0;
+    
+    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
+	if (button_irqs[i].irq < 0) {
+		continue;
+	}
+        err = request_irq(button_irqs[i].irq, buttons_interrupt, IRQ_TYPE_EDGE_BOTH, 
+                          button_irqs[i].name, (void *)&button_irqs[i]);
+        if (err)
+            break;
+    }
+
+    if (err) {
+        i--;
+        for (; i >= 0; i--) {
+	    if (button_irqs[i].irq < 0) {
+		continue;
+	    }
+	    disable_irq(button_irqs[i].irq);
+            free_irq(button_irqs[i].irq, (void *)&button_irqs[i]);
+        }
+        return -EBUSY;
+    }
+
+    ev_press = 1;
+    
+    return 0;
+}
+
+
+static int s3c24xx_buttons_close(struct inode *inode, struct file *file)
+{
+    int i;
+    
+    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
+	if (button_irqs[i].irq < 0) {
+	    continue;
+	}
+	free_irq(button_irqs[i].irq, (void *)&button_irqs[i]);
+    }
+
+    return 0;
+}
+
+
+static int s3c24xx_buttons_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
+{
+    unsigned long err;
+
+    if (!ev_press) {
+	if (filp->f_flags & O_NONBLOCK)
+	    return -EAGAIN;
+	else
+	    wait_event_interruptible(button_waitq, ev_press);
+    }
+    
+    ev_press = 0;
+
+    err = copy_to_user(buff, (const void *)key_values, min(sizeof(key_values), count));
+
+    return err ? -EFAULT : min(sizeof(key_values), count);
+}
+
+static unsigned int s3c24xx_buttons_poll( struct file *file, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+    poll_wait(file, &button_waitq, wait);
+    if (ev_press)
+        mask |= POLLIN | POLLRDNORM;
+    return mask;
+}
+
+
+static struct file_operations dev_fops = {
+    .owner   =   THIS_MODULE,
+    .open    =   s3c24xx_buttons_open,
+    .release =   s3c24xx_buttons_close, 
+    .read    =   s3c24xx_buttons_read,
+    .poll    =   s3c24xx_buttons_poll,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
diff -uprN linux-3.1.5-orig/drivers/char/mini2440_hello_module.c linux-3.1.5/drivers/char/mini2440_hello_module.c
--- linux-3.1.5-orig/drivers/char/mini2440_hello_module.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/mini2440_hello_module.c	2009-12-31 01:41:37.000000000 -0700
@@ -0,0 +1,18 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+
+static int __init mini2440_hello_module_init(void)
+{
+    printk("Hello, Mini2440 module is installed !\n");
+    return 0;
+}
+
+static void __exit mini2440_hello_module_cleanup(void)
+{
+    printk("Good-bye, Mini2440 module was removed!\n");
+}
+
+module_init(mini2440_hello_module_init);
+module_exit(mini2440_hello_module_cleanup);
+MODULE_LICENSE("GPL");
diff -uprN linux-3.1.5-orig/drivers/char/mini2440_leds.c linux-3.1.5/drivers/char/mini2440_leds.c
--- linux-3.1.5-orig/drivers/char/mini2440_leds.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/mini2440_leds.c	2012-10-25 17:21:07.927872745 -0600
@@ -0,0 +1,101 @@
+/*
+ * Modified by Doug Abbott, 10/25/12, to replace ioctl with unlocked_ioctl
+ */
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+#include <mach/regs-gpio.h>
+#include <mach/hardware.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <asm/unistd.h>
+
+
+#define DEVICE_NAME "leds"
+
+static unsigned long led_table [] = {
+	S3C2410_GPB(5),
+	S3C2410_GPB(6),
+	S3C2410_GPB(7),
+	S3C2410_GPB(8),
+};
+
+static unsigned int led_cfg_table [] = {
+	S3C2410_GPIO_OUTPUT,
+	S3C2410_GPIO_OUTPUT,
+	S3C2410_GPIO_OUTPUT,
+	S3C2410_GPIO_OUTPUT,
+};
+
+static long sbc2440_leds_ioctl(
+	struct file *file, 
+	unsigned int cmd, 
+	unsigned long arg)
+{
+	switch(cmd) {
+	case 0:
+	case 1:
+		if (arg > 4) {
+			return -EINVAL;
+		}
+		s3c2410_gpio_setpin(led_table[arg], !cmd);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct file_operations dev_fops = {
+	.owner	=	THIS_MODULE,
+	.unlocked_ioctl	=	sbc2440_leds_ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	int i;
+	
+	for (i = 0; i < 4; i++) {
+		s3c2410_gpio_cfgpin(led_table[i], led_cfg_table[i]);
+		s3c2410_gpio_setpin(led_table[i], 0);
+	}
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
diff -uprN linux-3.1.5-orig/drivers/char/mini2440_pwm.c linux-3.1.5/drivers/char/mini2440_pwm.c
--- linux-3.1.5-orig/drivers/char/mini2440_pwm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/mini2440_pwm.c	2012-10-25 17:30:36.734241038 -0600
@@ -0,0 +1,157 @@
+/*
+ * Modified by Doug Abbott, 1/25/12 to replace ioctl with unlocked_ioctl
+ * Replaced semaphore with mutex
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <mach/regs-gpio.h>
+#include <mach/hardware.h>
+#include <plat/regs-timer.h>
+#include <mach/regs-irq.h>
+#include <asm/mach/time.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+
+#define DEVICE_NAME     "pwm"
+
+#define PWM_IOCTL_SET_FREQ		1
+#define PWM_IOCTL_STOP			0
+
+static struct mutex lock;
+
+/* freq:  pclk/50/16/65536 ~ pclk/50/16 
+  * if pclk = 50MHz, freq is 1Hz to 62500Hz
+  * human ear : 20Hz~ 20000Hz
+  */
+static void PWM_Set_Freq( unsigned long freq )
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+
+	struct clk *clk_p;
+	unsigned long pclk;
+
+	//set GPB0 as tout0, pwm output
+	s3c2410_gpio_cfgpin(S3C2410_GPB(0), S3C2410_GPB0_TOUT0);
+
+	tcon = __raw_readl(S3C2410_TCON);
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg0 = __raw_readl(S3C2410_TCFG0);
+
+	//prescaler = 50
+	tcfg0 &= ~S3C2410_TCFG_PRESCALER0_MASK;
+	tcfg0 |= (50 - 1); 
+
+	//mux = 1/16
+	tcfg1 &= ~S3C2410_TCFG1_MUX0_MASK;
+	tcfg1 |= S3C2410_TCFG1_MUX0_DIV16;
+
+	__raw_writel(tcfg1, S3C2410_TCFG1);
+	__raw_writel(tcfg0, S3C2410_TCFG0);
+
+	clk_p = clk_get(NULL, "pclk");
+	pclk  = clk_get_rate(clk_p);
+	tcnt  = (pclk/50/16)/freq;
+	
+	__raw_writel(tcnt, S3C2410_TCNTB(0));
+	__raw_writel(tcnt/2, S3C2410_TCMPB(0));
+				
+	tcon &= ~0x1f;
+	tcon |= 0xb;		//disable deadzone, auto-reload, inv-off, update TCNTB0&TCMPB0, start timer 0
+	__raw_writel(tcon, S3C2410_TCON);
+	
+	tcon &= ~2;			//clear manual update bit
+	__raw_writel(tcon, S3C2410_TCON);
+}
+
+static void PWM_Stop(void)
+{
+	s3c2410_gpio_cfgpin(S3C2410_GPB(0), S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_setpin(S3C2410_GPB(0), 0);
+}
+
+static int s3c24xx_pwm_open(struct inode *inode, struct file *file)
+{
+	if (mutex_trylock(&lock))
+		return 0;
+	else
+		return -EBUSY;
+}
+
+
+static int s3c24xx_pwm_close(struct inode *inode, struct file *file)
+{
+	PWM_Stop();
+	mutex_unlock (&lock);
+    return 0;
+}
+
+
+static long s3c24xx_pwm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	//printk("ioctl pwm: %x %lx\n", cmd, arg);
+	switch (cmd) {
+	case PWM_IOCTL_SET_FREQ:
+		if (arg == 0)
+			return -EINVAL;
+		PWM_Set_Freq(arg);
+		break;
+
+	case PWM_IOCTL_STOP:
+		PWM_Stop();
+		break;
+	}
+
+	return 0;
+}
+
+
+static struct file_operations dev_fops = {
+    .owner   =   THIS_MODULE,
+    .open    =   s3c24xx_pwm_open,
+    .release =   s3c24xx_pwm_close, 
+    .unlocked_ioctl   =   s3c24xx_pwm_ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	mutex_init(&lock);
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+    	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("S3C2410/S3C2440 PWM Driver");
diff -uprN linux-3.1.5-orig/drivers/char/s3c24xx-adc.h linux-3.1.5/drivers/char/s3c24xx-adc.h
--- linux-3.1.5-orig/drivers/char/s3c24xx-adc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/drivers/char/s3c24xx-adc.h	2009-12-31 00:14:12.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef _S3C2410_ADC_H_
+#define _S3C2410_ADC_H_
+
+#define ADC_WRITE(ch, prescale)	((ch)<<16|(prescale))
+
+#define ADC_WRITE_GETCH(data)	(((data)>>16)&0x7)
+#define ADC_WRITE_GETPRE(data)	((data)&0xff)
+
+#endif /* _S3C2410_ADC_H_ */
diff -uprN linux-3.1.5-orig/fs/Kconfig linux-3.1.5/fs/Kconfig
--- linux-3.1.5-orig/fs/Kconfig	2011-12-09 09:57:05.000000000 -0700
+++ linux-3.1.5/fs/Kconfig	2012-10-25 16:28:38.613881147 -0600
@@ -199,6 +199,7 @@ source "fs/hfsplus/Kconfig"
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+source "fs/yaffs2/Kconfig"
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff -uprN linux-3.1.5-orig/fs/Kconfig.pre.yaffs linux-3.1.5/fs/Kconfig.pre.yaffs
--- linux-3.1.5-orig/fs/Kconfig.pre.yaffs	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/Kconfig.pre.yaffs	2011-12-09 09:57:05.000000000 -0700
@@ -0,0 +1,280 @@
+#
+# File system configuration
+#
+
+menu "File systems"
+
+if BLOCK
+
+source "fs/ext2/Kconfig"
+source "fs/ext3/Kconfig"
+source "fs/ext4/Kconfig"
+
+config FS_XIP
+# execute in place
+	bool
+	depends on EXT2_FS_XIP
+	default y
+
+source "fs/jbd/Kconfig"
+source "fs/jbd2/Kconfig"
+
+config FS_MBCACHE
+# Meta block cache for Extended Attributes (ext2/ext3/ext4)
+	tristate
+	default y if EXT2_FS=y && EXT2_FS_XATTR
+	default y if EXT3_FS=y && EXT3_FS_XATTR
+	default y if EXT4_FS=y && EXT4_FS_XATTR
+	default m if EXT2_FS_XATTR || EXT3_FS_XATTR || EXT4_FS_XATTR
+
+source "fs/reiserfs/Kconfig"
+source "fs/jfs/Kconfig"
+
+source "fs/xfs/Kconfig"
+source "fs/gfs2/Kconfig"
+source "fs/ocfs2/Kconfig"
+source "fs/btrfs/Kconfig"
+source "fs/nilfs2/Kconfig"
+
+endif # BLOCK
+
+# Posix ACL utility routines
+#
+# Note: Posix ACLs can be implemented without these helpers.  Never use
+# this symbol for ifdefs in core code.
+#
+config FS_POSIX_ACL
+	def_bool n
+
+config EXPORTFS
+	tristate
+
+config FILE_LOCKING
+	bool "Enable POSIX file locking API" if EXPERT
+	default y
+	help
+	  This option enables standard file locking support, required
+          for filesystems like NFS and for the flock() system
+          call. Disabling this option saves about 11k.
+
+source "fs/notify/Kconfig"
+
+source "fs/quota/Kconfig"
+
+source "fs/autofs4/Kconfig"
+source "fs/fuse/Kconfig"
+
+config CUSE
+	tristate "Character device in Userspace support"
+	depends on FUSE_FS
+	help
+	  This FUSE extension allows character devices to be
+	  implemented in userspace.
+
+	  If you want to develop or use userspace character device
+	  based on CUSE, answer Y or M.
+
+config GENERIC_ACL
+	bool
+	select FS_POSIX_ACL
+
+menu "Caches"
+
+source "fs/fscache/Kconfig"
+source "fs/cachefiles/Kconfig"
+
+endmenu
+
+if BLOCK
+menu "CD-ROM/DVD Filesystems"
+
+source "fs/isofs/Kconfig"
+source "fs/udf/Kconfig"
+
+endmenu
+endif # BLOCK
+
+if BLOCK
+menu "DOS/FAT/NT Filesystems"
+
+source "fs/fat/Kconfig"
+source "fs/ntfs/Kconfig"
+
+endmenu
+endif # BLOCK
+
+menu "Pseudo filesystems"
+
+source "fs/proc/Kconfig"
+source "fs/sysfs/Kconfig"
+
+config TMPFS
+	bool "Virtual memory file system support (former shm fs)"
+	depends on SHMEM
+	help
+	  Tmpfs is a file system which keeps all files in virtual memory.
+
+	  Everything in tmpfs is temporary in the sense that no files will be
+	  created on your hard drive. The files live in memory and swap
+	  space. If you unmount a tmpfs instance, everything stored therein is
+	  lost.
+
+	  See <file:Documentation/filesystems/tmpfs.txt> for details.
+
+config TMPFS_POSIX_ACL
+	bool "Tmpfs POSIX Access Control Lists"
+	depends on TMPFS
+	select TMPFS_XATTR
+	select GENERIC_ACL
+	help
+	  POSIX Access Control Lists (ACLs) support additional access rights
+	  for users and groups beyond the standard owner/group/world scheme,
+	  and this option selects support for ACLs specifically for tmpfs
+	  filesystems.
+
+	  If you've selected TMPFS, it's possible that you'll also need
+	  this option as there are a number of Linux distros that require
+	  POSIX ACL support under /dev for certain features to work properly.
+	  For example, some distros need this feature for ALSA-related /dev
+	  files for sound to work properly.  In short, if you're not sure,
+	  say Y.
+
+	  To learn more about Access Control Lists, visit the POSIX ACLs for
+	  Linux website <http://acl.bestbits.at/>.
+
+config TMPFS_XATTR
+	bool "Tmpfs extended attributes"
+	depends on TMPFS
+	default n
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page, or visit
+	  <http://acl.bestbits.at/> for details).
+
+	  Currently this enables support for the trusted.* and
+	  security.* namespaces.
+
+	  You need this for POSIX ACL support on tmpfs.
+
+	  If unsure, say N.
+
+config HUGETLBFS
+	bool "HugeTLB file system support"
+	depends on X86 || IA64 || SPARC64 || (S390 && 64BIT) || \
+		   SYS_SUPPORTS_HUGETLBFS || BROKEN
+	help
+	  hugetlbfs is a filesystem backing for HugeTLB pages, based on
+	  ramfs. For architectures that support it, say Y here and read
+	  <file:Documentation/vm/hugetlbpage.txt> for details.
+
+	  If unsure, say N.
+
+config HUGETLB_PAGE
+	def_bool HUGETLBFS
+
+source "fs/configfs/Kconfig"
+
+endmenu
+
+menuconfig MISC_FILESYSTEMS
+	bool "Miscellaneous filesystems"
+	default y
+	---help---
+	  Say Y here to get to see options for various miscellaneous
+	  filesystems, such as filesystems that came from other
+	  operating systems.
+
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and
+	  disabled; if unsure, say Y here.
+
+if MISC_FILESYSTEMS
+
+source "fs/adfs/Kconfig"
+source "fs/affs/Kconfig"
+source "fs/ecryptfs/Kconfig"
+source "fs/hfs/Kconfig"
+source "fs/hfsplus/Kconfig"
+source "fs/befs/Kconfig"
+source "fs/bfs/Kconfig"
+source "fs/efs/Kconfig"
+source "fs/jffs2/Kconfig"
+# UBIFS File system configuration
+source "fs/ubifs/Kconfig"
+source "fs/logfs/Kconfig"
+source "fs/cramfs/Kconfig"
+source "fs/squashfs/Kconfig"
+source "fs/freevxfs/Kconfig"
+source "fs/minix/Kconfig"
+source "fs/omfs/Kconfig"
+source "fs/hpfs/Kconfig"
+source "fs/qnx4/Kconfig"
+source "fs/romfs/Kconfig"
+source "fs/pstore/Kconfig"
+source "fs/sysv/Kconfig"
+source "fs/ufs/Kconfig"
+source "fs/exofs/Kconfig"
+
+endif # MISC_FILESYSTEMS
+
+menuconfig NETWORK_FILESYSTEMS
+	bool "Network File Systems"
+	default y
+	depends on NET
+	---help---
+	  Say Y here to get to see options for network filesystems and
+	  filesystem-related networking code, such as NFS daemon and
+	  RPCSEC security modules.
+
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and
+	  disabled; if unsure, say Y here.
+
+if NETWORK_FILESYSTEMS
+
+source "fs/nfs/Kconfig"
+source "fs/nfsd/Kconfig"
+
+config LOCKD
+	tristate
+	depends on FILE_LOCKING
+
+config LOCKD_V4
+	bool
+	depends on NFSD_V3 || NFS_V3
+	depends on FILE_LOCKING
+	default y
+
+config NFS_ACL_SUPPORT
+	tristate
+	select FS_POSIX_ACL
+
+config NFS_COMMON
+	bool
+	depends on NFSD || NFS_FS
+	default y
+
+source "net/sunrpc/Kconfig"
+source "fs/ceph/Kconfig"
+source "fs/cifs/Kconfig"
+source "fs/ncpfs/Kconfig"
+source "fs/coda/Kconfig"
+source "fs/afs/Kconfig"
+source "fs/9p/Kconfig"
+
+endif # NETWORK_FILESYSTEMS
+
+if BLOCK
+menu "Partition Types"
+
+source "fs/partitions/Kconfig"
+
+endmenu
+endif
+
+source "fs/nls/Kconfig"
+source "fs/dlm/Kconfig"
+
+endmenu
diff -uprN linux-3.1.5-orig/fs/Makefile linux-3.1.5/fs/Makefile
--- linux-3.1.5-orig/fs/Makefile	2011-12-09 09:57:05.000000000 -0700
+++ linux-3.1.5/fs/Makefile	2012-10-25 16:28:38.636881211 -0600
@@ -123,3 +123,4 @@ obj-$(CONFIG_GFS2_FS)           += gfs2/
 obj-$(CONFIG_EXOFS_FS)          += exofs/
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -uprN linux-3.1.5-orig/fs/Makefile.pre.yaffs linux-3.1.5/fs/Makefile.pre.yaffs
--- linux-3.1.5-orig/fs/Makefile.pre.yaffs	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/Makefile.pre.yaffs	2012-10-25 16:28:38.635881209 -0600
@@ -0,0 +1,125 @@
+#
+# Makefile for the Linux filesystems.
+#
+# 14 Sep 2000, Christoph Hellwig <hch@infradead.org>
+# Rewritten to use lists instead of if-statements.
+# 
+
+obj-y :=	open.o read_write.o file_table.o super.o \
+		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
+		ioctl.o readdir.o select.o fifo.o dcache.o inode.o \
+		attr.o bad_inode.o file.o filesystems.o namespace.o \
+		seq_file.o xattr.o libfs.o fs-writeback.o \
+		pnode.o drop_caches.o splice.o sync.o utimes.o \
+		stack.o fs_struct.o statfs.o
+
+ifeq ($(CONFIG_BLOCK),y)
+obj-y +=	buffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o
+else
+obj-y +=	no-block.o
+endif
+
+obj-$(CONFIG_BLK_DEV_INTEGRITY) += bio-integrity.o
+obj-y				+= notify/
+obj-$(CONFIG_EPOLL)		+= eventpoll.o
+obj-$(CONFIG_ANON_INODES)	+= anon_inodes.o
+obj-$(CONFIG_SIGNALFD)		+= signalfd.o
+obj-$(CONFIG_TIMERFD)		+= timerfd.o
+obj-$(CONFIG_EVENTFD)		+= eventfd.o
+obj-$(CONFIG_AIO)               += aio.o
+obj-$(CONFIG_FILE_LOCKING)      += locks.o
+obj-$(CONFIG_COMPAT)		+= compat.o compat_ioctl.o
+obj-$(CONFIG_BINFMT_AOUT)	+= binfmt_aout.o
+obj-$(CONFIG_BINFMT_EM86)	+= binfmt_em86.o
+obj-$(CONFIG_BINFMT_MISC)	+= binfmt_misc.o
+
+# binfmt_script is always there
+obj-y				+= binfmt_script.o
+
+obj-$(CONFIG_BINFMT_ELF)	+= binfmt_elf.o
+obj-$(CONFIG_COMPAT_BINFMT_ELF)	+= compat_binfmt_elf.o
+obj-$(CONFIG_BINFMT_ELF_FDPIC)	+= binfmt_elf_fdpic.o
+obj-$(CONFIG_BINFMT_SOM)	+= binfmt_som.o
+obj-$(CONFIG_BINFMT_FLAT)	+= binfmt_flat.o
+
+obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
+obj-$(CONFIG_FS_POSIX_ACL)	+= posix_acl.o xattr_acl.o
+obj-$(CONFIG_NFS_COMMON)	+= nfs_common/
+obj-$(CONFIG_GENERIC_ACL)	+= generic_acl.o
+
+obj-$(CONFIG_FHANDLE)		+= fhandle.o
+
+obj-y				+= quota/
+
+obj-$(CONFIG_PROC_FS)		+= proc/
+obj-y				+= partitions/
+obj-$(CONFIG_SYSFS)		+= sysfs/
+obj-$(CONFIG_CONFIGFS_FS)	+= configfs/
+obj-y				+= devpts/
+
+obj-$(CONFIG_PROFILING)		+= dcookies.o
+obj-$(CONFIG_DLM)		+= dlm/
+ 
+# Do not add any filesystems before this line
+obj-$(CONFIG_FSCACHE)		+= fscache/
+obj-$(CONFIG_REISERFS_FS)	+= reiserfs/
+obj-$(CONFIG_EXT3_FS)		+= ext3/ # Before ext2 so root fs can be ext3
+obj-$(CONFIG_EXT2_FS)		+= ext2/
+# We place ext4 after ext2 so plain ext2 root fs's are mounted using ext2
+# unless explicitly requested by rootfstype
+obj-$(CONFIG_EXT4_FS)		+= ext4/
+obj-$(CONFIG_JBD)		+= jbd/
+obj-$(CONFIG_JBD2)		+= jbd2/
+obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
+obj-y				+= ramfs/
+obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
+obj-$(CONFIG_CODA_FS)		+= coda/
+obj-$(CONFIG_MINIX_FS)		+= minix/
+obj-$(CONFIG_FAT_FS)		+= fat/
+obj-$(CONFIG_BFS_FS)		+= bfs/
+obj-$(CONFIG_ISO9660_FS)	+= isofs/
+obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
+obj-$(CONFIG_HFS_FS)		+= hfs/
+obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
+obj-$(CONFIG_VXFS_FS)		+= freevxfs/
+obj-$(CONFIG_NFS_FS)		+= nfs/
+obj-$(CONFIG_EXPORTFS)		+= exportfs/
+obj-$(CONFIG_NFSD)		+= nfsd/
+obj-$(CONFIG_LOCKD)		+= lockd/
+obj-$(CONFIG_NLS)		+= nls/
+obj-$(CONFIG_SYSV_FS)		+= sysv/
+obj-$(CONFIG_CIFS)		+= cifs/
+obj-$(CONFIG_NCP_FS)		+= ncpfs/
+obj-$(CONFIG_HPFS_FS)		+= hpfs/
+obj-$(CONFIG_NTFS_FS)		+= ntfs/
+obj-$(CONFIG_UFS_FS)		+= ufs/
+obj-$(CONFIG_EFS_FS)		+= efs/
+obj-$(CONFIG_JFFS2_FS)		+= jffs2/
+obj-$(CONFIG_LOGFS)		+= logfs/
+obj-$(CONFIG_UBIFS_FS)		+= ubifs/
+obj-$(CONFIG_AFFS_FS)		+= affs/
+obj-$(CONFIG_ROMFS_FS)		+= romfs/
+obj-$(CONFIG_QNX4FS_FS)		+= qnx4/
+obj-$(CONFIG_AUTOFS4_FS)	+= autofs4/
+obj-$(CONFIG_ADFS_FS)		+= adfs/
+obj-$(CONFIG_FUSE_FS)		+= fuse/
+obj-$(CONFIG_UDF_FS)		+= udf/
+obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
+obj-$(CONFIG_OMFS_FS)		+= omfs/
+obj-$(CONFIG_JFS_FS)		+= jfs/
+obj-$(CONFIG_XFS_FS)		+= xfs/
+obj-$(CONFIG_9P_FS)		+= 9p/
+obj-$(CONFIG_AFS_FS)		+= afs/
+obj-$(CONFIG_NILFS2_FS)		+= nilfs2/
+obj-$(CONFIG_BEFS_FS)		+= befs/
+obj-$(CONFIG_HOSTFS)		+= hostfs/
+obj-$(CONFIG_HPPFS)		+= hppfs/
+obj-$(CONFIG_CACHEFILES)	+= cachefiles/
+obj-$(CONFIG_DEBUG_FS)		+= debugfs/
+obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
+obj-$(CONFIG_BTRFS_FS)		+= btrfs/
+obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_EXOFS_FS)          += exofs/
+obj-$(CONFIG_CEPH_FS)		+= ceph/
+obj-$(CONFIG_PSTORE)		+= pstore/
diff -uprN linux-3.1.5-orig/fs/yaffs2/Kconfig linux-3.1.5/fs/yaffs2/Kconfig
--- linux-3.1.5-orig/fs/yaffs2/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/Kconfig	2012-10-25 16:28:38.655881264 -0600
@@ -0,0 +1,161 @@
+#
+# yaffs file system configurations
+#
+
+config YAFFS_FS
+	tristate "yaffs2 file system support"
+	default n
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  yaffs2, or Yet Another Flash File System, is a file system
+	  optimised for NAND Flash chips.
+
+	  To compile the yaffs2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on yaffs2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_TAGS_ECC
+	bool "Disable yaffs from doing ECC on tags by default"
+	depends on YAFFS_FS && YAFFS_YAFFS2
+	default n
+	help
+	  This defaults yaffs to using its own ECC calculations on tags instead of
+	  just relying on the MTD.
+	  This behavior can also be overridden with tags_ecc_on and
+	  tags_ecc_off mount options.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally yaffs only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on boot"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BLOCK_REFRESHING
+	bool "Disable yaffs2 block refreshing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then block refreshing is disabled.
+	 Block refreshing infrequently refreshes the oldest block in
+	 a yaffs2 file system. This mechanism helps to refresh flash to
+	 mitigate against data loss. This is particularly useful for MLC.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BACKGROUND
+	bool "Disable yaffs2 background processing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then background processing is disabled.
+	 Background processing makes many foreground activities faster.
+
+	 If unsure, say N.
+
+config YAFFS_XATTR
+	bool "Enable yaffs2 xattr support"
+	depends on YAFFS_FS
+	default y
+	help
+	 If this is set then yaffs2 will provide xattr support.
+	 If unsure, say Y.
diff -uprN linux-3.1.5-orig/fs/yaffs2/Makefile linux-3.1.5/fs/yaffs2/Makefile
--- linux-3.1.5-orig/fs/yaffs2/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/Makefile	2012-10-25 16:28:38.651881250 -0600
@@ -0,0 +1,18 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs.o
+
+yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o
+yaffs-y += yaffs_tagscompat.o
+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
+yaffs-y += yaffs_nameval.o yaffs_attribs.o
+yaffs-y += yaffs_allocator.o
+yaffs-y += yaffs_yaffs1.o
+yaffs-y += yaffs_yaffs2.o
+yaffs-y += yaffs_bitmap.o
+yaffs-y += yaffs_summary.o
+yaffs-y += yaffs_verify.o
+
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_allocator.c linux-3.1.5/fs/yaffs2/yaffs_allocator.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_allocator.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_allocator.c	2012-10-25 16:28:38.676881315 -0600
@@ -0,0 +1,357 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_allocator.h"
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yportenv.h"
+
+/*
+ * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
+ * of approx 100 objects that are themn allocated singly.
+ * This is basically a simplified slab allocator.
+ *
+ * We don't use the Linux slab allocator because slab does not allow
+ * us to dump all the objects in one hit when we do a umount and tear
+ * down  all the tnodes and objects. slab requires that we first free
+ * the individual objects.
+ *
+ * Once yaffs has been mainlined I shall try to motivate for a change
+ * to slab to provide the extra features we need here.
+ */
+
+struct yaffs_tnode_list {
+	struct yaffs_tnode_list *next;
+	struct yaffs_tnode *tnodes;
+};
+
+struct yaffs_obj_list {
+	struct yaffs_obj_list *next;
+	struct yaffs_obj *objects;
+};
+
+struct yaffs_allocator {
+	int n_tnodes_created;
+	struct yaffs_tnode *free_tnodes;
+	int n_free_tnodes;
+	struct yaffs_tnode_list *alloc_tnode_list;
+
+	int n_obj_created;
+	struct list_head free_objs;
+	int n_free_objects;
+
+	struct yaffs_obj_list *allocated_obj_list;
+};
+
+static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->alloc_tnode_list) {
+		tmp = allocator->alloc_tnode_list->next;
+
+		kfree(allocator->alloc_tnode_list->tnodes);
+		kfree(allocator->alloc_tnode_list);
+		allocator->alloc_tnode_list = tmp;
+	}
+
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static void yaffs_init_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->alloc_tnode_list = NULL;
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	int i;
+	struct yaffs_tnode *new_tnodes;
+	u8 *mem;
+	struct yaffs_tnode *curr;
+	struct yaffs_tnode *next;
+	struct yaffs_tnode_list *tnl;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_tnodes < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
+	mem = (u8 *) new_tnodes;
+
+	if (!new_tnodes) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs: Could not allocate Tnodes");
+		return YAFFS_FAIL;
+	}
+
+	/* New hookup for wide tnodes */
+	for (i = 0; i < n_tnodes - 1; i++) {
+		curr = (struct yaffs_tnode *)&mem[i * dev->tnode_size];
+		next = (struct yaffs_tnode *)&mem[(i + 1) * dev->tnode_size];
+		curr->internal[0] = next;
+	}
+
+	curr = (struct yaffs_tnode *)&mem[(n_tnodes - 1) * dev->tnode_size];
+	curr->internal[0] = allocator->free_tnodes;
+	allocator->free_tnodes = (struct yaffs_tnode *)mem;
+
+	allocator->n_free_tnodes += n_tnodes;
+	allocator->n_tnodes_created += n_tnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
+	if (!tnl) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Could not add tnodes to management list");
+		return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = new_tnodes;
+		tnl->next = allocator->alloc_tnode_list;
+		allocator->alloc_tnode_list = tnl;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
+
+	return YAFFS_OK;
+}
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode *tn = NULL;
+
+	if (!allocator) {
+		BUG();
+		return NULL;
+	}
+
+	/* If there are none left make more */
+	if (!allocator->free_tnodes)
+		yaffs_create_tnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (allocator->free_tnodes) {
+		tn = allocator->free_tnodes;
+		allocator->free_tnodes = allocator->free_tnodes->internal[0];
+		allocator->n_free_tnodes--;
+	}
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	if (tn) {
+		tn->internal[0] = allocator->free_tnodes;
+		allocator->free_tnodes = tn;
+		allocator->n_free_tnodes++;
+	}
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+/*--------------- yaffs_obj alloaction ------------------------
+ *
+ * Free yaffs_objs are stored in a list using obj->siblings.
+ * The blocks of allocated objects are stored in a linked list.
+ */
+
+static void yaffs_init_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->allocated_obj_list = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+}
+
+static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	struct yaffs_obj_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->allocated_obj_list) {
+		tmp = allocator->allocated_obj_list->next;
+		kfree(allocator->allocated_obj_list->objects);
+		kfree(allocator->allocated_obj_list);
+		allocator->allocated_obj_list = tmp;
+	}
+
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+	allocator->n_obj_created = 0;
+}
+
+static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	int i;
+	struct yaffs_obj *new_objs;
+	struct yaffs_obj_list *list;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_obj < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_objs = kmalloc(n_obj * sizeof(struct yaffs_obj), GFP_NOFS);
+	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
+
+	if (!new_objs || !list) {
+		kfree(new_objs);
+		new_objs = NULL;
+		kfree(list);
+		list = NULL;
+		yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			"Could not allocate more objects");
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < n_obj; i++)
+		list_add(&new_objs[i].siblings, &allocator->free_objs);
+
+	allocator->n_free_objects += n_obj;
+	allocator->n_obj_created += n_obj;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = new_objs;
+	list->next = allocator->allocated_obj_list;
+	allocator->allocated_obj_list = list;
+
+	return YAFFS_OK;
+}
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = NULL;
+	struct list_head *lh;
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return obj;
+	}
+
+	/* If there are none left make more */
+	if (list_empty(&allocator->free_objs))
+		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (!list_empty(&allocator->free_objs)) {
+		lh = allocator->free_objs.next;
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		list_del_init(lh);
+		allocator->n_free_objects--;
+	}
+
+	return obj;
+}
+
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	/* Link into the free list. */
+	list_add(&obj->siblings, &allocator->free_objs);
+	allocator->n_free_objects++;
+}
+
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+
+	if (!dev->allocator) {
+		BUG();
+		return;
+	}
+
+	yaffs_deinit_raw_tnodes(dev);
+	yaffs_deinit_raw_objs(dev);
+	kfree(dev->allocator);
+	dev->allocator = NULL;
+}
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator;
+
+	if (dev->allocator) {
+		BUG();
+		return;
+	}
+
+	allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
+	if (allocator) {
+		dev->allocator = allocator;
+		yaffs_init_raw_tnodes(dev);
+		yaffs_init_raw_objs(dev);
+	}
+}
+
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_allocator.h linux-3.1.5/fs/yaffs2/yaffs_allocator.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_allocator.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_allocator.h	2012-10-25 16:28:38.741881504 -0600
@@ -0,0 +1,30 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ALLOCATOR_H__
+#define __YAFFS_ALLOCATOR_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev);
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev);
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn);
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev);
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_attribs.c linux-3.1.5/fs/yaffs2/yaffs_attribs.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_attribs.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_attribs.c	2012-10-25 16:28:38.677881320 -0600
@@ -0,0 +1,124 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh)
+{
+	obj->yst_uid = oh->yst_uid;
+	obj->yst_gid = oh->yst_gid;
+	obj->yst_atime = oh->yst_atime;
+	obj->yst_mtime = oh->yst_mtime;
+	obj->yst_ctime = oh->yst_ctime;
+	obj->yst_rdev = oh->yst_rdev;
+}
+
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj)
+{
+	oh->yst_uid = obj->yst_uid;
+	oh->yst_gid = obj->yst_gid;
+	oh->yst_atime = obj->yst_atime;
+	oh->yst_mtime = obj->yst_mtime;
+	oh->yst_ctime = obj->yst_ctime;
+	oh->yst_rdev = obj->yst_rdev;
+
+}
+
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c)
+{
+	obj->yst_mtime = Y_CURRENT_TIME;
+	if (do_a)
+		obj->yst_atime = obj->yst_mtime;
+	if (do_c)
+		obj->yst_ctime = obj->yst_mtime;
+}
+
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev)
+{
+	yaffs_load_current_time(obj, 1, 1);
+	obj->yst_rdev = rdev;
+	obj->yst_uid = uid;
+	obj->yst_gid = gid;
+}
+
+static loff_t yaffs_get_file_size(struct yaffs_obj *obj)
+{
+	YCHAR *alias = NULL;
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.file_variant.file_size;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = obj->variant.symlink_variant.alias;
+		if (!alias)
+			return 0;
+		return strnlen(alias, YAFFS_MAX_ALIAS_LENGTH);
+	default:
+		return 0;
+	}
+}
+
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_resize_file(obj, attr->ia_size);
+
+	yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_get_file_size(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_attribs.h linux-3.1.5/fs/yaffs2/yaffs_attribs.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_attribs.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_attribs.h	2012-10-25 16:28:38.743881508 -0600
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ATTRIBS_H__
+#define __YAFFS_ATTRIBS_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh);
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj);
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev);
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c);
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr);
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_bitmap.c linux-3.1.5/fs/yaffs2/yaffs_bitmap.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_bitmap.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_bitmap.c	2012-10-25 16:28:38.677881320 -0600
@@ -0,0 +1,97 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_bitmap.h"
+#include "yaffs_trace.h"
+/*
+ * Chunk bitmap manipulations
+ */
+
+static inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"BlockBits block %d is not valid",
+			blk);
+		BUG();
+	}
+	return dev->chunk_bits +
+	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
+}
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
+	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Chunk Id (%d:%d) invalid",
+			blk, chunk);
+		BUG();
+	}
+}
+
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	memset(blk_bits, 0, dev->chunk_bit_stride);
+}
+
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++) {
+		if (*blk_bits)
+			return 1;
+		blk_bits++;
+	}
+	return 0;
+}
+
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+	int n = 0;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
+		n += hweight8(*blk_bits);
+
+	return n;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_bitmap.h linux-3.1.5/fs/yaffs2/yaffs_bitmap.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_bitmap.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_bitmap.h	2012-10-25 16:28:38.743881508 -0600
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+#ifndef __YAFFS_BITMAP_H__
+#define __YAFFS_BITMAP_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk);
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk);
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_checkptrw.c linux-3.1.5/fs/yaffs2/yaffs_checkptrw.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_checkptrw.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_checkptrw.c	2012-10-25 16:28:38.688881393 -0600
@@ -0,0 +1,473 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+struct yaffs_checkpt_chunk_hdr {
+	int version;
+	int seq;
+	u32 sum;
+	u32 xor;
+} ;
+
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+static int apply_block_offset(struct yaffs_dev *dev, int block)
+{
+	return block - dev->block_offset;
+}
+
+static void yaffs2_checkpt_init_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	hdr.version = YAFFS_CHECKPOINT_VERSION;
+	hdr.seq = dev->checkpt_page_seq;
+	hdr.sum = dev->checkpt_sum;
+	hdr.xor = dev->checkpt_xor;
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	memcpy(dev->checkpt_buffer, &hdr, sizeof(hdr));
+}
+
+static int yaffs2_checkpt_check_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	memcpy(&hdr, dev->checkpt_buffer, sizeof(hdr));
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	return hdr.version == YAFFS_CHECKPOINT_VERSION &&
+		hdr.seq == dev->checkpt_page_seq &&
+		hdr.sum == dev->checkpt_sum &&
+		hdr.xor == dev->checkpt_xor;
+}
+
+static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
+{
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpt blocks_avail = %d", blocks_avail);
+
+	return (blocks_avail <= 0) ? 0 : 1;
+}
+
+static int yaffs_checkpt_erase(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (!dev->param.erase_fn)
+		return 0;
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checking blocks %d to %d",
+		dev->internal_start_block, dev->internal_end_block);
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		int offset_i = apply_block_offset(dev, i);
+		int result;
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"erasing checkpt block %d", i);
+
+			dev->n_erasures++;
+
+			result = dev->param.erase_fn(dev, offset_i);
+			if(result) {
+				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+				dev->n_erased_blocks++;
+				dev->n_free_chunks +=
+				    dev->param.chunks_per_block;
+			} else {
+				dev->param.bad_block_fn(dev, offset_i);
+				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	return 1;
+}
+
+static void yaffs2_checkpt_find_erased_block(struct yaffs_dev *dev)
+{
+	int i;
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
+		dev->n_erased_blocks, dev->param.n_reserved_blocks,
+		blocks_avail, dev->checkpt_next_block);
+
+	if (dev->checkpt_next_block >= 0 &&
+	    dev->checkpt_next_block <= dev->internal_end_block &&
+	    blocks_avail > 0) {
+
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev, i);
+			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpt_next_block = i + 1;
+				dev->checkpt_cur_block = i;
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"allocating checkpt block %d", i);
+				return;
+			}
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "out of checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+static void yaffs2_checkpt_find_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_ext_tags tags;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"find next checkpt block: start:  blocks %d next %d",
+		dev->blocks_in_checkpt, dev->checkpt_next_block);
+
+	if (dev->blocks_in_checkpt < dev->checkpt_max_blocks)
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			int chunk = i * dev->param.chunks_per_block;
+			enum yaffs_block_state state;
+			u32 seq;
+
+			dev->param.read_chunk_tags_fn(dev,
+					apply_chunk_offset(dev, chunk),
+					NULL, &tags);
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"find next checkpt block: search: block %d state %d oid %d seq %d eccr %d",
+				i, (int) state,
+				tags.obj_id, tags.seq_number,
+				tags.ecc_result);
+
+			if (tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+				continue;
+
+			dev->param.query_block_fn(dev,
+						apply_block_offset(dev, i),
+						&state, &seq);
+			if (state == YAFFS_BLOCK_STATE_DEAD)
+				continue;
+
+			/* Right kind of block */
+			dev->checkpt_next_block = tags.obj_id;
+			dev->checkpt_cur_block = i;
+			dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
+			dev->blocks_in_checkpt++;
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"found checkpt block %d", i);
+			return;
+		}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
+{
+	int i;
+
+	dev->checkpt_open_write = writing;
+
+	/* Got the functions we need? */
+	if (!dev->param.write_chunk_tags_fn ||
+	    !dev->param.read_chunk_tags_fn ||
+	    !dev->param.erase_fn || !dev->param.bad_block_fn)
+		return 0;
+
+	if (writing && !yaffs2_checkpt_space_ok(dev))
+		return 0;
+
+	if (!dev->checkpt_buffer)
+		dev->checkpt_buffer =
+		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	dev->checkpt_page_seq = 0;
+	dev->checkpt_byte_count = 0;
+	dev->checkpt_sum = 0;
+	dev->checkpt_xor = 0;
+	dev->checkpt_cur_block = -1;
+	dev->checkpt_cur_chunk = -1;
+	dev->checkpt_next_block = dev->internal_start_block;
+
+	if (writing) {
+		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+		yaffs2_checkpt_init_chunk_hdr(dev);
+		return yaffs_checkpt_erase(dev);
+	}
+
+	/* Opening for a read */
+	/* Set to a value that will kick off a read */
+	dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
+	/* A checkpoint block list of 1 checkpoint block per 16 block is
+	 * (hopefully) going to be way more than we need */
+	dev->blocks_in_checkpt = 0;
+	dev->checkpt_max_blocks =
+	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
+	dev->checkpt_block_list =
+	    kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
+
+	if (!dev->checkpt_block_list)
+		return 0;
+
+	for (i = 0; i < dev->checkpt_max_blocks; i++)
+		dev->checkpt_block_list[i] = -1;
+
+	return 1;
+}
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
+{
+	u32 composite_sum;
+
+	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
+	*sum = composite_sum;
+	return 1;
+}
+
+static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
+{
+	int chunk;
+	int offset_chunk;
+	struct yaffs_ext_tags tags;
+
+	if (dev->checkpt_cur_block < 0) {
+		yaffs2_checkpt_find_erased_block(dev);
+		dev->checkpt_cur_chunk = 0;
+	}
+
+	if (dev->checkpt_cur_block < 0)
+		return 0;
+
+	tags.is_deleted = 0;
+	tags.obj_id = dev->checkpt_next_block;	/* Hint to next place to look */
+	tags.chunk_id = dev->checkpt_page_seq + 1;
+	tags.seq_number = YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.n_bytes = dev->data_bytes_per_chunk;
+	if (dev->checkpt_cur_chunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		struct yaffs_block_info *bi =
+		    yaffs_get_block_info(dev, dev->checkpt_cur_block);
+		bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocks_in_checkpt++;
+	}
+
+	chunk =
+	    dev->checkpt_cur_block * dev->param.chunks_per_block +
+	    dev->checkpt_cur_chunk;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d",
+		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
+		tags.obj_id, tags.chunk_id);
+
+	offset_chunk = apply_chunk_offset(dev, chunk);
+
+	dev->n_page_writes++;
+
+	dev->param.write_chunk_tags_fn(dev, offset_chunk,
+				       dev->checkpt_buffer, &tags);
+	dev->checkpt_page_seq++;
+	dev->checkpt_cur_chunk++;
+	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
+		dev->checkpt_cur_chunk = 0;
+		dev->checkpt_cur_block = -1;
+	}
+	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+
+	yaffs2_checkpt_init_chunk_hdr(dev);
+
+
+	return 1;
+}
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (!dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+		dev->checkpt_buffer[dev->checkpt_byte_offs] = *data_bytes;
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
+			ok = yaffs2_checkpt_flush_buffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	struct yaffs_ext_tags tags;
+	int chunk;
+	int offset_chunk;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
+
+			if (dev->checkpt_cur_block < 0) {
+				yaffs2_checkpt_find_block(dev);
+				dev->checkpt_cur_chunk = 0;
+			}
+
+			if (dev->checkpt_cur_block < 0) {
+				ok = 0;
+				break;
+			}
+
+			chunk = dev->checkpt_cur_block *
+			    dev->param.chunks_per_block +
+			    dev->checkpt_cur_chunk;
+
+			offset_chunk = apply_chunk_offset(dev, chunk);
+			dev->n_page_reads++;
+
+			/* read in the next chunk */
+			dev->param.read_chunk_tags_fn(dev,
+						offset_chunk,
+						dev->checkpt_buffer,
+						&tags);
+
+			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				ok = 0;
+				break;
+			}
+			if(!yaffs2_checkpt_check_chunk_hdr(dev)) {
+				ok = 0;
+				break;
+			}
+
+			dev->checkpt_page_seq++;
+			dev->checkpt_cur_chunk++;
+
+			if (dev->checkpt_cur_chunk >=
+					dev->param.chunks_per_block)
+				dev->checkpt_cur_block = -1;
+
+		}
+
+		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+	}
+
+	return i;
+}
+
+int yaffs_checkpt_close(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->checkpt_open_write) {
+		if (dev->checkpt_byte_offs !=
+			sizeof(sizeof(struct yaffs_checkpt_chunk_hdr)))
+			yaffs2_checkpt_flush_buffer(dev);
+	} else if (dev->checkpt_block_list) {
+		for (i = 0;
+		     i < dev->blocks_in_checkpt &&
+		     dev->checkpt_block_list[i] >= 0; i++) {
+			int blk = dev->checkpt_block_list[i];
+			struct yaffs_block_info *bi = NULL;
+
+			if (dev->internal_start_block <= blk &&
+			    blk <= dev->internal_end_block)
+				bi = yaffs_get_block_info(dev, blk);
+			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
+				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		}
+		kfree(dev->checkpt_block_list);
+		dev->checkpt_block_list = NULL;
+	}
+
+	dev->n_free_chunks -=
+		dev->blocks_in_checkpt * dev->param.chunks_per_block;
+	dev->n_erased_blocks -= dev->blocks_in_checkpt;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
+		dev->checkpt_byte_count);
+
+	if (dev->checkpt_buffer) {
+		/* free the buffer */
+		kfree(dev->checkpt_buffer);
+		dev->checkpt_buffer = NULL;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev)
+{
+	/* Erase the checkpoint data */
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint invalidate of %d blocks",
+		dev->blocks_in_checkpt);
+
+	return yaffs_checkpt_erase(dev);
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_checkptrw.h linux-3.1.5/fs/yaffs2/yaffs_checkptrw.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_checkptrw.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_checkptrw.h	2012-10-25 16:28:38.743881508 -0600
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing);
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes);
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes);
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum);
+
+int yaffs_checkpt_close(struct yaffs_dev *dev);
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_ecc.c linux-3.1.5/fs/yaffs2/yaffs_ecc.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_ecc.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_ecc.c	2012-10-25 16:28:38.696881390 -0600
@@ -0,0 +1,281 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
+ * such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity,
+ * and therefore this bytes influence on the line parity.
+ */
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {	/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+}
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0;	/* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1;	/* Corrected the error */
+	}
+
+	if ((hweight8(d0) + hweight8(d1) + hweight8(d2)) == 1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1;	/* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc_other)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < n_bytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	ecc_other->col_parity = (col_parity >> 2) & 0x3f;
+	ecc_other->line_parity = line_parity;
+	ecc_other->line_parity_prime = line_parity_prime;
+}
+
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc)
+{
+	unsigned char delta_col;	/* column parity delta */
+	unsigned delta_line;	/* line parity delta */
+	unsigned delta_line_prime;	/* line parity delta */
+	unsigned bit;
+
+	delta_col = read_ecc->col_parity ^ test_ecc->col_parity;
+	delta_line = read_ecc->line_parity ^ test_ecc->line_parity;
+	delta_line_prime =
+	    read_ecc->line_parity_prime ^ test_ecc->line_parity_prime;
+
+	if ((delta_col | delta_line | delta_line_prime) == 0)
+		return 0;	/* no error */
+
+	if (delta_line == ~delta_line_prime &&
+	    (((delta_col ^ (delta_col >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (delta_col & 0x20)
+			bit |= 0x04;
+		if (delta_col & 0x08)
+			bit |= 0x02;
+		if (delta_col & 0x02)
+			bit |= 0x01;
+
+		if (delta_line >= n_bytes)
+			return -1;
+
+		data[delta_line] ^= (1 << bit);
+
+		return 1;	/* corrected */
+	}
+
+	if ((hweight32(delta_line) +
+	     hweight32(delta_line_prime) +
+	     hweight8(delta_col)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1;	/* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_ecc.h linux-3.1.5/fs/yaffs2/yaffs_ecc.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_ecc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_ecc.h	2012-10-25 16:28:38.743881509 -0600
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data.
+ * Thus, two such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+struct yaffs_ecc_other {
+	unsigned char col_parity;
+	unsigned line_parity;
+	unsigned line_parity_prime;
+};
+
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc);
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc);
+
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc);
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc);
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_getblockinfo.h linux-3.1.5/fs/yaffs2/yaffs_getblockinfo.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_getblockinfo.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_getblockinfo.h	2012-10-25 16:28:38.743881509 -0600
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+
+/* Function to manipulate block info */
+static inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
+							      *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs: get_block_info block %d is not valid",
+			blk);
+		BUG();
+	}
+	return &dev->block_info[blk - dev->internal_start_block];
+}
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_guts.c linux-3.1.5/fs/yaffs2/yaffs_guts.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_guts.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_guts.c	2012-10-25 16:28:38.709881391 -0600
@@ -0,0 +1,5010 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_guts.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_nand.h"
+#include "yaffs_yaffs1.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_verify.h"
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nameval.h"
+#include "yaffs_allocator.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
+#define YAFFS_GC_GOOD_ENOUGH 2
+#define YAFFS_GC_PASSIVE_THRESHOLD 4
+
+#include "yaffs_ecc.h"
+
+/* Forward declarations */
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve);
+
+
+
+/* Function to calculate chunk and offset */
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out)
+{
+	int chunk;
+	u32 offset;
+
+	chunk = (u32) (addr >> dev->chunk_shift);
+
+	if (dev->chunk_div == 1) {
+		/* easy power of 2 case */
+		offset = (u32) (addr & dev->chunk_mask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunk_base;
+
+		chunk /= dev->chunk_div;
+
+		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
+		offset = (u32) (addr - chunk_base);
+	}
+
+	*chunk_out = chunk;
+	*offset_out = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static inline u32 calc_shifts_ceiling(u32 x)
+{
+	int extra_bits;
+	int shifts;
+
+	shifts = extra_bits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extra_bits++;
+		x >>= 1;
+		shifts++;
+	}
+
+	if (extra_bits)
+		shifts++;
+
+	return shifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static inline u32 calc_shifts(u32 x)
+{
+	u32 shifts;
+
+	shifts = 0;
+
+	if (!x)
+		return 0;
+
+	while (!(x & 1)) {
+		x >>= 1;
+		shifts++;
+	}
+
+	return shifts;
+}
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
+{
+	int i;
+	u8 *buf = (u8 *) 1;
+
+	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->temp_buffer[i].in_use = 0;
+		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].buffer = buf;
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
+{
+	int i;
+
+	dev->temp_in_use++;
+	if (dev->temp_in_use > dev->max_temp)
+		dev->max_temp = dev->temp_in_use;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].in_use == 0) {
+			dev->temp_buffer[i].in_use = 1;
+			return dev->temp_buffer[i].buffer;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanaged_buffer_allocs++;
+	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
+
+}
+
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
+{
+	int i;
+
+	dev->temp_in_use--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer) {
+			dev->temp_buffer[i].in_use = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		yaffs_trace(YAFFS_TRACE_BUFFERS,
+			"Releasing unmanaged temp buffer");
+		kfree(buffer);
+		dev->unmanaged_buffer_deallocs++;
+	}
+
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
+				     const u8 *data,
+				     const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) data;
+	(void) tags;
+}
+
+static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
+				      const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) tags;
+}
+
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi)
+{
+	if (!bi->gc_prioritise) {
+		bi->gc_prioritise = 1;
+		dev->has_pending_prioritised_gc = 1;
+		bi->chunk_error_strikes++;
+
+		if (bi->chunk_error_strikes > 3) {
+			bi->needs_retiring = 1;	/* Too many stikes, so retire */
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Block struck out");
+
+		}
+	}
+}
+
+static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
+					int erased_ok)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs_handle_chunk_error(dev, bi);
+
+	if (erased_ok) {
+		/* Was an actual write failure,
+		 * so mark the block for retirement.*/
+		bi->needs_retiring = 1;
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  "**>> Block %d needs retiring", flash_block);
+	}
+
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+	yaffs_skip_rest_of_block(dev);
+}
+
+/*
+ * Verification code
+ */
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static inline int yaffs_hash_fn(int n)
+{
+	if (n < 0)
+		n = -n;
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
+{
+	return dev->root_dir;
+}
+
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
+{
+	return dev->lost_n_found;
+}
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_check_ff(u8 *buffer, int n_bytes)
+{
+	/* Horrible, slow implementation */
+	while (n_bytes--) {
+		if (*buffer != 0xff)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
+{
+	int retval = YAFFS_OK;
+	u8 *data = yaffs_get_temp_buffer(dev);
+	struct yaffs_ext_tags tags;
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
+
+	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
+		tags.chunk_used) {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not erased", nand_chunk);
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_release_temp_buffer(dev, data);
+
+	return retval;
+
+}
+
+static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
+				      int nand_chunk,
+				      const u8 *data,
+				      struct yaffs_ext_tags *tags)
+{
+	int retval = YAFFS_OK;
+	struct yaffs_ext_tags temp_tags;
+	u8 *buffer = yaffs_get_temp_buffer(dev);
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
+	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
+	    temp_tags.obj_id != tags->obj_id ||
+	    temp_tags.chunk_id != tags->chunk_id ||
+	    temp_tags.n_bytes != tags->n_bytes)
+		retval = YAFFS_FAIL;
+
+	yaffs_release_temp_buffer(dev, buffer);
+
+	return retval;
+}
+
+
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
+{
+	int reserved_chunks;
+	int reserved_blocks = dev->param.n_reserved_blocks;
+	int checkpt_blocks;
+
+	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
+
+	reserved_chunks =
+	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
+
+	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
+}
+
+static int yaffs_find_alloc_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_block_info *bi;
+
+	if (dev->n_erased_blocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "yaffs tragedy: no more erased blocks");
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		dev->alloc_block_finder++;
+		if (dev->alloc_block_finder < dev->internal_start_block
+		    || dev->alloc_block_finder > dev->internal_end_block) {
+			dev->alloc_block_finder = dev->internal_start_block;
+		}
+
+		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->seq_number++;
+			bi->seq_number = dev->seq_number;
+			dev->n_erased_blocks--;
+			yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			  "Allocated block %d, seq  %d, %d left" ,
+			   dev->alloc_block_finder, dev->seq_number,
+			   dev->n_erased_blocks);
+			return dev->alloc_block_finder;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs tragedy: no more erased blocks, but there should have been %d",
+		dev->n_erased_blocks);
+
+	return -1;
+}
+
+static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
+			     struct yaffs_block_info **block_ptr)
+{
+	int ret_val;
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block < 0) {
+		/* Get next block to allocate off */
+		dev->alloc_block = yaffs_find_alloc_block(dev);
+		dev->alloc_page = 0;
+	}
+
+	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
+		/* No space unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
+	    && dev->alloc_page == 0)
+		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
+
+	/* Next page please.... */
+	if (dev->alloc_block >= 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+
+		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
+		    dev->alloc_page;
+		bi->pages_in_use++;
+		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
+
+		dev->alloc_page++;
+
+		dev->n_free_chunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->alloc_page >= dev->param.chunks_per_block) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		if (block_ptr)
+			*block_ptr = bi;
+
+		return ret_val;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ERROR,
+		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
+
+	return -1;
+}
+
+static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
+{
+	int n;
+
+	n = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	if (dev->alloc_block > 0)
+		n += (dev->param.chunks_per_block - dev->alloc_page);
+
+	return n;
+
+}
+
+/*
+ * yaffs_skip_rest_of_block() skips over the rest of the allocation block
+ * if we don't want to write to it.
+ */
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
+{
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block > 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+	}
+}
+
+static int yaffs_write_new_chunk(struct yaffs_dev *dev,
+				 const u8 *data,
+				 struct yaffs_ext_tags *tags, int use_reserver)
+{
+	int attempts = 0;
+	int write_ok = 0;
+	int chunk;
+
+	yaffs2_checkpt_invalidate(dev);
+
+	do {
+		struct yaffs_block_info *bi = 0;
+		int erased_ok = 0;
+
+		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.        If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 *
+		 * Mods to the above
+		 * If an erase check fails or the write fails we skip the
+		 * rest of the block.
+		 */
+
+		/* let's give it a try */
+		attempts++;
+
+		if (dev->param.always_check_erased)
+			bi->skip_erased_check = 0;
+
+		if (!bi->skip_erased_check) {
+			erased_ok = yaffs_check_chunk_erased(dev, chunk);
+			if (erased_ok != YAFFS_OK) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+				  "**>> yaffs chunk %d was not erased",
+				  chunk);
+
+				/* If not erased, delete this one,
+				 * skip rest of block and
+				 * try another chunk */
+				yaffs_chunk_del(dev, chunk, 1, __LINE__);
+				yaffs_skip_rest_of_block(dev);
+				continue;
+			}
+		}
+
+		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
+
+		if (!bi->skip_erased_check)
+			write_ok =
+			    yaffs_verify_chunk_written(dev, chunk, data, tags);
+
+		if (write_ok != YAFFS_OK) {
+			/* Clean up aborted write, skip to next block and
+			 * try another chunk */
+			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
+			continue;
+		}
+
+		bi->skip_erased_check = 1;
+
+		/* Copy the data into the robustification buffer */
+		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
+
+	} while (write_ok != YAFFS_OK &&
+		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!write_ok)
+		chunk = -1;
+
+	if (attempts > 1) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs write required %d attempts",
+			attempts);
+		dev->n_retried_writes += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs2_checkpt_invalidate(dev);
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
+		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Failed to mark bad and erase block %d",
+				flash_block);
+		} else {
+			struct yaffs_ext_tags tags;
+			int chunk_id =
+			    flash_block * dev->param.chunks_per_block;
+
+			u8 *buffer = yaffs_get_temp_buffer(dev);
+
+			memset(buffer, 0xff, dev->data_bytes_per_chunk);
+			memset(&tags, 0, sizeof(tags));
+			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->param.write_chunk_tags_fn(dev, chunk_id -
+							   dev->chunk_offset,
+							   buffer,
+							   &tags) != YAFFS_OK)
+				yaffs_trace(YAFFS_TRACE_ALWAYS,
+					"yaffs: Failed to write bad block marker to block %d",
+					flash_block);
+
+			yaffs_release_temp_buffer(dev, buffer);
+		}
+	}
+
+	bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+	bi->gc_prioritise = 0;
+	bi->needs_retiring = 0;
+
+	dev->n_retired_blocks++;
+}
+
+/*---------------- Name handling functions ------------*/
+
+static u16 yaffs_calc_name_sum(const YCHAR *name)
+{
+	u16 sum = 0;
+	u16 i = 1;
+
+	if (!name)
+		return 0;
+
+	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
+
+		/* 0x1f mask is case insensitive */
+		sum += ((*name) & 0x1f) * i;
+		i++;
+		name++;
+	}
+	return sum;
+}
+
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
+{
+	memset(obj->short_name, 0, sizeof(obj->short_name));
+	if (name &&
+		strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
+		YAFFS_SHORT_NAME_LENGTH)
+		strcpy(obj->short_name, name);
+	else
+		obj->short_name[0] = _Y('\0');
+	obj->sum = yaffs_calc_name_sum(name);
+}
+
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
+	memset(tmp_name, 0, sizeof(tmp_name));
+	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
+				YAFFS_MAX_NAME_LENGTH + 1);
+	yaffs_set_obj_name(obj, tmp_name);
+#else
+	yaffs_set_obj_name(obj, oh->name);
+#endif
+}
+
+loff_t yaffs_max_file_size(struct yaffs_dev *dev)
+{
+	if(sizeof(loff_t) < 8)
+		return YAFFS_MAX_FILE_SIZE_32;
+	else
+		return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
+
+	if (tn) {
+		memset(tn, 0, dev->tnode_size);
+		dev->n_tnodes++;
+	}
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	yaffs_free_raw_tnode(dev, tn);
+	dev->n_tnodes--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	yaffs_deinit_raw_tnodes_and_objs(dev);
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+}
+
+static void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			unsigned pos, unsigned val)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunk_grp_bits;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	mask = dev->tnode_mask << bit_in_word;
+
+	map[word_in_map] &= ~mask;
+	map[word_in_map] |= (mask & (val << bit_in_word));
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		mask =
+		    dev->tnode_mask >> bit_in_word;
+		map[word_in_map] &= ~mask;
+		map[word_in_map] |= (mask & (val >> bit_in_word));
+	}
+}
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	val = map[word_in_map] >> bit_in_word;
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		val |= (map[word_in_map] << bit_in_word);
+	}
+
+	val &= dev->tnode_mask;
+	val <<= dev->chunk_grp_bits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of top_level
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id)
+{
+	struct yaffs_tnode *tn = file_struct->top;
+	u32 i;
+	int required_depth;
+	int level = file_struct->top_level;
+
+	(void) dev;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level)
+		return NULL;	/* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunk_id >>
+				   (YAFFS_TNODES_LEVEL0_BITS +
+				    (level - 1) *
+				    YAFFS_TNODES_INTERNAL_BITS)) &
+				  YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* add_find_tnode_0 finds the level 0 tnode if it exists,
+ * otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
+ *  specified tn will be plugged into the ttree.
+ */
+
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn)
+{
+	int required_depth;
+	int i;
+	int l;
+	struct yaffs_tnode *tn;
+	u32 x;
+
+	/* Check sane level and page Id */
+	if (file_struct->top_level < 0 ||
+	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = file_struct->top_level; i < required_depth; i++) {
+
+			tn = yaffs_get_tnode(dev);
+
+			if (tn) {
+				tn->internal[0] = file_struct->top;
+				file_struct->top = tn;
+				file_struct->top_level++;
+			} else {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs: no more tnodes");
+				return NULL;
+			}
+		}
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = file_struct->top_level;
+	tn = file_struct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunk_id >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_get_tnode(dev);
+				if (!tn->internal[x])
+					return NULL;
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passed_tn) {
+					/* If we already have one, release it */
+					if (tn->internal[x])
+						yaffs_free_tnode(dev,
+							tn->internal[x]);
+					tn->internal[x] = passed_tn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_get_tnode(dev);
+					if (!tn->internal[x])
+						return NULL;
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passed_tn) {
+			memcpy(tn, passed_tn,
+			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
+			yaffs_free_tnode(dev, passed_tn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
+			    int chunk_obj)
+{
+	return (tags->chunk_id == chunk_obj &&
+		tags->obj_id == obj_id &&
+		!tags->is_deleted) ? 1 : 0;
+
+}
+
+static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
+					struct yaffs_ext_tags *tags, int obj_id,
+					int inode_chunk)
+{
+	int j;
+
+	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
+		if (yaffs_check_chunk_bit
+		    (dev, the_chunk / dev->param.chunks_per_block,
+		     the_chunk % dev->param.chunks_per_block)) {
+
+			if (dev->chunk_grp_size == 1)
+				return the_chunk;
+			else {
+				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+							 tags);
+				if (yaffs_tags_match(tags,
+							obj_id, inode_chunk)) {
+					/* found it; */
+					return the_chunk;
+				}
+			}
+		}
+		the_chunk++;
+	}
+	return -1;
+}
+
+static int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+				    struct yaffs_ext_tags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	int ret_val = -1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+	return ret_val;
+}
+
+static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
+				     struct yaffs_ext_tags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	struct yaffs_dev *dev = in->my_dev;
+	int ret_val = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+
+	/* Delete the entry in the filestructure (if found) */
+	if (ret_val != -1)
+		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
+
+	return ret_val;
+}
+
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan)
+{
+	/* NB in_scan is zero unless scanning.
+	 * For forward scanning, in_scan is > 0;
+	 * for backward scanning in_scan is < 0
+	 *
+	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
+	 */
+
+	struct yaffs_tnode *tn;
+	struct yaffs_dev *dev = in->my_dev;
+	int existing_cunk;
+	struct yaffs_ext_tags existing_tags;
+	struct yaffs_ext_tags new_tags;
+	unsigned existing_serial, new_serial;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file
+		 * during scanning.
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!in_scan) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy:attempt to put data chunk into a non-file"
+				);
+			BUG();
+		}
+
+		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_add_find_tnode_0(dev,
+				    &in->variant.file_variant,
+				    inode_chunk, NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	if (!nand_chunk)
+		/* Dummy insert, bail now */
+		return YAFFS_OK;
+
+	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	if (in_scan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we
+		 * need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags
+		 * so this is quite cheap.
+		 */
+
+		if (existing_cunk > 0) {
+			/* NB Right now existing chunk will not be real
+			 * chunk_id if the chunk group size > 1
+			 * thus we have to do a FindChunkInFile to get the
+			 * real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which
+			 * one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what
+			 * we use, dump the new one.
+			 * YAFFS1: Get both sets of tags and compare serial
+			 * numbers.
+			 */
+
+			if (in_scan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_rd_chunk_tags_nand(dev,
+							 nand_chunk,
+							 NULL, &new_tags);
+
+				/* Do a proper find */
+				existing_cunk =
+				    yaffs_find_chunk_in_file(in, inode_chunk,
+							     &existing_tags);
+			}
+
+			if (existing_cunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: existing chunk < 0 in scan"
+					);
+
+			}
+
+			/* NB The deleted flags should be false, otherwise
+			 * the chunks will not be loaded during a scan
+			 */
+
+			if (in_scan > 0) {
+				new_serial = new_tags.serial_number;
+				existing_serial = existing_tags.serial_number;
+			}
+
+			if ((in_scan > 0) &&
+			    (existing_cunk <= 0 ||
+			     ((existing_serial + 1) & 3) == new_serial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to
+				 * update the tnode
+				 */
+				yaffs_chunk_del(dev, existing_cunk, 1,
+						__LINE__);
+			} else {
+				/* Backward scanning or we want to use the
+				 * existing one
+				 * Delete the new one and return early so that
+				 * the tnode isn't changed
+				 */
+				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existing_cunk == 0)
+		in->n_data_chunks++;
+
+	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
+
+	return YAFFS_OK;
+}
+
+static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
+{
+	struct yaffs_block_info *the_block;
+	unsigned block_no;
+
+	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
+
+	block_no = chunk / dev->param.chunks_per_block;
+	the_block = yaffs_get_block_info(dev, block_no);
+	if (the_block) {
+		the_block->soft_del_pages++;
+		dev->n_free_chunks++;
+		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
+ * the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls
+ * the chunk out of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks
+ * are soft deleted.
+ */
+
+static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
+				 u32 level, int chunk_offset)
+{
+	int i;
+	int the_chunk;
+	int all_done = 1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = YAFFS_NTNODES_INTERNAL - 1;
+			all_done && i >= 0;
+			i--) {
+			if (tn->internal[i]) {
+				all_done =
+				    yaffs_soft_del_worker(in,
+					tn->internal[i],
+					level - 1,
+					(chunk_offset <<
+					YAFFS_TNODES_INTERNAL_BITS)
+					+ i);
+				if (all_done) {
+					yaffs_free_tnode(dev,
+						tn->internal[i]);
+					tn->internal[i] = NULL;
+				} else {
+					/* Can this happen? */
+				}
+			}
+		}
+		return (all_done) ? 1 : 0;
+	}
+
+	/* level 0 */
+	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk) {
+			yaffs_soft_del_chunk(dev, the_chunk);
+			yaffs_load_tnode_0(dev, tn, i, 0);
+		}
+	}
+	return 1;
+}
+
+static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_obj *parent;
+
+	yaffs_verify_obj_in_dir(obj);
+	parent = obj->parent;
+
+	yaffs_verify_dir(parent);
+
+	if (dev && dev->param.remove_obj_fn)
+		dev->param.remove_obj_fn(obj);
+
+	list_del_init(&obj->siblings);
+	obj->parent = NULL;
+
+	yaffs_verify_dir(parent);
+}
+
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
+{
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a null pointer directory"
+			);
+		BUG();
+		return;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a non-directory"
+			);
+		BUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		BUG();
+	}
+
+	yaffs_verify_dir(directory);
+
+	yaffs_remove_obj_from_dir(obj);
+
+	/* Now add it */
+	list_add(&obj->siblings, &directory->variant.dir_variant.children);
+	obj->parent = directory;
+
+	if (directory == obj->my_dev->unlinked_dir
+	    || directory == obj->my_dev->del_dir) {
+		obj->unlinked = 1;
+		obj->my_dev->n_unlinked_files++;
+		obj->rename_allowed = 0;
+	}
+
+	yaffs_verify_dir(directory);
+	yaffs_verify_obj_in_dir(obj);
+}
+
+static int yaffs_change_obj_name(struct yaffs_obj *obj,
+				 struct yaffs_obj *new_dir,
+				 const YCHAR *new_name, int force, int shadows)
+{
+	int unlink_op;
+	int del_op;
+	struct yaffs_obj *existing_target;
+
+	if (new_dir == NULL)
+		new_dir = obj->parent;	/* use the old directory */
+
+	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
+			);
+		BUG();
+	}
+
+	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
+	del_op = (new_dir == obj->my_dev->del_dir);
+
+	existing_target = yaffs_find_by_name(new_dir, new_name);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are OK.
+	 *   else only proceed if the new name does not exist and we're putting
+	 *   it into a directory.
+	 */
+	if (!(unlink_op || del_op || force ||
+	      shadows > 0 || !existing_target) ||
+	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		return YAFFS_FAIL;
+
+	yaffs_set_obj_name(obj, new_name);
+	obj->dirty = 1;
+	yaffs_add_obj_to_dir(new_dir, obj);
+
+	if (unlink_op)
+		obj->unlinked = 1;
+
+	/* If it is a deletion then we mark it as a shrink for gc  */
+	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+/*------------------------ Short Operations Cache ------------------------------
+ *   In many situations where there is no high level buffering  a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance
+ *   benefit with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering and the short op cache
+ *   provides write buffering.
+ *
+ *   There are a small number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+	struct yaffs_cache *cache;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	for (i = 0; i < n_caches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj && cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void yaffs_flush_file_cache(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	struct yaffs_cache *cache;
+	int chunk_written = 0;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	if (n_caches < 1)
+		return;
+	do {
+		cache = NULL;
+
+		/* Find the lowest dirty chunk for this object */
+		for (i = 0; i < n_caches; i++) {
+			if (dev->cache[i].object == obj &&
+			    dev->cache[i].dirty) {
+				if (!cache ||
+				    dev->cache[i].chunk_id < lowest) {
+					cache = &dev->cache[i];
+					lowest = cache->chunk_id;
+				}
+			}
+		}
+
+		if (cache && !cache->locked) {
+			/* Write it out and free it up */
+			chunk_written =
+			    yaffs_wr_data_obj(cache->object,
+					      cache->chunk_id,
+					      cache->data,
+					      cache->n_bytes, 1);
+			cache->dirty = 0;
+			cache->object = NULL;
+		}
+	} while (cache && chunk_written > 0);
+
+	if (cache)
+		/* Hoosterman, disk full while writing cache out. */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs tragedy: no space during cache write");
+}
+
+/*yaffs_flush_whole_cache(dev)
+ *
+ *
+ */
+
+void yaffs_flush_whole_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int n_caches = dev->param.n_caches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < n_caches && !obj; i++) {
+			if (dev->cache[i].object && dev->cache[i].dirty)
+				obj = dev->cache[i].object;
+		}
+		if (obj)
+			yaffs_flush_file_cache(obj);
+	} while (obj);
+
+}
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (!dev->cache[i].object)
+				return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_cache *cache;
+	struct yaffs_obj *the_obj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	/* Try find a non-dirty one... */
+
+	cache = yaffs_grab_chunk_worker(dev);
+
+	if (!cache) {
+		/* They were all dirty, find the LRU object and flush
+		 * its cache, then  find again.
+		 * NB what's here is not very accurate,
+		 * we actually flush the object with the LRU chunk.
+		 */
+
+		/* With locking we can't assume we can use entry zero,
+		 * Set the_obj to a valid pointer for Coverity. */
+		the_obj = dev->cache[0].object;
+		usage = -1;
+		cache = NULL;
+		pushout = -1;
+
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object &&
+			    !dev->cache[i].locked &&
+			    (dev->cache[i].last_use < usage ||
+			    !cache)) {
+				usage = dev->cache[i].last_use;
+				the_obj = dev->cache[i].object;
+				cache = &dev->cache[i];
+				pushout = i;
+			}
+		}
+
+		if (!cache || cache->dirty) {
+			/* Flush and try again */
+			yaffs_flush_file_cache(the_obj);
+			cache = yaffs_grab_chunk_worker(dev);
+		}
+	}
+	return cache;
+}
+
+/* Find a cached chunk */
+static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
+						  int chunk_id)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].object == obj &&
+		    dev->cache[i].chunk_id == chunk_id) {
+			dev->cache_hits++;
+
+			return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
+			    int is_write)
+{
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return;
+
+	if (dev->cache_last_use < 0 ||
+		dev->cache_last_use > 100000000) {
+		/* Reset the cache usages */
+		for (i = 1; i < dev->param.n_caches; i++)
+			dev->cache[i].last_use = 0;
+
+		dev->cache_last_use = 0;
+	}
+	dev->cache_last_use++;
+	cache->last_use = dev->cache_last_use;
+
+	if (is_write)
+		cache->dirty = 1;
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
+{
+	struct yaffs_cache *cache;
+
+	if (object->my_dev->param.n_caches > 0) {
+		cache = yaffs_find_chunk_cache(object, chunk_id);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.n_caches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == in)
+				dev->cache[i].object = NULL;
+		}
+	}
+}
+
+static void yaffs_unhash_obj(struct yaffs_obj *obj)
+{
+	int bucket;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!list_empty(&obj->hash_link)) {
+		list_del_init(&obj->hash_link);
+		bucket = yaffs_hash_fn(obj->obj_id);
+		dev->obj_bucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_free_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj) {
+		BUG();
+		return;
+	}
+	dev = obj->my_dev;
+	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
+		obj, obj->my_inode);
+	if (obj->parent)
+		BUG();
+	if (!list_empty(&obj->siblings))
+		BUG();
+
+	if (obj->my_inode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		obj->defered_free = 1;
+		return;
+	}
+
+	yaffs_unhash_obj(obj);
+
+	yaffs_free_raw_obj(dev, obj);
+	dev->n_obj--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj)
+{
+	if (obj->defered_free)
+		yaffs_free_obj(obj);
+}
+
+static int yaffs_generic_obj_del(struct yaffs_obj *in)
+{
+	/* Iinvalidate the file's data in the cache, without flushing. */
+	yaffs_invalidate_whole_cache(in);
+
+	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
+		/* Move to unlinked directory so we have a deletion record */
+		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
+				      0);
+	}
+
+	yaffs_remove_obj_from_dir(in);
+	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
+	in->hdr_chunk = 0;
+
+	yaffs_free_obj(in);
+	return YAFFS_OK;
+
+}
+
+static void yaffs_soft_del_file(struct yaffs_obj *obj)
+{
+	if (!obj->deleted ||
+	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
+	    obj->soft_del)
+		return;
+
+	if (obj->n_data_chunks <= 0) {
+		/* Empty file with no duplicate object headers,
+		 * just delete it immediately */
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
+		obj->variant.file_variant.top = NULL;
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: Deleting empty file %d",
+			obj->obj_id);
+		yaffs_generic_obj_del(obj);
+	} else {
+		yaffs_soft_del_worker(obj,
+				      obj->variant.file_variant.top,
+				      obj->variant.
+				      file_variant.top_level, 0);
+		obj->soft_del = 1;
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ *
+ * This function is recursive. For levels > 0 the function is called again on
+ * any sub-tree. For level == 0 we just check if the sub-tree has data.
+ * If there is no data in a subtree then it is pruned.
+ */
+
+static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
+					      struct yaffs_tnode *tn, u32 level,
+					      int del0)
+{
+	int i;
+	int has_data;
+
+	if (!tn)
+		return tn;
+
+	has_data = 0;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i]) {
+				tn->internal[i] =
+				    yaffs_prune_worker(dev,
+						tn->internal[i],
+						level - 1,
+						(i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				has_data++;
+		}
+	} else {
+		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
+		u32 *map = (u32 *) tn;
+
+		for (i = 0; !has_data && i < tnode_size_u32; i++) {
+			if (map[i])
+				has_data++;
+		}
+	}
+
+	if (has_data == 0 && del0) {
+		/* Free and return NULL */
+		yaffs_free_tnode(dev, tn);
+		tn = NULL;
+	}
+	return tn;
+}
+
+static int yaffs_prune_tree(struct yaffs_dev *dev,
+			    struct yaffs_file_var *file_struct)
+{
+	int i;
+	int has_data;
+	int done = 0;
+	struct yaffs_tnode *tn;
+
+	if (file_struct->top_level < 1)
+		return YAFFS_OK;
+
+	file_struct->top =
+	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
+
+	/* Now we have a tree with all the non-zero branches NULL but
+	 * the height is the same as it was.
+	 * Let's see if we can trim internal tnodes to shorten the tree.
+	 * We can do this if only the 0th element in the tnode is in use
+	 * (ie all the non-zero are NULL)
+	 */
+
+	while (file_struct->top_level && !done) {
+		tn = file_struct->top;
+
+		has_data = 0;
+		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i])
+				has_data++;
+		}
+
+		if (!has_data) {
+			file_struct->top = tn->internal[0];
+			file_struct->top_level--;
+			yaffs_free_tnode(dev, tn);
+		} else {
+			done = 1;
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* alloc_empty_obj gets us a clean Object.*/
+static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
+
+	if (!obj)
+		return obj;
+
+	dev->n_obj++;
+
+	/* Now sweeten it up... */
+
+	memset(obj, 0, sizeof(struct yaffs_obj));
+	obj->being_created = 1;
+
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;
+	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
+	INIT_LIST_HEAD(&(obj->hard_links));
+	INIT_LIST_HEAD(&(obj->hash_link));
+	INIT_LIST_HEAD(&obj->siblings);
+
+	/* Now make the directory sane */
+	if (dev->root_dir) {
+		obj->parent = dev->root_dir;
+		list_add(&(obj->siblings),
+			 &dev->root_dir->variant.dir_variant.children);
+	}
+
+	/* Add it to the lost and found directory.
+	 * NB Can't put root or lost-n-found in lost-n-found so
+	 * check if lost-n-found exists first
+	 */
+	if (dev->lost_n_found)
+		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+
+	obj->being_created = 0;
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return obj;
+}
+
+static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
+{
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* Search for the shortest list or one that
+	 * isn't too long.
+	 */
+
+	for (i = 0; i < 10 && lowest > 4; i++) {
+		dev->bucket_finder++;
+		dev->bucket_finder %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->obj_bucket[dev->bucket_finder].count < lowest) {
+			lowest = dev->obj_bucket[dev->bucket_finder].count;
+			l = dev->bucket_finder;
+		}
+	}
+
+	return l;
+}
+
+static int yaffs_new_obj_id(struct yaffs_dev *dev)
+{
+	int bucket = yaffs_find_nice_bucket(dev);
+	int found = 0;
+	struct list_head *i;
+	u32 n = (u32) bucket;
+
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
+
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		if (1 || dev->obj_bucket[bucket].count > 0) {
+			list_for_each(i, &dev->obj_bucket[bucket].list) {
+				/* If there is already one in the list */
+				if (i && list_entry(i, struct yaffs_obj,
+						    hash_link)->obj_id == n) {
+					found = 0;
+				}
+			}
+		}
+	}
+	return n;
+}
+
+static void yaffs_hash_obj(struct yaffs_obj *in)
+{
+	int bucket = yaffs_hash_fn(in->obj_id);
+	struct yaffs_dev *dev = in->my_dev;
+
+	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
+	dev->obj_bucket[bucket].count++;
+}
+
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
+{
+	int bucket = yaffs_hash_fn(number);
+	struct list_head *i;
+	struct yaffs_obj *in;
+
+	list_for_each(i, &dev->obj_bucket[bucket].list) {
+		/* Look if it is in the list */
+		in = list_entry(i, struct yaffs_obj, hash_link);
+		if (in->obj_id == number) {
+			/* Don't show if it is defered free */
+			if (in->defered_free)
+				return NULL;
+			return in;
+		}
+	}
+
+	return NULL;
+}
+
+static struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
+				enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+	struct yaffs_tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_new_obj_id(dev);
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_get_tnode(dev);
+		if (!tn)
+			return NULL;
+	}
+
+	the_obj = yaffs_alloc_empty_obj(dev);
+	if (!the_obj) {
+		if (tn)
+			yaffs_free_tnode(dev, tn);
+		return NULL;
+	}
+
+	the_obj->fake = 0;
+	the_obj->rename_allowed = 1;
+	the_obj->unlink_allowed = 1;
+	the_obj->obj_id = number;
+	yaffs_hash_obj(the_obj);
+	the_obj->variant_type = type;
+	yaffs_load_current_time(the_obj, 1, 1);
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		the_obj->variant.file_variant.file_size = 0;
+		the_obj->variant.file_variant.scanned_size = 0;
+		the_obj->variant.file_variant.shrink_size =
+						yaffs_max_file_size(dev);
+		the_obj->variant.file_variant.top_level = 0;
+		the_obj->variant.file_variant.top = tn;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* No action required */
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* todo this should not happen */
+		break;
+	}
+	return the_obj;
+}
+
+static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
+					       int number, u32 mode)
+{
+
+	struct yaffs_obj *obj =
+	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+
+	if (!obj)
+		return NULL;
+
+	obj->fake = 1;	/* it is fake so it might not use NAND */
+	obj->rename_allowed = 0;
+	obj->unlink_allowed = 0;
+	obj->deleted = 0;
+	obj->unlinked = 0;
+	obj->yst_mode = mode;
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;	/* Not a valid chunk. */
+	return obj;
+
+}
+
+
+static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	int i;
+
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+	yaffs_init_raw_tnodes_and_objs(dev);
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
+		dev->obj_bucket[i].count = 0;
+	}
+}
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+
+	if (number > 0)
+		the_obj = yaffs_find_by_number(dev, number);
+
+	if (!the_obj)
+		the_obj = yaffs_new_obj(dev, number, type);
+
+	return the_obj;
+
+}
+
+YCHAR *yaffs_clone_str(const YCHAR *str)
+{
+	YCHAR *new_str = NULL;
+	int len;
+
+	if (!str)
+		str = _Y("");
+
+	len = strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
+	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
+	if (new_str) {
+		strncpy(new_str, str, len);
+		new_str[len] = 0;
+	}
+	return new_str;
+
+}
+/*
+ *yaffs_update_parent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ *
+ * This can be handled immediately or defered. Defering helps reduce the number
+ * of updates when many files in a directory are changed within a brief period.
+ *
+ * If the directory updating is defered then yaffs_update_dirty_dirs must be
+ * called periodically.
+ */
+
+static void yaffs_update_parent(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj)
+		return;
+	dev = obj->my_dev;
+	obj->dirty = 1;
+	yaffs_load_current_time(obj, 0, 1);
+	if (dev->param.defered_dir_update) {
+		struct list_head *link = &obj->variant.dir_variant.dirty;
+
+		if (list_empty(link)) {
+			list_add(link, &dev->dirty_dirs);
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+			  "Added object %d to dirty directories",
+			   obj->obj_id);
+		}
+
+	} else {
+		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
+{
+	struct list_head *link;
+	struct yaffs_obj *obj;
+	struct yaffs_dir_var *d_s;
+	union yaffs_obj_var *o_v;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
+
+	while (!list_empty(&dev->dirty_dirs)) {
+		link = dev->dirty_dirs.next;
+		list_del_init(link);
+
+		d_s = list_entry(link, struct yaffs_dir_var, dirty);
+		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
+		obj = list_entry(o_v, struct yaffs_obj, variant);
+
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
+			obj->obj_id);
+
+		if (obj->dirty)
+			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+/*
+ * Mknod (create) a new object.
+ * equiv_obj only has meaning for a hard link;
+ * alias_str only has meaning for a symlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
+					  struct yaffs_obj *parent,
+					  const YCHAR *name,
+					  u32 mode,
+					  u32 uid,
+					  u32 gid,
+					  struct yaffs_obj *equiv_obj,
+					  const YCHAR *alias_str, u32 rdev)
+{
+	struct yaffs_obj *in;
+	YCHAR *str = NULL;
+	struct yaffs_dev *dev = parent->my_dev;
+
+	/* Check if the entry exists.
+	 * If it does then fail the call since we don't want a dup. */
+	if (yaffs_find_by_name(parent, name))
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_clone_str(alias_str);
+		if (!str)
+			return NULL;
+	}
+
+	in = yaffs_new_obj(dev, -1, type);
+
+	if (!in) {
+		kfree(str);
+		return NULL;
+	}
+
+	in->hdr_chunk = 0;
+	in->valid = 1;
+	in->variant_type = type;
+
+	in->yst_mode = mode;
+
+	yaffs_attribs_init(in, gid, uid, rdev);
+
+	in->n_data_chunks = 0;
+
+	yaffs_set_obj_name(in, name);
+	in->dirty = 1;
+
+	yaffs_add_obj_to_dir(parent, in);
+
+	in->my_dev = parent->my_dev;
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		in->variant.symlink_variant.alias = str;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		in->variant.hardlink_variant.equiv_obj = equiv_obj;
+		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
+		list_add(&in->hard_links, &equiv_obj->hard_links);
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* do nothing */
+		break;
+	}
+
+	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
+		/* Could not create the object header, fail */
+		yaffs_del_obj(in);
+		in = NULL;
+	}
+
+	if (in)
+		yaffs_update_parent(parent);
+
+	return in;
+}
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				mode, uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				uid, gid, NULL, NULL, rdev);
+}
+
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_link_obj returns the object id of the equivalent object.*/
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
+				 struct yaffs_obj *equiv_obj)
+{
+	/* Get the real object in case we were fed a hard link obj */
+	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
+
+	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
+			parent, name, 0, 0, 0,
+			equiv_obj, NULL, 0))
+		return equiv_obj;
+
+	return NULL;
+
+}
+
+
+
+/*---------------------- Block Management and Page Allocation -------------*/
+
+static void yaffs_deinit_blocks(struct yaffs_dev *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		vfree(dev->block_info);
+	else
+		kfree(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		vfree(dev->chunk_bits);
+	else
+		kfree(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
+
+static int yaffs_init_blocks(struct yaffs_dev *dev)
+{
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	dev->block_info = NULL;
+	dev->chunk_bits = NULL;
+	dev->alloc_block = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->block_info =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
+	if (!dev->block_info) {
+		dev->block_info =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_info));
+		dev->block_info_alt = 1;
+	} else {
+		dev->block_info_alt = 0;
+	}
+
+	if (!dev->block_info)
+		goto alloc_error;
+
+	/* Set up dynamic blockinfo stuff. Round up bytes. */
+	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
+	dev->chunk_bits =
+		kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
+	if (!dev->chunk_bits) {
+		dev->chunk_bits =
+		    vmalloc(dev->chunk_bit_stride * n_blocks);
+		dev->chunk_bits_alt = 1;
+	} else {
+		dev->chunk_bits_alt = 0;
+	}
+	if (!dev->chunk_bits)
+		goto alloc_error;
+
+
+	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
+	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
+	return YAFFS_OK;
+
+alloc_error:
+	yaffs_deinit_blocks(dev);
+	return YAFFS_FAIL;
+}
+
+
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
+	int erased_ok = 0;
+	int i;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		"yaffs_block_became_dirty block %d state %d %s",
+		block_no, bi->block_state,
+		(bi->needs_retiring) ? "needs retiring" : "");
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
+
+	/* If this is the block being garbage collected then stop gc'ing */
+	if (block_no == dev->gc_block)
+		dev->gc_block = 0;
+
+	/* If this block is currently the best candidate for gc
+	 * then drop as a candidate */
+	if (block_no == dev->gc_dirtiest) {
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+	}
+
+	if (!bi->needs_retiring) {
+		yaffs2_checkpt_invalidate(dev);
+		erased_ok = yaffs_erase_block(dev, block_no);
+		if (!erased_ok) {
+			dev->n_erase_failures++;
+			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  "**>> Erasure failed %d", block_no);
+		}
+	}
+
+	/* Verify erasure if needed */
+	if (erased_ok &&
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
+	     !yaffs_skip_verification(dev))) {
+		for (i = 0; i < dev->param.chunks_per_block; i++) {
+			if (!yaffs_check_chunk_erased(dev,
+				block_no * dev->param.chunks_per_block + i)) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					">>Block %d erasure supposedly OK, but chunk %d not erased",
+					block_no, i);
+			}
+		}
+	}
+
+	if (!erased_ok) {
+		/* We lost a block of free space */
+		dev->n_free_chunks -= dev->param.chunks_per_block;
+		yaffs_retire_block(dev, block_no);
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			"**>> Block %d retired", block_no);
+		return;
+	}
+
+	/* Clean it up... */
+	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+	bi->seq_number = 0;
+	dev->n_erased_blocks++;
+	bi->pages_in_use = 0;
+	bi->soft_del_pages = 0;
+	bi->has_shrink_hdr = 0;
+	bi->skip_erased_check = 1;	/* Clean, so no need to check */
+	bi->gc_prioritise = 0;
+	bi->has_summary = 0;
+
+	yaffs_clear_chunk_bits(dev, block_no);
+
+	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
+}
+
+static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
+					struct yaffs_block_info *bi,
+					int old_chunk, u8 *buffer)
+{
+	int new_chunk;
+	int mark_flash = 1;
+	struct yaffs_ext_tags tags;
+	struct yaffs_obj *object;
+	int matching_chunk;
+	int ret_val = YAFFS_OK;
+
+	memset(&tags, 0, sizeof(tags));
+	yaffs_rd_chunk_tags_nand(dev, old_chunk,
+				 buffer, &tags);
+	object = yaffs_find_by_number(dev, tags.obj_id);
+
+	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
+		"Collecting chunk in block %d, %d %d %d ",
+		dev->gc_chunk, tags.obj_id,
+		tags.chunk_id, tags.n_bytes);
+
+	if (object && !yaffs_skip_verification(dev)) {
+		if (tags.chunk_id == 0)
+			matching_chunk =
+			    object->hdr_chunk;
+		else if (object->soft_del)
+			/* Defeat the test */
+			matching_chunk = old_chunk;
+		else
+			matching_chunk =
+			    yaffs_find_chunk_in_file
+			    (object, tags.chunk_id,
+			     NULL);
+
+		if (old_chunk != matching_chunk)
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"gc: page in gc mismatch: %d %d %d %d",
+				old_chunk,
+				matching_chunk,
+				tags.obj_id,
+				tags.chunk_id);
+	}
+
+	if (!object) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"page %d in gc has no object: %d %d %d ",
+			old_chunk,
+			tags.obj_id, tags.chunk_id,
+			tags.n_bytes);
+	}
+
+	if (object &&
+	    object->deleted &&
+	    object->soft_del && tags.chunk_id != 0) {
+		/* Data chunk in a soft deleted file,
+		 * throw it away.
+		 * It's a soft deleted data chunk,
+		 * No need to copy this, just forget
+		 * about it and fix up the object.
+		 */
+
+		/* Free chunks already includes
+		 * softdeleted chunks, how ever this
+		 * chunk is going to soon be really
+		 * deleted which will increment free
+		 * chunks. We have to decrement free
+		 * chunks so this works out properly.
+		 */
+		dev->n_free_chunks--;
+		bi->soft_del_pages--;
+
+		object->n_data_chunks--;
+		if (object->n_data_chunks <= 0) {
+			/* remeber to clean up obj */
+			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
+			dev->n_clean_ups++;
+		}
+		mark_flash = 0;
+	} else if (object) {
+		/* It's either a data chunk in a live
+		 * file or an ObjectHeader, so we're
+		 * interested in it.
+		 * NB Need to keep the ObjectHeaders of
+		 * deleted files until the whole file
+		 * has been deleted off
+		 */
+		tags.serial_number++;
+		dev->n_gc_copies++;
+
+		if (tags.chunk_id == 0) {
+			/* It is an object Id,
+			 * We need to nuke the
+			 * shrinkheader flags since its
+			 * work is done.
+			 * Also need to clean up
+			 * shadowing.
+			 */
+			struct yaffs_obj_hdr *oh;
+			oh = (struct yaffs_obj_hdr *) buffer;
+
+			oh->is_shrink = 0;
+			tags.extra_is_shrink = 0;
+			oh->shadows_obj = 0;
+			oh->inband_shadowed_obj_id = 0;
+			tags.extra_shadows = 0;
+
+			/* Update file size */
+			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				yaffs_oh_size_load(oh,
+				    object->variant.file_variant.file_size);
+				tags.extra_file_size =
+				    object->variant.file_variant.file_size;
+			}
+
+			yaffs_verify_oh(object, oh, &tags, 1);
+			new_chunk =
+			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
+		} else {
+			new_chunk =
+			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
+		}
+
+		if (new_chunk < 0) {
+			ret_val = YAFFS_FAIL;
+		} else {
+
+			/* Now fix up the Tnodes etc. */
+
+			if (tags.chunk_id == 0) {
+				/* It's a header */
+				object->hdr_chunk = new_chunk;
+				object->serial = tags.serial_number;
+			} else {
+				/* It's a data chunk */
+				yaffs_put_chunk_in_file(object, tags.chunk_id,
+							new_chunk, 0);
+			}
+		}
+	}
+	if (ret_val == YAFFS_OK)
+		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
+	return ret_val;
+}
+
+static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
+{
+	int old_chunk;
+	int ret_val = YAFFS_OK;
+	int i;
+	int is_checkpt_block;
+	int max_copies;
+	int chunks_before = yaffs_get_erased_chunks(dev);
+	int chunks_after;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
+
+	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+		"Collecting block %d, in use %d, shrink %d, whole_block %d",
+		block, bi->pages_in_use, bi->has_shrink_hdr,
+		whole_block);
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	yaffs_summary_gc(dev, block);
+
+	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"Collecting block %d that has no chunks in use",
+			block);
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		yaffs_verify_blk(dev, bi, block);
+
+		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
+		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
+
+		for (/* init already done */ ;
+		     ret_val == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     max_copies > 0;
+		     dev->gc_chunk++, old_chunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+				/* Page is in use and might need to be copied */
+				max_copies--;
+				ret_val = yaffs_gc_process_chunk(dev, bi,
+							old_chunk, buffer);
+			}
+		}
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	yaffs_verify_collected_blk(dev, bi, block);
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		/*
+		 * The gc did not complete. Set block state back to FULL
+		 * because checkpointing does not restore gc.
+		 */
+		bi->block_state = YAFFS_BLOCK_STATE_FULL;
+	} else {
+		/* The gc completed. */
+		/* Do any required cleanups */
+		for (i = 0; i < dev->n_clean_ups; i++) {
+			/* Time to delete the file too */
+			struct yaffs_obj *object =
+			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
+			if (object) {
+				yaffs_free_tnode(dev,
+					  object->variant.file_variant.top);
+				object->variant.file_variant.top = NULL;
+				yaffs_trace(YAFFS_TRACE_GC,
+					"yaffs: About to finally delete object %d",
+					object->obj_id);
+				yaffs_generic_obj_del(object);
+				object->my_dev->n_deleted_files--;
+			}
+
+		}
+		chunks_after = yaffs_get_erased_chunks(dev);
+		if (chunks_before >= chunks_after)
+			yaffs_trace(YAFFS_TRACE_GC,
+				"gc did not increase free chunks before %d after %d",
+				chunks_before, chunks_after);
+		dev->gc_block = 0;
+		dev->gc_chunk = 0;
+		dev->n_clean_ups = 0;
+	}
+
+	dev->gc_disable = 0;
+
+	return ret_val;
+}
+
+/*
+ * find_gc_block() selects the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
+				    int aggressive, int background)
+{
+	int i;
+	int iterations;
+	unsigned selected = 0;
+	int prioritised = 0;
+	int prioritised_exist = 0;
+	struct yaffs_block_info *bi;
+	int threshold;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->has_pending_prioritised_gc && !aggressive) {
+		dev->gc_dirtiest = 0;
+		bi = dev->block_info;
+		for (i = dev->internal_start_block;
+		     i <= dev->internal_end_block && !selected; i++) {
+
+			if (bi->gc_prioritise) {
+				prioritised_exist = 1;
+				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				    yaffs_block_ok_for_gc(dev, bi)) {
+					selected = i;
+					prioritised = 1;
+				}
+			}
+			bi++;
+		}
+
+		/*
+		 * If there is a prioritised block and none was selected then
+		 * this happened because there is at least one old dirty block
+		 * gumming up the works. Let's gc the oldest dirty block.
+		 */
+
+		if (prioritised_exist &&
+		    !selected && dev->oldest_dirty_block > 0)
+			selected = dev->oldest_dirty_block;
+
+		if (!prioritised_exist)	/* None found, so we can clear this */
+			dev->has_pending_prioritised_gc = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty
+	 * block, and search harder.
+	 * else (leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	if (!selected) {
+		int pages_used;
+		int n_blocks =
+		    dev->internal_end_block - dev->internal_start_block + 1;
+		if (aggressive) {
+			threshold = dev->param.chunks_per_block;
+			iterations = n_blocks;
+		} else {
+			int max_threshold;
+
+			if (background)
+				max_threshold = dev->param.chunks_per_block / 2;
+			else
+				max_threshold = dev->param.chunks_per_block / 8;
+
+			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+
+			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
+			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+			if (threshold > max_threshold)
+				threshold = max_threshold;
+
+			iterations = n_blocks / 16 + 1;
+			if (iterations > 100)
+				iterations = 100;
+		}
+
+		for (i = 0;
+		     i < iterations &&
+		     (dev->gc_dirtiest < 1 ||
+		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+		     i++) {
+			dev->gc_block_finder++;
+			if (dev->gc_block_finder < dev->internal_start_block ||
+			    dev->gc_block_finder > dev->internal_end_block)
+				dev->gc_block_finder =
+				    dev->internal_start_block;
+
+			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
+
+			pages_used = bi->pages_in_use - bi->soft_del_pages;
+
+			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+			    pages_used < dev->param.chunks_per_block &&
+			    (dev->gc_dirtiest < 1 ||
+			     pages_used < dev->gc_pages_in_use) &&
+			    yaffs_block_ok_for_gc(dev, bi)) {
+				dev->gc_dirtiest = dev->gc_block_finder;
+				dev->gc_pages_in_use = pages_used;
+			}
+		}
+
+		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
+			selected = dev->gc_dirtiest;
+	}
+
+	/*
+	 * If nothing has been selected for a while, try the oldest dirty
+	 * because that's gumming up the works.
+	 */
+
+	if (!selected && dev->param.is_yaffs2 &&
+	    dev->gc_not_done >= (background ? 10 : 20)) {
+		yaffs2_find_oldest_dirty_seq(dev);
+		if (dev->oldest_dirty_block > 0) {
+			selected = dev->oldest_dirty_block;
+			dev->gc_dirtiest = selected;
+			dev->oldest_dirty_gc_count++;
+			bi = yaffs_get_block_info(dev, selected);
+			dev->gc_pages_in_use =
+			    bi->pages_in_use - bi->soft_del_pages;
+		} else {
+			dev->gc_not_done = 0;
+		}
+	}
+
+	if (selected) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC Selected block %d with %d free, prioritised:%d",
+			selected,
+			dev->param.chunks_per_block - dev->gc_pages_in_use,
+			prioritised);
+
+		dev->n_gc_blocks++;
+		if (background)
+			dev->bg_gcs++;
+
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+		dev->gc_not_done = 0;
+		if (dev->refresh_skip > 0)
+			dev->refresh_skip--;
+	} else {
+		dev->gc_not_done++;
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
+			dev->gc_block_finder, dev->gc_not_done, threshold,
+			dev->gc_dirtiest, dev->gc_pages_in_use,
+			dev->oldest_dirty_block, background ? " bg" : "");
+	}
+
+	return selected;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and only accepts more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_check_gc(struct yaffs_dev *dev, int background)
+{
+	int aggressive = 0;
+	int gc_ok = YAFFS_OK;
+	int max_tries = 0;
+	int min_erased;
+	int erased_chunks;
+	int checkpt_block_adjust;
+
+	if (dev->param.gc_control && (dev->param.gc_control(dev) & 1) == 0)
+		return YAFFS_OK;
+
+	if (dev->gc_disable)
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+
+	/* This loop should pass the first time.
+	 * Only loops here if the collection does not increase space.
+	 */
+
+	do {
+		max_tries++;
+
+		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
+
+		min_erased =
+		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
+		erased_chunks =
+		    dev->n_erased_blocks * dev->param.chunks_per_block;
+
+		/* If we need a block soon then do aggressive gc. */
+		if (dev->n_erased_blocks < min_erased)
+			aggressive = 1;
+		else {
+			if (!background
+			    && erased_chunks > (dev->n_free_chunks / 4))
+				break;
+
+			if (dev->gc_skip > 20)
+				dev->gc_skip = 20;
+			if (erased_chunks < dev->n_free_chunks / 2 ||
+			    dev->gc_skip < 1 || background)
+				aggressive = 0;
+			else {
+				dev->gc_skip--;
+				break;
+			}
+		}
+
+		dev->gc_skip = 5;
+
+		/* If we don't already have a block being gc'd then see if we
+		 * should start another */
+
+		if (dev->gc_block < 1 && !aggressive) {
+			dev->gc_block = yaffs2_find_refresh_block(dev);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+		if (dev->gc_block < 1) {
+			dev->gc_block =
+			    yaffs_find_gc_block(dev, aggressive, background);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+
+		if (dev->gc_block > 0) {
+			dev->all_gcs++;
+			if (!aggressive)
+				dev->passive_gc_count++;
+
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC n_erased_blocks %d aggressive %d",
+				dev->n_erased_blocks, aggressive);
+
+			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
+		}
+
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
+		    dev->gc_block > 0) {
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
+				dev->n_erased_blocks, max_tries,
+				dev->gc_block);
+		}
+	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
+		 (dev->gc_block > 0) && (max_tries < 2));
+
+	return aggressive ? gc_ok : YAFFS_OK;
+}
+
+/*
+ * yaffs_bg_gc()
+ * Garbage collects. Intended to be called from a background thread.
+ * Returns non-zero if at least half the free chunks are erased.
+ */
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
+{
+	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
+
+	yaffs_check_gc(dev, 1);
+	return erased_chunks > dev->n_free_chunks / 2;
+}
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
+{
+	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
+
+	if (nand_chunk >= 0)
+		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
+						buffer, NULL);
+	else {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not found zero instead",
+			nand_chunk);
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
+		return 0;
+	}
+
+}
+
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn)
+{
+	int block;
+	int page;
+	struct yaffs_ext_tags tags;
+	struct yaffs_block_info *bi;
+
+	if (chunk_id <= 0)
+		return;
+
+	dev->n_deletions++;
+	block = chunk_id / dev->param.chunks_per_block;
+	page = chunk_id % dev->param.chunks_per_block;
+
+	if (!yaffs_check_chunk_bit(dev, block, page))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Deleting invalid chunk %d", chunk_id);
+
+	bi = yaffs_get_block_info(dev, block);
+
+	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+
+	yaffs_trace(YAFFS_TRACE_DELETION,
+		"line %d delete of chunk %d",
+		lyn, chunk_id);
+
+	if (!dev->param.is_yaffs2 && mark_flash &&
+	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
+
+		memset(&tags, 0, sizeof(tags));
+		tags.is_deleted = 1;
+		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
+		yaffs_handle_chunk_update(dev, chunk_id, &tags);
+	} else {
+		dev->n_unmarked_deletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->n_free_chunks++;
+		yaffs_clear_chunk_bit(dev, block, page);
+		bi->pages_in_use--;
+
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			yaffs_block_became_dirty(dev, block);
+		}
+	}
+}
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prev_chunk_id;
+	struct yaffs_ext_tags prev_tags;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_dev *dev = in->my_dev;
+
+	yaffs_check_gc(dev, 0);
+
+	/* Get the previous chunk at this location in the file if it exists.
+	 * If it does not exist then put a zero into the tree. This creates
+	 * the tnode now, rather than later when it is harder to clean up.
+	 */
+	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
+	if (prev_chunk_id < 1 &&
+	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
+		return 0;
+
+	/* Set up new tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+
+	new_tags.chunk_id = inode_chunk;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number =
+	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
+	new_tags.n_bytes = n_bytes;
+
+	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "Writing %d bytes to chunk!!!!!!!!!",
+		   n_bytes);
+		BUG();
+	}
+
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
+
+	if (new_chunk_id > 0) {
+		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
+
+		if (prev_chunk_id > 0)
+			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+		yaffs_verify_file_sane(in);
+	}
+	return new_chunk_id;
+
+}
+
+
+
+static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
+				const YCHAR *name, const void *value, int size,
+				int flags)
+{
+	struct yaffs_xattr_mod xmod;
+	int result;
+
+	xmod.set = set;
+	xmod.name = name;
+	xmod.data = value;
+	xmod.size = size;
+	xmod.flags = flags;
+	xmod.result = -ENOSPC;
+
+	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
+
+	if (result > 0)
+		return xmod.result;
+	else
+		return -ENOSPC;
+}
+
+static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
+				   struct yaffs_xattr_mod *xmod)
+{
+	int retval = 0;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer = buffer + x_offs;
+
+	if (xmod->set)
+		retval =
+		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
+			     xmod->size, xmod->flags);
+	else
+		retval = nval_del(x_buffer, x_size, xmod->name);
+
+	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+	obj->xattr_known = 1;
+	xmod->result = retval;
+
+	return retval;
+}
+
+static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
+				  void *value, int size)
+{
+	char *buffer = NULL;
+	int result;
+	struct yaffs_ext_tags tags;
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer;
+	int retval = 0;
+
+	if (obj->hdr_chunk < 1)
+		return -ENODATA;
+
+	/* If we know that the object has no xattribs then don't do all the
+	 * reading and parsing.
+	 */
+	if (obj->xattr_known && !obj->has_xattr) {
+		if (name)
+			return -ENODATA;
+		else
+			return 0;
+	}
+
+	buffer = (char *)yaffs_get_temp_buffer(dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	result =
+	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
+
+	if (result != YAFFS_OK)
+		retval = -ENOENT;
+	else {
+		x_buffer = buffer + x_offs;
+
+		if (!obj->xattr_known) {
+			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+			obj->xattr_known = 1;
+		}
+
+		if (name)
+			retval = nval_get(x_buffer, x_size, name, value, size);
+		else
+			retval = nval_list(x_buffer, x_size, value, size);
+	}
+	yaffs_release_temp_buffer(dev, (u8 *) buffer);
+	return retval;
+}
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
+		      const void *value, int size, int flags)
+{
+	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
+}
+
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
+{
+	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
+}
+
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
+		      int size)
+{
+	return yaffs_do_xattrib_fetch(obj, name, value, size);
+}
+
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
+}
+
+static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
+{
+	u8 *buf;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
+		return;
+
+	dev = in->my_dev;
+	in->lazy_loaded = 0;
+	buf = yaffs_get_temp_buffer(dev);
+
+	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
+	oh = (struct yaffs_obj_hdr *)buf;
+
+	in->yst_mode = oh->yst_mode;
+	yaffs_load_attribs(in, oh);
+	yaffs_set_obj_name_from_oh(in, oh);
+
+	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		in->variant.symlink_variant.alias =
+		    yaffs_clone_str(oh->alias);
+		if (!in->variant.symlink_variant.alias)
+			alloc_failed = 1;	/* Not returned */
+	}
+	yaffs_release_temp_buffer(dev, buf);
+}
+
+static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
+				    const YCHAR *oh_name, int buff_size)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	if (dev->param.auto_unicode) {
+		if (*oh_name) {
+			/* It is an ASCII name, do an ASCII to
+			 * unicode conversion */
+			const char *ascii_oh_name = (const char *)oh_name;
+			int n = buff_size - 1;
+			while (n > 0 && *ascii_oh_name) {
+				*name = *ascii_oh_name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			strncpy(name, oh_name + 1, buff_size - 1);
+		}
+	} else {
+#else
+	(void) dev;
+	{
+#endif
+		strncpy(name, oh_name, buff_size - 1);
+	}
+}
+
+static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
+				    const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+
+	int is_ascii;
+	YCHAR *w;
+
+	if (dev->param.auto_unicode) {
+
+		is_ascii = 1;
+		w = name;
+
+		/* Figure out if the name will fit in ascii character set */
+		while (is_ascii && *w) {
+			if ((*w) & 0xff00)
+				is_ascii = 0;
+			w++;
+		}
+
+		if (is_ascii) {
+			/* It is an ASCII name, so convert unicode to ascii */
+			char *ascii_oh_name = (char *)oh_name;
+			int n = YAFFS_MAX_NAME_LENGTH - 1;
+			while (n > 0 && *name) {
+				*ascii_oh_name = *name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			/* Unicode name, so save starting at the second YCHAR */
+			*oh_name = 0;
+			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
+		}
+	} else {
+#else
+	dev = dev;
+	{
+#endif
+		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
+	}
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
+		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
+{
+
+	struct yaffs_block_info *bi;
+	struct yaffs_dev *dev = in->my_dev;
+	int prev_chunk_id;
+	int ret_val = 0;
+	int result = 0;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_ext_tags old_tags;
+	const YCHAR *alias = NULL;
+	u8 *buffer = NULL;
+	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj_hdr *oh = NULL;
+	loff_t file_size = 0;
+
+	strcpy(old_name, _Y("silly old name"));
+
+	if (in->fake && in != dev->root_dir && !force && !xmod)
+		return ret_val;
+
+	yaffs_check_gc(dev, 0);
+	yaffs_check_obj_details_loaded(in);
+
+	buffer = yaffs_get_temp_buffer(in->my_dev);
+	oh = (struct yaffs_obj_hdr *)buffer;
+
+	prev_chunk_id = in->hdr_chunk;
+
+	if (prev_chunk_id > 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
+						  buffer, &old_tags);
+
+		yaffs_verify_oh(in, oh, &old_tags, 0);
+		memcpy(old_name, oh->name, sizeof(oh->name));
+		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
+	} else {
+		memset(buffer, 0xff, dev->data_bytes_per_chunk);
+	}
+
+	oh->type = in->variant_type;
+	oh->yst_mode = in->yst_mode;
+	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
+
+	yaffs_load_attribs_oh(oh, in);
+
+	if (in->parent)
+		oh->parent_obj_id = in->parent->obj_id;
+	else
+		oh->parent_obj_id = 0;
+
+	if (name && *name) {
+		memset(oh->name, 0, sizeof(oh->name));
+		yaffs_load_oh_from_name(dev, oh->name, name);
+	} else if (prev_chunk_id > 0) {
+		memcpy(oh->name, old_name, sizeof(oh->name));
+	} else {
+		memset(oh->name, 0, sizeof(oh->name));
+	}
+
+	oh->is_shrink = is_shrink;
+
+	switch (in->variant_type) {
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* Should not happen */
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
+		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
+			file_size = in->variant.file_variant.file_size;
+		yaffs_oh_size_load(oh, file_size);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = in->variant.symlink_variant.alias;
+		if (!alias)
+			alias = _Y("no alias");
+		strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
+		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+		break;
+	}
+
+	/* process any xattrib modifications */
+	if (xmod)
+		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
+
+	/* Tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+	in->serial++;
+	new_tags.chunk_id = 0;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number = in->serial;
+
+	/* Add extra info for file header */
+	new_tags.extra_available = 1;
+	new_tags.extra_parent_id = oh->parent_obj_id;
+	new_tags.extra_file_size = file_size;
+	new_tags.extra_is_shrink = oh->is_shrink;
+	new_tags.extra_equiv_id = oh->equiv_id;
+	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
+	new_tags.extra_obj_type = in->variant_type;
+	yaffs_verify_oh(in, oh, &new_tags, 1);
+
+	/* Create new chunk in NAND */
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags,
+				  (prev_chunk_id > 0) ? 1 : 0);
+
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer);
+
+	if (new_chunk_id < 0)
+		return new_chunk_id;
+
+	in->hdr_chunk = new_chunk_id;
+
+	if (prev_chunk_id > 0)
+		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+	if (!yaffs_obj_cache_dirty(in))
+		in->dirty = 0;
+
+	/* If this was a shrink, then mark the block
+	 * that the chunk lives on */
+	if (is_shrink) {
+		bi = yaffs_get_block_info(in->my_dev,
+					  new_chunk_id /
+					  in->my_dev->param.chunks_per_block);
+		bi->has_shrink_hdr = 1;
+	}
+
+
+	return new_chunk_id;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
+{
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	struct yaffs_cache *cache;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->data_bytes_per_chunk)
+			n_copy = n;
+		else
+			n_copy = dev->data_bytes_per_chunk - start;
+
+		cache = yaffs_find_chunk_cache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than
+		 * a whole chunk or we're using inband tags then use the cache
+		 * (if there is caching) else bypass the cache.
+		 */
+		if (cache || n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			if (dev->param.n_caches > 0) {
+
+				/* If we can't find the data in the cache,
+				 * then load it up. */
+
+				if (!cache) {
+					cache =
+					    yaffs_grab_chunk_cache(in->my_dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+					cache->n_bytes = 0;
+				}
+
+				yaffs_use_cache(dev, cache, 0);
+
+				cache->locked = 1;
+
+				memcpy(buffer, &cache->data[start], n_copy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy.. */
+
+				u8 *local_buffer =
+				    yaffs_get_temp_buffer(dev);
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+
+				memcpy(buffer, &local_buffer[start], n_copy);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Read directly into the buffer. */
+			yaffs_rd_data_obj(in, chunk, buffer);
+		}
+		n -= n_copy;
+		offset += n_copy;
+		buffer += n_copy;
+		n_done += n_copy;
+	}
+	return n_done;
+}
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_through)
+{
+
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	int n_writeback;
+	loff_t start_write = offset;
+	int chunk_written = 0;
+	u32 n_bytes_read;
+	loff_t chunk_start;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0 && chunk_written >= 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+
+		if (((loff_t)chunk) *
+		    dev->data_bytes_per_chunk + start != offset ||
+		    start >= dev->data_bytes_per_chunk) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"AddrToChunk of offset %lld gives chunk %d start %d",
+				offset, chunk, start);
+		}
+		chunk++;	/* File pos to chunk in file offset */
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->data_bytes_per_chunk) {
+			n_copy = n;
+
+			/* Now calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of
+			 * file then we need to write back as much as was there
+			 * before.
+			 */
+
+			chunk_start = (((loff_t)(chunk - 1)) *
+					dev->data_bytes_per_chunk);
+
+			if (chunk_start > in->variant.file_variant.file_size)
+				n_bytes_read = 0;	/* Past end of file */
+			else
+				n_bytes_read =
+				    in->variant.file_variant.file_size -
+				    chunk_start;
+
+			if (n_bytes_read > dev->data_bytes_per_chunk)
+				n_bytes_read = dev->data_bytes_per_chunk;
+
+			n_writeback =
+			    (n_bytes_read >
+			     (start + n)) ? n_bytes_read : (start + n);
+
+			if (n_writeback < 0 ||
+			    n_writeback > dev->data_bytes_per_chunk)
+				BUG();
+
+		} else {
+			n_copy = dev->data_bytes_per_chunk - start;
+			n_writeback = dev->data_bytes_per_chunk;
+		}
+
+		if (n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both
+			 * start and end chunk), or we're using inband tags,
+			 * so we want to use the cache buffers.
+			 */
+			if (dev->param.n_caches > 0) {
+				struct yaffs_cache *cache;
+
+				/* If we can't find the data in the cache, then
+				 * load the cache */
+				cache = yaffs_find_chunk_cache(in, chunk);
+
+				if (!cache &&
+				    yaffs_check_alloc_available(dev, 1)) {
+					cache = yaffs_grab_chunk_cache(dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+				} else if (cache &&
+					   !cache->dirty &&
+					   !yaffs_check_alloc_available(dev,
+									1)) {
+					/* Drop the cache if it was a read cache
+					 * item and no space check has been made
+					 * for it.
+					 */
+					cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_use_cache(dev, cache, 1);
+					cache->locked = 1;
+
+					memcpy(&cache->data[start], buffer,
+					       n_copy);
+
+					cache->locked = 0;
+					cache->n_bytes = n_writeback;
+
+					if (write_through) {
+						chunk_written =
+						    yaffs_wr_data_obj
+						    (cache->object,
+						     cache->chunk_id,
+						     cache->data,
+						     cache->n_bytes, 1);
+						cache->dirty = 0;
+					}
+				} else {
+					chunk_written = -1;	/* fail write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe
+				 * both start and end chunk). Read into the
+				 * local buffer then copy over and write back.
+				 */
+
+				u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+				memcpy(&local_buffer[start], buffer, n_copy);
+
+				chunk_written =
+				    yaffs_wr_data_obj(in, chunk,
+						      local_buffer,
+						      n_writeback, 0);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Write directly from the buffer. */
+
+			chunk_written =
+			    yaffs_wr_data_obj(in, chunk, buffer,
+					      dev->data_bytes_per_chunk, 0);
+
+			/* Since we've overwritten the cached data,
+			 * we better invalidate it. */
+			yaffs_invalidate_chunk_cache(in, chunk);
+		}
+
+		if (chunk_written >= 0) {
+			n -= n_copy;
+			offset += n_copy;
+			buffer += n_copy;
+			n_done += n_copy;
+		}
+	}
+
+	/* Update file object */
+
+	if ((start_write + n_done) > in->variant.file_variant.file_size)
+		in->variant.file_variant.file_size = (start_write + n_done);
+
+	in->dirty = 1;
+	return n_done;
+}
+
+int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		  int n_bytes, int write_through)
+{
+	yaffs2_handle_hole(in, offset);
+	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
+}
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
+{
+
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+	int i;
+	int chunk_id;
+	u32 dummy;
+	int last_del;
+	int start_del;
+
+	if (old_size > 0)
+		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
+	else
+		last_del = 0;
+
+	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
+				&start_del, &dummy);
+	last_del++;
+	start_del++;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = last_del; i >= start_del; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_chunk_del
+		 */
+
+		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
+
+		if (chunk_id < 1)
+			continue;
+
+		if (chunk_id <
+		    (dev->internal_start_block * dev->param.chunks_per_block) ||
+		    chunk_id >=
+		    ((dev->internal_end_block + 1) *
+		      dev->param.chunks_per_block)) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Found daft chunk_id %d for %d",
+				chunk_id, i);
+		} else {
+			in->n_data_chunks--;
+			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
+		}
+	}
+}
+
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
+{
+	int new_full;
+	u32 new_partial;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
+
+	yaffs_prune_chunks(obj, new_size);
+
+	if (new_partial != 0) {
+		int last_chunk = 1 + new_full;
+		u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+		/* Rewrite the last chunk with its new size and zero pad */
+		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
+		memset(local_buffer + new_partial, 0,
+		       dev->data_bytes_per_chunk - new_partial);
+
+		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
+				  new_partial, 1);
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+	}
+
+	obj->variant.file_variant.file_size = new_size;
+
+	yaffs_prune_tree(dev, &obj->variant.file_variant);
+}
+
+int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
+{
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+
+	yaffs_flush_file_cache(in);
+	yaffs_invalidate_whole_cache(in);
+
+	yaffs_check_gc(dev, 0);
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (new_size == old_size)
+		return YAFFS_OK;
+
+	if (new_size > old_size) {
+		yaffs2_handle_hole(in, new_size);
+		in->variant.file_variant.file_size = new_size;
+	} else {
+		/* new_size < old_size */
+		yaffs_resize_file_down(in, new_size);
+	}
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->is_shadowed &&
+	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
+		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
+
+	return YAFFS_OK;
+}
+
+int yaffs_flush_file(struct yaffs_obj *in, int update_time, int data_sync)
+{
+	if (!in->dirty)
+		return YAFFS_OK;
+
+	yaffs_flush_file_cache(in);
+
+	if (data_sync)
+		return YAFFS_OK;
+
+	if (update_time)
+		yaffs_load_current_time(in, 0, 0);
+
+	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
+				YAFFS_OK : YAFFS_FAIL;
+}
+
+
+/* yaffs_del_file deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
+{
+	int ret_val;
+	int del_now = 0;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!in->my_inode)
+		del_now = 1;
+
+	if (del_now) {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->del_dir,
+					  _Y("deleted"), 0, 0);
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: immediate deletion of file %d",
+			in->obj_id);
+		in->deleted = 1;
+		in->my_dev->n_deleted_files++;
+		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+			yaffs_resize_file(in, 0);
+		yaffs_soft_del_file(in);
+	} else {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
+					  _Y("unlinked"), 0, 0);
+	}
+	return ret_val;
+}
+
+static int yaffs_del_file(struct yaffs_obj *in)
+{
+	int ret_val = YAFFS_OK;
+	int deleted;	/* Need to cache value on stack if in is freed */
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+		yaffs_resize_file(in, 0);
+
+	if (in->n_data_chunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			ret_val = yaffs_unlink_file_if_needed(in);
+
+		deleted = in->deleted;
+
+		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->my_dev->n_deleted_files++;
+			yaffs_soft_del_file(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
+		in->variant.file_variant.top = NULL;
+		yaffs_generic_obj_del(in);
+
+		return YAFFS_OK;
+	}
+}
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
+{
+	return (obj &&
+		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(list_empty(&obj->variant.dir_variant.children));
+}
+
+static int yaffs_del_dir(struct yaffs_obj *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_generic_obj_del(obj);
+}
+
+static int yaffs_del_symlink(struct yaffs_obj *in)
+{
+	kfree(in->variant.symlink_variant.alias);
+	in->variant.symlink_variant.alias = NULL;
+
+	return yaffs_generic_obj_del(in);
+}
+
+static int yaffs_del_link(struct yaffs_obj *in)
+{
+	/* remove this hardlink from the list associated with the equivalent
+	 * object
+	 */
+	list_del_init(&in->hard_links);
+	return yaffs_generic_obj_del(in);
+}
+
+int yaffs_del_obj(struct yaffs_obj *obj)
+{
+	int ret_val = -1;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		ret_val = yaffs_del_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!list_empty(&obj->variant.dir_variant.dirty)) {
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+				"Remove object %d from dirty directories",
+				obj->obj_id);
+			list_del_init(&obj->variant.dir_variant.dirty);
+		}
+		return yaffs_del_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		ret_val = yaffs_del_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		ret_val = yaffs_del_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		ret_val = yaffs_generic_obj_del(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		ret_val = 0;
+		break;		/* should not happen. */
+	}
+	return ret_val;
+}
+
+static int yaffs_unlink_worker(struct yaffs_obj *obj)
+{
+	int del_now = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (!obj->my_inode)
+		del_now = 1;
+
+	yaffs_update_parent(obj->parent);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_del_link(obj);
+	} else if (!list_empty(&obj->hard_links)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Move it from its parent directory so that the rename works.
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		struct yaffs_obj *hl;
+		struct yaffs_obj *parent;
+		int ret_val;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
+				hard_links);
+
+		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+		parent = hl->parent;
+
+		list_del_init(&hl->hard_links);
+
+		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
+
+		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
+
+		if (ret_val == YAFFS_OK)
+			ret_val = yaffs_generic_obj_del(hl);
+
+		return ret_val;
+
+	} else if (del_now) {
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_del_file(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			list_del_init(&obj->variant.dir_variant.dirty);
+			return yaffs_del_dir(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_del_symlink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_generic_obj_del(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if (yaffs_is_non_empty_dir(obj)) {
+		return YAFFS_FAIL;
+	} else {
+		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
+						_Y("unlinked"), 0, 0);
+	}
+}
+
+static int yaffs_unlink_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->unlink_allowed)
+		return yaffs_unlink_worker(obj);
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
+{
+	struct yaffs_obj *obj;
+
+	obj = yaffs_find_by_name(dir, name);
+	return yaffs_unlink_obj(obj);
+}
+
+/* Note:
+ * If old_name is NULL then we take old_dir as the object to be renamed.
+ */
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
+		     struct yaffs_obj *new_dir, const YCHAR *new_name)
+{
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *existing_target = NULL;
+	int force = 0;
+	int result;
+	struct yaffs_dev *dev;
+
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	dev = old_dir->my_dev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems.
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	 */
+	if (old_dir == new_dir &&
+		old_name && new_name &&
+		strcmp(old_name, new_name) == 0)
+		force = 1;
+#endif
+
+	if (strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
+	    YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	if (old_name)
+		obj = yaffs_find_by_name(old_dir, old_name);
+	else{
+		obj = old_dir;
+		old_dir = obj->parent;
+	}
+
+	if (obj && obj->rename_allowed) {
+		/* Now handle an existing target, if there is one */
+		existing_target = yaffs_find_by_name(new_dir, new_name);
+		if (yaffs_is_non_empty_dir(existing_target)) {
+			return YAFFS_FAIL;	/* ENOTEMPTY */
+		} else if (existing_target && existing_target != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc here otherwise it can mess
+			 * up the shadowing.
+			 *
+			 */
+			dev->gc_disable = 1;
+			yaffs_change_obj_name(obj, new_dir, new_name, force,
+					      existing_target->obj_id);
+			existing_target->is_shadowed = 1;
+			yaffs_unlink_obj(existing_target);
+			dev->gc_disable = 0;
+		}
+
+		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
+
+		yaffs_update_parent(old_dir);
+		if (new_dir != old_dir)
+			yaffs_update_parent(new_dir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning)
+{
+	struct yaffs_obj *obj;
+
+	if (backward_scanning) {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_find_by_number(dev, obj_id);
+		if (obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that
+	 * it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->is_shadowed = 1;
+	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
+	obj->variant.file_variant.shrink_size = 0;
+	obj->valid = 1;		/* So that we don't read any other info. */
+}
+
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
+{
+	struct list_head *lh;
+	struct list_head *save;
+	struct yaffs_obj *hl;
+	struct yaffs_obj *in;
+
+	list_for_each_safe(lh, save, hard_list) {
+		hl = list_entry(lh, struct yaffs_obj, hard_links);
+		in = yaffs_find_by_number(dev,
+					hl->variant.hardlink_variant.equiv_id);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardlink_variant.equiv_obj = in;
+			list_add(&hl->hard_links, &in->hard_links);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardlink_variant.equiv_obj = NULL;
+			INIT_LIST_HEAD(&hl->hard_links);
+		}
+	}
+}
+
+static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
+{
+	/*
+	 *  Sort out state of unlinked and deleted objects after scanning.
+	 */
+	struct list_head *i;
+	struct list_head *n;
+	struct yaffs_obj *l;
+
+	if (dev->read_only)
+		return;
+
+	/* Soft delete all the unlinked files */
+	list_for_each_safe(i, n,
+			   &dev->unlinked_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+
+	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships
+ *  between directories:
+ *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
+ *   lost-n-found->parent == root_dir
+ *
+ * This fixes the problem where directories might have inadvertently been
+ * deleted leaving the object "hanging" without being rooted in the
+ * directory tree.
+ */
+
+static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+	return (obj == dev->del_dir ||
+		obj == dev->unlinked_dir || obj == dev->root_dir);
+}
+
+static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_obj *parent;
+	int i;
+	struct list_head *lh;
+	struct list_head *n;
+	int depth_limit;
+	int hanging;
+
+	if (dev->read_only)
+		return;
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			parent = obj->parent;
+
+			if (yaffs_has_null_parent(dev, obj)) {
+				/* These directories are not hanging */
+				hanging = 0;
+			} else if (!parent ||
+				   parent->variant_type !=
+				   YAFFS_OBJECT_TYPE_DIRECTORY) {
+				hanging = 1;
+			} else if (yaffs_has_null_parent(dev, parent)) {
+				hanging = 0;
+			} else {
+				/*
+				 * Need to follow the parent chain to
+				 * see if it is hanging.
+				 */
+				hanging = 0;
+				depth_limit = 100;
+
+				while (parent != dev->root_dir &&
+				       parent->parent &&
+				       parent->parent->variant_type ==
+				       YAFFS_OBJECT_TYPE_DIRECTORY &&
+				       depth_limit > 0) {
+					parent = parent->parent;
+					depth_limit--;
+				}
+				if (parent != dev->root_dir)
+					hanging = 1;
+			}
+			if (hanging) {
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Hanging object %d moved to lost and found",
+					obj->obj_id);
+				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+			}
+		}
+	}
+}
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_del_dir_contents(struct yaffs_obj *dir)
+{
+	struct yaffs_obj *obj;
+	struct list_head *lh;
+	struct list_head *n;
+
+	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		BUG();
+
+	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
+			yaffs_del_dir_contents(obj);
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Deleting lost_found object %d",
+			obj->obj_id);
+		yaffs_unlink_obj(obj);
+	}
+}
+
+static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
+{
+	yaffs_del_dir_contents(dev->lost_n_found);
+}
+
+
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
+				     const YCHAR *name)
+{
+	int sum;
+	struct list_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: null pointer directory"
+			);
+		BUG();
+		return NULL;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: non-directory"
+			);
+		BUG();
+	}
+
+	sum = yaffs_calc_name_sum(name);
+
+	list_for_each(i, &directory->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+
+		if (l->parent != directory)
+			BUG();
+
+		yaffs_check_obj_details_loaded(l);
+
+		/* Special case for lost-n-found */
+		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+			if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
+				return l;
+		} else if (l->sum == sum || l->hdr_chunk <= 0) {
+			/* LostnFound chunk called Objxxx
+			 * Do a real check
+			 */
+			yaffs_get_obj_name(l, buffer,
+				YAFFS_MAX_NAME_LENGTH + 1);
+			if (!strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
+				return l;
+		}
+	}
+	return NULL;
+}
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		obj = obj->variant.hardlink_variant.equiv_obj;
+		yaffs_check_obj_details_loaded(obj);
+	}
+	return obj;
+}
+
+/*
+ *  A note or two on object names.
+ *  * If the object name is missing, we then make one up in the form objnnn
+ *
+ *  * ASCII names are stored in the object header's name field from byte zero
+ *  * Unicode names are historically stored starting from byte zero.
+ *
+ * Then there are automatic Unicode names...
+ * The purpose of these is to save names in a way that can be read as
+ * ASCII or Unicode names as appropriate, thus allowing a Unicode and ASCII
+ * system to share files.
+ *
+ * These automatic unicode are stored slightly differently...
+ *  - If the name can fit in the ASCII character space then they are saved as
+ *    ascii names as per above.
+ *  - If the name needs Unicode then the name is saved in Unicode
+ *    starting at oh->name[1].
+
+ */
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size)
+{
+	/* Create an object name if we could not find one. */
+	if (strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
+		YCHAR local_name[20];
+		YCHAR num_string[20];
+		YCHAR *x = &num_string[19];
+		unsigned v = obj->obj_id;
+		num_string[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
+		strcat(local_name, x);
+		strncpy(name, local_name, buffer_size - 1);
+	}
+}
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
+{
+	memset(name, 0, buffer_size * sizeof(YCHAR));
+	yaffs_check_obj_details_loaded(obj);
+	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+	} else if (obj->short_name[0]) {
+		strcpy(name, obj->short_name);
+	} else if (obj->hdr_chunk > 0) {
+		int result;
+		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
+
+		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
+
+		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
+
+		if (obj->hdr_chunk > 0) {
+			result = yaffs_rd_chunk_tags_nand(obj->my_dev,
+							  obj->hdr_chunk,
+							  buffer, NULL);
+		}
+		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
+					buffer_size);
+
+		yaffs_release_temp_buffer(obj->my_dev, buffer);
+	}
+
+	yaffs_fix_null_name(obj, name, buffer_size);
+
+	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
+}
+
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_get_equivalent_obj(obj);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.file_variant.file_size;
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		if (!obj->variant.symlink_variant.alias)
+			return 0;
+		return strnlen(obj->variant.symlink_variant.alias,
+				     YAFFS_MAX_ALIAS_LENGTH);
+	} else {
+		/* Only a directory should drop through to here */
+		return obj->my_dev->data_bytes_per_chunk;
+	}
+}
+
+int yaffs_get_obj_link_count(struct yaffs_obj *obj)
+{
+	int count = 0;
+	struct list_head *i;
+
+	if (!obj->unlinked)
+		count++;	/* the object itself */
+
+	list_for_each(i, &obj->hard_links)
+	    count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_get_obj_inode(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	return obj->obj_id;
+}
+
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+		return DT_REG;
+		break;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_clone_str(obj->variant.symlink_variant.alias);
+	else
+		return yaffs_clone_str(_Y(""));
+}
+
+/*--------------------------- Initialisation code -------------------------- */
+
+static int yaffs_check_dev_fns(const struct yaffs_dev *dev)
+{
+	/* Common functions, gotta have */
+	if (!dev->param.erase_fn || !dev->param.initialise_flash_fn)
+		return 0;
+
+	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+	if (dev->param.write_chunk_tags_fn &&
+	    dev->param.read_chunk_tags_fn &&
+	    !dev->param.write_chunk_fn &&
+	    !dev->param.read_chunk_fn &&
+	    dev->param.bad_block_fn && dev->param.query_block_fn)
+		return 1;
+
+	/* Can use the "spare" style interface for yaffs1 */
+	if (!dev->param.is_yaffs2 &&
+	    !dev->param.write_chunk_tags_fn &&
+	    !dev->param.read_chunk_tags_fn &&
+	    dev->param.write_chunk_fn &&
+	    dev->param.read_chunk_fn &&
+	    !dev->param.bad_block_fn && !dev->param.query_block_fn)
+		return 1;
+
+	return 0;		/* bad */
+}
+
+static int yaffs_create_initial_dir(struct yaffs_dev *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost+found directories */
+	dev->lost_n_found = dev->root_dir = NULL;
+	dev->unlinked_dir = dev->del_dir = NULL;
+	dev->unlinked_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+	dev->del_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+	dev->root_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
+				  YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lost_n_found =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
+	    && dev->del_dir) {
+		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+int yaffs_guts_initialise(struct yaffs_dev *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()");
+
+	/* Check stuff that must be set */
+
+	if (!dev) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: Need a device"
+			);
+		return YAFFS_FAIL;
+	}
+
+	if (dev->is_mounted) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		return YAFFS_FAIL;
+	}
+
+	dev->internal_start_block = dev->param.start_block;
+	dev->internal_end_block = dev->param.end_block;
+	dev->block_offset = 0;
+	dev->chunk_offset = 0;
+	dev->n_free_chunks = 0;
+
+	dev->gc_block = 0;
+
+	if (dev->param.start_block == 0) {
+		dev->internal_start_block = dev->param.start_block + 1;
+		dev->internal_end_block = dev->param.end_block + 1;
+		dev->block_offset = 1;
+		dev->chunk_offset = dev->param.chunks_per_block;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
+		dev->param.total_bytes_per_chunk < 1024) ||
+		(!dev->param.is_yaffs2 &&
+			dev->param.total_bytes_per_chunk < 512) ||
+		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
+		 dev->param.chunks_per_block < 2 ||
+		 dev->param.n_reserved_blocks < 2 ||
+		dev->internal_start_block <= 0 ||
+		dev->internal_end_block <= 0 ||
+		dev->internal_end_block <=
+		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
+		) {
+		/* otherwise it is too small */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
+			dev->param.total_bytes_per_chunk,
+			dev->param.is_yaffs2 ? "2" : "",
+			dev->param.inband_tags);
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_init_nand(dev) != YAFFS_OK) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->param.inband_tags)
+		dev->data_bytes_per_chunk =
+		    dev->param.total_bytes_per_chunk -
+		    sizeof(struct yaffs_packed_tags2_tags_only);
+	else
+		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_check_dev_fns(dev)) {
+		/* Function missing */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"device function(s) missing or wrong");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished with most checks. Further checks happen later on too. */
+
+	dev->is_mounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->data_bytes_per_chunk;
+	/* We always use dev->chunk_shift and dev->chunk_div */
+	dev->chunk_shift = calc_shifts(x);
+	x >>= dev->chunk_shift;
+	dev->chunk_div = x;
+	/* We only use chunk mask if chunk_div is 1 */
+	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
+
+	/*
+	 * Calculate chunk_grp_bits.
+	 * We need to find the next power of 2 > than internal_end_block
+	 */
+
+	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
+
+	bits = calc_shifts_ceiling(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->param.wide_tnodes_disabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnode_width = 16;
+		else
+			dev->tnode_width = bits;
+	} else {
+		dev->tnode_width = 16;
+	}
+
+	dev->tnode_mask = (1 << dev->tnode_width) - 1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunk_grp_size
+	 */
+
+	if (bits <= dev->tnode_width)
+		dev->chunk_grp_bits = 0;
+	else
+		dev->chunk_grp_bits = bits - dev->tnode_width;
+
+	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
+	if (dev->tnode_size < sizeof(struct yaffs_tnode))
+		dev->tnode_size = sizeof(struct yaffs_tnode);
+
+	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
+
+	if (dev->param.chunks_per_block < dev->chunk_grp_size) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished verifying the device, continue with initialisation */
+
+	/* More device initialisation */
+	dev->all_gcs = 0;
+	dev->passive_gc_count = 0;
+	dev->oldest_dirty_gc_count = 0;
+	dev->bg_gcs = 0;
+	dev->gc_block_finder = 0;
+	dev->buffered_block = -1;
+	dev->doing_buffered_block_rewrite = 0;
+	dev->n_deleted_files = 0;
+	dev->n_bg_deletions = 0;
+	dev->n_unlinked_files = 0;
+	dev->n_ecc_fixed = 0;
+	dev->n_ecc_unfixed = 0;
+	dev->n_tags_ecc_fixed = 0;
+	dev->n_tags_ecc_unfixed = 0;
+	dev->n_erase_failures = 0;
+	dev->n_erased_blocks = 0;
+	dev->gc_disable = 0;
+	dev->has_pending_prioritised_gc = 1;
+		/* Assume the worst for now, will get fixed on first GC */
+	INIT_LIST_HEAD(&dev->dirty_dirs);
+	dev->oldest_dirty_seq = 0;
+	dev->oldest_dirty_block = 0;
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_init_tmp_buffers(dev))
+		init_failed = 1;
+
+	dev->cache = NULL;
+	dev->gc_cleanup_list = NULL;
+
+	if (!init_failed && dev->param.n_caches > 0) {
+		int i;
+		void *buf;
+		int cache_bytes =
+		    dev->param.n_caches * sizeof(struct yaffs_cache);
+
+		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
+
+		buf = (u8 *) dev->cache;
+
+		if (dev->cache)
+			memset(dev->cache, 0, cache_bytes);
+
+		for (i = 0; i < dev->param.n_caches && buf; i++) {
+			dev->cache[i].object = NULL;
+			dev->cache[i].last_use = 0;
+			dev->cache[i].dirty = 0;
+			dev->cache[i].data = buf =
+			    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->cache_last_use = 0;
+	}
+
+	dev->cache_hits = 0;
+
+	if (!init_failed) {
+		dev->gc_cleanup_list =
+		    kmalloc(dev->param.chunks_per_block * sizeof(u32),
+					GFP_NOFS);
+		if (!dev->gc_cleanup_list)
+			init_failed = 1;
+	}
+
+	if (dev->param.is_yaffs2)
+		dev->param.use_header_file_size = 1;
+
+	if (!init_failed && !yaffs_init_blocks(dev))
+		init_failed = 1;
+
+	yaffs_init_tnodes_and_objs(dev);
+
+	if (!init_failed && !yaffs_create_initial_dir(dev))
+		init_failed = 1;
+
+	if (!init_failed && dev->param.is_yaffs2 &&
+		!dev->param.disable_summary &&
+		!yaffs_summary_init(dev))
+		init_failed = 1;
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->param.is_yaffs2) {
+			if (yaffs2_checkpt_restore(dev)) {
+				yaffs_check_obj_details_loaded(dev->root_dir);
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
+					YAFFS_TRACE_MOUNT,
+					"yaffs: restored from checkpoint"
+					);
+			} else {
+
+				/* Clean up the mess caused by an aborted
+				 * checkpoint load then scan backwards.
+				 */
+				yaffs_deinit_blocks(dev);
+
+				yaffs_deinit_tnodes_and_objs(dev);
+
+				dev->n_erased_blocks = 0;
+				dev->n_free_chunks = 0;
+				dev->alloc_block = -1;
+				dev->alloc_page = -1;
+				dev->n_deleted_files = 0;
+				dev->n_unlinked_files = 0;
+				dev->n_bg_deletions = 0;
+
+				if (!init_failed && !yaffs_init_blocks(dev))
+					init_failed = 1;
+
+				yaffs_init_tnodes_and_objs(dev);
+
+				if (!init_failed
+				    && !yaffs_create_initial_dir(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs2_scan_backwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs1_scan(dev)) {
+			init_failed = 1;
+		}
+
+		yaffs_strip_deleted_objs(dev);
+		yaffs_fix_hanging_objs(dev);
+		if (dev->param.empty_lost_n_found)
+			yaffs_empty_l_n_f(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		yaffs_trace(YAFFS_TRACE_TRACING,
+		  "yaffs: yaffs_guts_initialise() aborted.");
+
+		yaffs_deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->n_page_reads = 0;
+	dev->n_page_writes = 0;
+	dev->n_erasures = 0;
+	dev->n_gc_copies = 0;
+	dev->n_retried_writes = 0;
+
+	dev->n_retired_blocks = 0;
+
+	yaffs_verify_free_chunks(dev);
+	yaffs_verify_blocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
+		yaffs2_checkpt_invalidate(dev);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+	  "yaffs: yaffs_guts_initialise() done.");
+	return YAFFS_OK;
+}
+
+void yaffs_deinitialise(struct yaffs_dev *dev)
+{
+	if (dev->is_mounted) {
+		int i;
+
+		yaffs_deinit_blocks(dev);
+		yaffs_deinit_tnodes_and_objs(dev);
+		yaffs_summary_deinit(dev);
+
+		if (dev->param.n_caches > 0 && dev->cache) {
+
+			for (i = 0; i < dev->param.n_caches; i++) {
+				kfree(dev->cache[i].data);
+				dev->cache[i].data = NULL;
+			}
+
+			kfree(dev->cache);
+			dev->cache = NULL;
+		}
+
+		kfree(dev->gc_cleanup_list);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+			kfree(dev->temp_buffer[i].buffer);
+
+		dev->is_mounted = 0;
+
+		if (dev->param.deinitialise_flash_fn)
+			dev->param.deinitialise_flash_fn(dev);
+	}
+}
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev)
+{
+	int n_free = 0;
+	int b;
+	struct yaffs_block_info *blk;
+
+	blk = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+		switch (blk->block_state) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			n_free +=
+			    (dev->param.chunks_per_block - blk->pages_in_use +
+			     blk->soft_del_pages);
+			break;
+		default:
+			break;
+		}
+		blk++;
+	}
+	return n_free;
+}
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
+{
+	/* This is what we report to the outside world */
+	int n_free;
+	int n_dirty_caches;
+	int blocks_for_checkpt;
+	int i;
+
+	n_free = dev->n_free_chunks;
+	n_free += dev->n_deleted_files;
+
+	/* Now count and subtract the number of dirty chunks in the cache. */
+
+	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].dirty)
+			n_dirty_caches++;
+	}
+
+	n_free -= n_dirty_caches;
+
+	n_free -=
+	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
+
+	/* Now figure checkpoint space and report that... */
+	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
+
+	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
+
+	if (n_free < 0)
+		n_free = 0;
+
+	return n_free;
+}
+
+/*
+ * Marshalling functions to get loff_t file sizes into and out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
+{
+	oh->file_size_low = (fsize & 0xFFFFFFFF);
+	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
+}
+
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
+{
+	loff_t retval;
+
+	if (sizeof(loff_t) >= 8 && ~(oh->file_size_high))
+		retval = (((loff_t) oh->file_size_high) << 32) |
+			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
+	else
+		retval = (loff_t) oh->file_size_low;
+
+	return retval;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_guts.h linux-3.1.5/fs/yaffs2/yaffs_guts.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_guts.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_guts.h	2012-10-25 16:28:38.745881512 -0600
@@ -0,0 +1,975 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xff
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941ff53
+
+/*
+ * Tnodes form a tree with the tnodes in "levels"
+ * Levels greater than 0 hold 8 slots which point to other tnodes.
+ * Those at level 0 hold 16 slots which point to chunks in NAND.
+ *
+ * A maximum level of 8 thust supports files of size up to:
+ *
+ * 2^(3*MAX_LEVEL+4)
+ *
+ * Thus a max level of 8 supports files with up to 2^^28 chunks which gives
+ * a maximum file size of arounf 51Gbytees with 2k chunks.
+ */
+#define YAFFS_NTNODES_LEVEL0		16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		8
+#define YAFFS_TNODES_MAX_BITS		(YAFFS_TNODES_LEVEL0_BITS + \
+					YAFFS_TNODES_INTERNAL_BITS * \
+					YAFFS_TNODES_MAX_LEVEL)
+#define YAFFS_MAX_CHUNK_ID		((1 << YAFFS_TNODES_MAX_BITS) - 1)
+
+#define YAFFS_MAX_FILE_SIZE_32		0x7fffffff
+
+/* Constants for YAFFS1 mode */
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK	(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+#define YAFFS_OBJECT_SPACE		0x40000
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
+
+/* Binary data version stamps */
+#define YAFFS_SUMMARY_VERSION		1
+#define YAFFS_CHECKPOINT_VERSION	7
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Fake object Id for summary data */
+#define YAFFS_OBJECTID_SUMMARY		0x10
+
+/* Pseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA	0x21
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
+
+/* ChunkCache is used for short read/write operations.*/
+struct yaffs_cache {
+	struct yaffs_obj *object;
+	int chunk_id;
+	int last_use;
+	int dirty;
+	int n_bytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+	u8 *data;
+};
+
+/* yaffs1 tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary
+ * otherwise the structure size will get blown out.
+ */
+
+struct yaffs_tags {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes_lsb:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned n_bytes_msb:2;
+};
+
+union yaffs_tags_union {
+	struct yaffs_tags as_tags;
+	u8 as_bytes[8];
+};
+
+
+/* Stuff used for extended tags in YAFFS2 */
+
+enum yaffs_ecc_result {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+};
+
+enum yaffs_obj_type {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+};
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+struct yaffs_ext_tags {
+	unsigned chunk_used;	/*  Status of the chunk: used or unused */
+	unsigned obj_id;	/* If 0 this is not used */
+	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
+	unsigned n_bytes;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	enum yaffs_ecc_result ecc_result;
+	unsigned block_bad;
+
+	/* YAFFS 1 stuff */
+	unsigned is_deleted;	/* The chunk is marked deleted */
+	unsigned serial_number;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned seq_number;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extra_available;	/* Extra info available if not zero */
+	unsigned extra_parent_id;	/* The parent object */
+	unsigned extra_is_shrink;	/* Is it a shrink header? */
+	unsigned extra_shadows;	/* Does this shadow another object? */
+
+	enum yaffs_obj_type extra_obj_type;	/* What object type? */
+
+	loff_t extra_file_size;		/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
+};
+
+/* Spare structure for YAFFS1 */
+struct yaffs_spare {
+	u8 tb0;
+	u8 tb1;
+	u8 tb2;
+	u8 tb3;
+	u8 page_status;		/* set to 0 to delete the chunk */
+	u8 block_status;
+	u8 tb4;
+	u8 tb5;
+	u8 ecc1[3];
+	u8 tb6;
+	u8 tb7;
+	u8 ecc2[3];
+};
+
+/*Special structure for passing through to mtd */
+struct yaffs_nand_spare {
+	struct yaffs_spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+enum yaffs_block_state {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	/* Being scanned */
+
+	YAFFS_BLOCK_STATE_NEEDS_SCAN,
+	/* The block might have something on it (ie it is allocating or full,
+	 * perhaps empty) but it needs to be scanned to determine its true
+	 * state.
+	 * This state is only valid during scanning.
+	 * NB We tolerate empty because the pre-scanner might be incapable of
+	 * deciding
+	 * However, if this state is returned on a YAFFS2 device,
+	 * then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these.
+	 * If a block is only partially allocated at mount it is treated as
+	 * full.
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 * If a block was only partially allocated when mounted we treat
+	 * it as fully allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* The block was full and now all chunks have been deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data. */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	    /* This block has failed and is not in use */
+};
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+struct yaffs_block_info {
+
+	int soft_del_pages:10;	/* number of soft deleted pages */
+	int pages_in_use:10;	/* number of pages in use */
+	unsigned block_state:4;	/* One of the above block states. */
+				/* NB use unsigned because enum is sometimes
+				 * an int */
+	u32 needs_retiring:1;	/* Data has failed on this block, */
+				/*need to get valid data off and retire*/
+	u32 skip_erased_check:1;/* Skip the erased check on this block */
+	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
+				   Block should be prioritised for GC */
+	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
+				failures on this block and tried to reuse it */
+	u32 has_summary:1;	/* The block has a summary */
+
+	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
+	u32 seq_number;		/* block sequence number for yaffs2 */
+
+};
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+struct yaffs_obj_hdr {
+	enum yaffs_obj_type type;
+
+	/* Apply to everything  */
+	int parent_obj_id;
+	u16 sum_no_longer_used;	/* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to all object types except for hard links */
+	u32 yst_mode;		/* protection */
+
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+
+	/* File size  applies to files only */
+	u32 file_size_low;
+
+	/* Equivalent object id applies to hard links only. */
+	int equiv_id;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
+
+	u32 win_ctime[2];
+	u32 win_atime[2];
+	u32 win_mtime[2];
+
+	u32 inband_shadowed_obj_id;
+	u32 inband_is_shrink;
+
+	u32 file_size_high;
+	u32 reserved[1];
+	int shadows_obj;	/* This object header shadows the
+				specified object if > 0 */
+
+	/* is_shrink applies to object headers written when wemake a hole. */
+	u32 is_shrink;
+
+};
+
+/*--------------------------- Tnode -------------------------- */
+
+struct yaffs_tnode {
+	struct yaffs_tnode *internal[YAFFS_NTNODES_INTERNAL];
+};
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+struct yaffs_file_var {
+	loff_t file_size;
+	loff_t scanned_size;
+	loff_t shrink_size;
+	int top_level;
+	struct yaffs_tnode *top;
+};
+
+struct yaffs_dir_var {
+	struct list_head children;	/* list of child links */
+	struct list_head dirty;	/* Entry for list of dirty directories */
+};
+
+struct yaffs_symlink_var {
+	YCHAR *alias;
+};
+
+struct yaffs_hardlink_var {
+	struct yaffs_obj *equiv_obj;
+	u32 equiv_id;
+};
+
+union yaffs_obj_var {
+	struct yaffs_file_var file_variant;
+	struct yaffs_dir_var dir_variant;
+	struct yaffs_symlink_var symlink_variant;
+	struct yaffs_hardlink_var hardlink_variant;
+};
+
+struct yaffs_obj {
+	u8 deleted:1;		/* This should only apply to unlinked files. */
+	u8 soft_del:1;		/* it has also been soft deleted */
+	u8 unlinked:1;		/* An unlinked file.*/
+	u8 fake:1;		/* A fake object has no presence on NAND. */
+	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
+	u8 unlink_allowed:1;
+	u8 dirty:1;		/* the object needs to be written to flash */
+	u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available
+				 * ie. file data chunks encountered before
+				* the header.
+				 */
+	u8 lazy_loaded:1;	/* This object has been lazy loaded and
+				 * is missing some detail */
+
+	u8 defered_free:1;	/* Object is removed from NAND, but is
+				 * still in the inode cache.
+				 * Free of object is defered.
+				 * until the inode is released.
+				 */
+	u8 being_created:1;	/* This object is still being created
+				 * so skip some verification checks. */
+	u8 is_shadowed:1;	/* This object is shadowed on the way
+				 * to being renamed. */
+
+	u8 xattr_known:1;	/* We know if this has object has xattribs
+				 * or not. */
+	u8 has_xattr:1;		/* This object has xattribs.
+				 * Only valid if xattr_known. */
+
+	u8 serial;		/* serial number of chunk in NAND.*/
+	u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_dev *my_dev;	/* The device I'm on */
+
+	struct list_head hash_link;	/* list of objects in hash bucket */
+
+	struct list_head hard_links;	/* hard linked object chain*/
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_obj *parent;
+	struct list_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdr_chunk;
+
+	int n_data_chunks;	/* Number of data chunks for this file. */
+
+	u32 obj_id;		/* the object id value */
+
+	u32 yst_mode;
+
+	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
+
+#ifdef CONFIG_YAFFS_WINCE
+	u32 win_ctime[2];
+	u32 win_mtime[2];
+	u32 win_atime[2];
+#else
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+#endif
+
+	u32 yst_rdev;
+
+	void *my_inode;
+
+	enum yaffs_obj_type variant_type;
+
+	union yaffs_obj_var variant;
+
+};
+
+struct yaffs_obj_bucket {
+	struct list_head list;
+	int count;
+};
+
+/* yaffs_checkpt_obj holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+struct yaffs_checkpt_obj {
+	int struct_type;
+	u32 obj_id;
+	u32 parent_id;
+	int hdr_chunk;
+	enum yaffs_obj_type variant_type:3;
+	u8 deleted:1;
+	u8 soft_del:1;
+	u8 unlinked:1;
+	u8 fake:1;
+	u8 rename_allowed:1;
+	u8 unlink_allowed:1;
+	u8 serial;
+	int n_data_chunks;
+	loff_t size_or_equiv_obj;
+};
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few.
+ */
+
+struct yaffs_buffer {
+	u8 *buffer;
+	int in_use;
+};
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_param {
+	const YCHAR *name;
+
+	/*
+	 * Entry parameters set up way early. Yaffs sets up the rest.
+	 * The structure should be zeroed out before use so that unused
+	 * and defualt values are zero.
+	 */
+
+	int inband_tags;	/* Use unband tags */
+	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
+					 be a power of 2 */
+	int chunks_per_block;	/* does not need to be a power of 2 */
+	int spare_bytes_per_chunk;	/* spare area size */
+	int start_block;	/* Start block we're allowed to use */
+	int end_block;		/* End block we're allowed to use */
+	int n_reserved_blocks;	/* Tuneable so that we can reduce
+				 * reserved blocks on NOR and RAM. */
+
+	int n_caches;		/* If <= 0, then short op caching is disabled,
+				 * else the number of short op caches.
+				 */
+	int use_nand_ecc;	/* Flag to decide whether or not to use
+				 * NAND driver ECC on data (yaffs1) */
+	int tags_9bytes;	/* Use 9 byte tags */
+	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
+				 * on packed tags (yaffs2) */
+
+	int is_yaffs2;		/* Use yaffs2 mode on this device */
+
+	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
+
+	int refresh_period;	/* How often to check for a block refresh */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	u8 skip_checkpt_rd;
+	u8 skip_checkpt_wr;
+
+	int enable_xattr;	/* Enable xattribs */
+
+	/* NAND access functions (Must be set before calling YAFFS) */
+
+	int (*write_chunk_fn) (struct yaffs_dev *dev,
+			       int nand_chunk, const u8 *data,
+			       const struct yaffs_spare *spare);
+	int (*read_chunk_fn) (struct yaffs_dev *dev,
+			      int nand_chunk, u8 *data,
+			      struct yaffs_spare *spare);
+	int (*erase_fn) (struct yaffs_dev *dev, int flash_block);
+	int (*initialise_flash_fn) (struct yaffs_dev *dev);
+	int (*deinitialise_flash_fn) (struct yaffs_dev *dev);
+
+	/* yaffs2 mode functions */
+	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags);
+	int (*bad_block_fn) (struct yaffs_dev *dev, int block_no);
+	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number);
+
+	/* The remove_obj_fn function must be supplied by OS flavours that
+	 * need it.
+	 * yaffs direct uses it to implement the faster readdir.
+	 * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*remove_obj_fn) (struct yaffs_obj *obj);
+
+	/* Callback to mark the superblock dirty */
+	void (*sb_dirty_fn) (struct yaffs_dev *dev);
+
+	/*  Callback to control garbage collection. */
+	unsigned (*gc_control) (struct yaffs_dev *dev);
+
+	/* Debug control flags. Don't use unless you know what you're doing */
+	int use_header_file_size;	/* Flag to determine if we should use
+					 * file sizes from the header */
+	int disable_lazy_load;	/* Disable lazy loading on this device */
+	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
+	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
+				 * softdeletion. */
+
+	int defered_dir_update;	/* Set to defer directory updates */
+
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	int auto_unicode;
+#endif
+	int always_check_erased;	/* Force chunk erased check always on */
+
+	int disable_summary;
+
+	int max_objects;	/*
+				 * Set to limit the number of objects created.
+				 * 0 = no limit.
+				*/
+};
+
+struct yaffs_dev {
+	struct yaffs_param param;
+
+	/* Context storage. Holds extra OS specific data for this device */
+
+	void *os_context;
+	void *driver_context;
+
+	struct list_head dev_list;
+
+	/* Runtime parameters. Set up by YAFFS. */
+	int data_bytes_per_chunk;
+
+	/* Non-wide tnode stuff */
+	u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
+				 * the tnodes are not wide enough.
+				 */
+	u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
+
+	/* Stuff to support wide tnodes */
+	u32 tnode_width;
+	u32 tnode_mask;
+	u32 tnode_size;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	u32 chunk_shift;	/* Shift value */
+	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
+	u32 chunk_mask;		/* Mask to use for power-of-2 case */
+
+	int is_mounted;
+	int read_only;
+	int is_checkpointed;
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internal_start_block;
+	int internal_end_block;
+	int block_offset;
+	int chunk_offset;
+
+	/* Runtime checkpointing stuff */
+	int checkpt_page_seq;	/* running sequence number of checkpt pages */
+	int checkpt_byte_count;
+	int checkpt_byte_offs;
+	u8 *checkpt_buffer;
+	int checkpt_open_write;
+	int blocks_in_checkpt;
+	int checkpt_cur_chunk;
+	int checkpt_cur_block;
+	int checkpt_next_block;
+	int *checkpt_block_list;
+	int checkpt_max_blocks;
+	u32 checkpt_sum;
+	u32 checkpt_xor;
+
+	int checkpoint_blocks_required;	/* Number of blocks needed to store
+					 * current checkpoint set */
+
+	/* Block Info */
+	struct yaffs_block_info *block_info;
+	u8 *chunk_bits;		/* bitmap of chunks in use */
+	unsigned block_info_alt:1;	/* allocated using alternative alloc */
+	unsigned chunk_bits_alt:1;	/* allocated using alternative alloc */
+	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
+				 * Must be consistent with chunks_per_block.
+				 */
+
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int alloc_block_finder;	/* Used to search for next allocation block */
+
+	/* Object and Tnode memory management */
+	void *allocator;
+	int n_obj;
+	int n_tnodes;
+
+	int n_hardlinks;
+
+	struct yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
+	u32 bucket_finder;
+
+	int n_free_chunks;
+
+	/* Garbage collection control */
+	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
+	u32 n_clean_ups;
+
+	unsigned has_pending_prioritised_gc;	/* We think this device might
+						have pending prioritised gcs */
+	unsigned gc_disable;
+	unsigned gc_block_finder;
+	unsigned gc_dirtiest;
+	unsigned gc_pages_in_use;
+	unsigned gc_not_done;
+	unsigned gc_block;
+	unsigned gc_chunk;
+	unsigned gc_skip;
+	struct yaffs_summary_tags *gc_sum_tags;
+
+	/* Special directories */
+	struct yaffs_obj *root_dir;
+	struct yaffs_obj *lost_n_found;
+
+	int buffered_block;	/* Which block is buffered here? */
+	int doing_buffered_block_rewrite;
+
+	struct yaffs_cache *cache;
+	int cache_last_use;
+
+	/* Stuff for background deletion and unlinked files. */
+	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
+					 files live. */
+	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
+					sent to disappear. */
+	struct yaffs_obj *unlinked_deletion;	/* Current file being
+							background deleted. */
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* Temporary buffer management */
+	struct yaffs_buffer temp_buffer[YAFFS_N_TEMP_BUFFERS];
+	int max_temp;
+	int temp_in_use;
+	int unmanaged_buffer_allocs;
+	int unmanaged_buffer_deallocs;
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+					allocating block */
+	unsigned oldest_dirty_seq;
+	unsigned oldest_dirty_block;
+
+	/* Block refreshing */
+	int refresh_skip;	/* A skip down counter.
+				 * Refresh happens when this gets to zero. */
+
+	/* Dirty directory handling */
+	struct list_head dirty_dirs;	/* List of dirty directories */
+
+	/* Summary */
+	int chunks_per_summary;
+	struct yaffs_summary_tags *sum_tags;
+
+	/* Statistics */
+	u32 n_page_writes;
+	u32 n_page_reads;
+	u32 n_erasures;
+	u32 n_erase_failures;
+	u32 n_gc_copies;
+	u32 all_gcs;
+	u32 passive_gc_count;
+	u32 oldest_dirty_gc_count;
+	u32 n_gc_blocks;
+	u32 bg_gcs;
+	u32 n_retried_writes;
+	u32 n_retired_blocks;
+	u32 n_ecc_fixed;
+	u32 n_ecc_unfixed;
+	u32 n_tags_ecc_fixed;
+	u32 n_tags_ecc_unfixed;
+	u32 n_deletions;
+	u32 n_unmarked_deletions;
+	u32 refresh_count;
+	u32 cache_hits;
+	u32 tags_used;
+	u32 summary_used;
+
+};
+
+/* The CheckpointDevice structure holds the device information that changes
+ *at runtime and must be preserved over unmount/mount cycles.
+ */
+struct yaffs_checkpt_dev {
+	int struct_type;
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int n_free_chunks;
+
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+				 * allocating block */
+
+};
+
+struct yaffs_checkpt_validity {
+	int struct_type;
+	u32 magic;
+	u32 version;
+	u32 head;
+};
+
+struct yaffs_shadow_fixer {
+	int obj_id;
+	int shadowed_id;
+	struct yaffs_shadow_fixer *next;
+};
+
+/* Structure for doing xattr modifications */
+struct yaffs_xattr_mod {
+	int set;		/* If 0 then this is a deletion */
+	const YCHAR *name;
+	const void *data;
+	int size;
+	int flags;
+	int result;
+};
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_guts_initialise(struct yaffs_dev *dev);
+void yaffs_deinitialise(struct yaffs_dev *dev);
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
+		     struct yaffs_obj *new_dir, const YCHAR * new_name);
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name);
+int yaffs_del_obj(struct yaffs_obj *obj);
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj);
+int yaffs_get_obj_inode(struct yaffs_obj *obj);
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
+int yaffs_get_obj_link_count(struct yaffs_obj *obj);
+
+/* File operations */
+int yaffs_file_rd(struct yaffs_obj *obj, u8 * buffer, loff_t offset,
+		  int n_bytes);
+int yaffs_wr_file(struct yaffs_obj *obj, const u8 * buffer, loff_t offset,
+		  int n_bytes, int write_trhrough);
+int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid);
+
+int yaffs_flush_file(struct yaffs_obj *obj, int update_time, int data_sync);
+
+/* Flushing and checkpointing */
+void yaffs_flush_whole_cache(struct yaffs_dev *dev);
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev);
+int yaffs_checkpoint_restore(struct yaffs_dev *dev);
+
+/* Directory operations */
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid);
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
+				     const YCHAR *name);
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
+
+/* Link operations */
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
+				 struct yaffs_obj *equiv_obj);
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
+
+/* Symlink operations */
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias);
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev);
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
+		      const void *value, int size, int flags);
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
+		      int size);
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
+
+/* Special directories */
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev);
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj);
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev);
+
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency);
+
+/* Debug dump  */
+int yaffs_dump_obj(struct yaffs_obj *obj);
+
+void yaffs_guts_test(struct yaffs_dev *dev);
+
+/* A few useful functions to be used within the core files*/
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn);
+int yaffs_check_ff(u8 *buffer, int n_bytes);
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi);
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type);
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan);
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh);
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
+YCHAR *yaffs_clone_str(const YCHAR *str);
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
+		    int force, int is_shrink, int shadows,
+		    struct yaffs_xattr_mod *xop);
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning);
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks);
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev);
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn);
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_trhrough);
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id);
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos);
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out);
+/*
+ * Marshalling functions to get loff_t file sizes into aand out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize);
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh);
+loff_t yaffs_max_file_size(struct yaffs_dev *dev);
+
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_linux.h linux-3.1.5/fs/yaffs2/yaffs_linux.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_linux.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_linux.h	2012-10-25 16:28:38.745881512 -0600
@@ -0,0 +1,41 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_LINUX_H__
+#define __YAFFS_LINUX_H__
+
+#include "yportenv.h"
+
+struct yaffs_linux_context {
+	struct list_head context_list;	/* List of these we have mounted */
+	struct yaffs_dev *dev;
+	struct super_block *super;
+	struct task_struct *bg_thread;	/* Background thread for this device */
+	int bg_running;
+	struct mutex gross_lock;	/* Gross locking mutex*/
+	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
+				 * at compile time so we have to allocate it.
+				 */
+	struct list_head search_contexts;
+	void (*put_super_fn) (struct super_block *sb);
+
+	struct task_struct *readdir_process;
+	unsigned mount_id;
+};
+
+#define yaffs_dev_to_lc(dev) ((struct yaffs_linux_context *)((dev)->os_context))
+#define yaffs_dev_to_mtd(dev) ((struct mtd_info *)((dev)->driver_context))
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif1.c linux-3.1.5/fs/yaffs2/yaffs_mtdif1.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif1.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif1.c	2012-10-25 16:28:38.780881609 -0600
@@ -0,0 +1,364 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_tags compatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (use_nand_ecc is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_calc_tags_ecc */
+#include "yaffs_linux.h"
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * 9 byte tags and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * page_status byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need packed_tags1 plus page_status: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the page_status
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15},
+	.oobavail = 9,
+	.oobfree = {{0, 4}, {6, 2}, {11, 2}, {4, 1} }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to packed_tags1 form
+ *  - Compute mini-ECC for packed_tags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the packed_tags1 meta-data which does not include
+ * a full sequence number (as found in the larger packed_tags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev,
+			      int nand_chunk, const u8 *data,
+			      const struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+
+	/* we assume that packed_tags1 and struct yaffs_tags are compatible */
+	compile_time_assertion(sizeof(struct yaffs_packed_tags1) == 12);
+	compile_time_assertion(sizeof(struct yaffs_tags) == 8);
+
+	yaffs_pack_tags1(&pt1, etags);
+	yaffs_calc_tags_ecc((struct yaffs_tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with is_deleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+	if(dev->param.tags_9bytes) {
+        	((u8 *) &pt1)[8] = 0xff;
+        	if (etags->is_deleted) {
+		        memset(&pt1, 0xff, 8);
+        		/* zero page_status byte to indicate deleted */
+	        	((u8 *) &pt1)[8] = 0;
+                }
+        } else {
+        	if (etags->is_deleted) {
+	        	memset(&pt1, 0xff, 8);
+	        	/* clear delete status bit to indicate deleted */
+        		pt1.deleted = 0;
+                }
+	}
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (u8 *) &pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add ecc_result.
+ */
+static int rettags(struct yaffs_ext_tags *etags, int ecc_result, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->ecc_result = ecc_result;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except ecc_result and block_bad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the packed_tags1 mini-ECC (correct if necessary/possible)
+ *  - Convert packed_tags1 to ExtendedTags
+ *  - Update ecc_result and block_bad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev,
+			     int nand_chunk, u8 *data,
+			     struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = data;
+	ops.oobbuf = (u8 *) &pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->block_bad = (mtd->block_isbad) (mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_check_ff((u8 *) &pt1, 8)) {
+		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+
+	if(dev->param.tags_9bytes) {
+        	deleted = (hweight8(((u8 *) &pt1)[8]) < 7);
+        } else {
+        	/* Read deleted status (bit) then return it to it's non-deleted
+	         * state before performing tags mini-ECC check. pt1.deleted is
+        	 * inverted.
+	         */
+        	deleted = !pt1.deleted;
+        	pt1.deleted = 1;
+        }
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_check_tags_ecc((struct yaffs_tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->n_tags_ecc_fixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->n_tags_ecc_unfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set should_be_ff just to keep yaffs_unpack_tags1 happy]
+	 */
+	pt1.should_be_ff = 0xffffffff;
+	yaffs_unpack_tags1(etags, &pt1);
+	etags->ecc_result = eccres;
+
+	/* Set deleted state */
+	etags->is_deleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_test_prerequists(struct yaffs_dev *dev, struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < (dev->param.tags_9bytes ? 9 : 8)) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d",
+			oobavail, dev->param.tags_9bytes ? 9 : 8);
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCAN, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state_ptr, u32 * seq_ptr)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_num = block_no * dev->param.chunks_per_block;
+	loff_t addr = (loff_t) chunk_num * dev->data_bytes_per_chunk;
+	struct yaffs_ext_tags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_test_prerequists(dev, mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_read_chunk_tags(dev, chunk_num, NULL, &etags);
+	etags.block_bad = (mtd->block_isbad) (mtd, addr);
+	if (etags.block_bad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad",
+			block_no);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+	} else if (etags.chunk_used) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		seqnum = etags.seq_number;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*state_ptr = state;
+	*seq_ptr = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION */
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif1.h linux-3.1.5/fs/yaffs2/yaffs_mtdif1.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif1.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif1.h	2012-10-25 16:28:38.745881513 -0600
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF1_H__
+#define __YAFFS_MTDIF1_H__
+
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags);
+
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags);
+
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no);
+
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif2.c linux-3.1.5/fs/yaffs2/yaffs_mtdif2.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif2.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif2.c	2012-10-25 16:28:38.782881614 -0600
@@ -0,0 +1,268 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+#include "yaffs_linux.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size total_bytes_per_chunk so
+ * that we can also use it to load the tags.
+ */
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_write_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)(data +
+							dev->
+							data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+	ops.len = dev->param.total_bytes_per_chunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->param.inband_tags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				   &dummy, data, (u8 *) packed_tags_ptr, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->param.total_bytes_per_chunk,
+			       &dummy, data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int local_data = 0;
+
+	loff_t addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_read_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags) {
+
+		if (!data) {
+			local_data = 1;
+			data = yaffs_get_temp_buffer(dev);
+		}
+
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->param.inband_tags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+				   &dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OPS_AUTO_OOB;
+		ops.ooblen = packed_tags_size;
+		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = yaffs_dev_to_lc(dev)->spare_buffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->param.inband_tags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				       &dummy, data, dev->spare_buffer, NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->data_bytes_per_chunk,
+				      &dummy, data);
+		if (!dev->param.inband_tags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spare_buffer);
+	}
+#endif
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			struct yaffs_packed_tags2_tags_only *pt2tp;
+			pt2tp =
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2_tags_only(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(packed_tags_ptr,
+			       yaffs_dev_to_lc(dev)->spare_buffer,
+			       packed_tags_size);
+			yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+		}
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && retval == -EBADMSG
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+	if (tags && retval == -EUCLEAN
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_mark_block_bad %d",
+		block_no);
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       block_no * dev->param.chunks_per_block *
+			       dev->param.total_bytes_per_chunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "nandmtd2_query_block %d", block_no);
+	retval =
+	    mtd->block_isbad(mtd,
+			     block_no * dev->param.chunks_per_block *
+			     dev->param.total_bytes_per_chunk);
+
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+		nandmtd2_read_chunk_tags(dev, block_no *
+					 dev->param.chunks_per_block, NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block is bad seq %d state %d",
+		*seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif2.h linux-3.1.5/fs/yaffs2/yaffs_mtdif2.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif2.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif2.h	2012-10-25 16:28:38.745881513 -0600
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF2_H__
+#define __YAFFS_MTDIF2_H__
+
+#include "yaffs_guts.h"
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags);
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags);
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no);
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif.c linux-3.1.5/fs/yaffs2/yaffs_mtdif.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif.c	2012-10-25 16:28:38.714881427 -0600
@@ -0,0 +1,53 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+
+#include "yaffs_linux.h"
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	u32 addr =
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->param.total_bytes_per_chunk * dev->param.chunks_per_block;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd->erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+int nandmtd_initialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif.h linux-3.1.5/fs/yaffs2/yaffs_mtdif.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_mtdif.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_mtdif.h	2012-10-25 16:28:38.745881513 -0600
@@ -0,0 +1,23 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no);
+int nandmtd_initialise(struct yaffs_dev *dev);
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_nameval.c linux-3.1.5/fs/yaffs2/yaffs_nameval.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_nameval.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_nameval.c	2012-10-25 16:28:38.714881427 -0600
@@ -0,0 +1,208 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This simple implementation of a name-value store assumes a small number of
+* values and fits into a small finite buffer.
+ *
+ * Each attribute is stored as a record:
+ *  sizeof(int) bytes   record size.
+ *  strnlen+1 bytes name null terminated.
+ *  nbytes    value.
+ *  ----------
+ *  total size  stored in record size
+ *
+ * This code has not been tested with unicode yet.
+ */
+
+#include "yaffs_nameval.h"
+
+#include "yportenv.h"
+
+static int nval_find(const char *xb, int xb_size, const YCHAR *name,
+		     int *exist_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)),
+				name, size)) {
+			if (exist_size)
+				*exist_size = size;
+			return pos;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	if (exist_size)
+		*exist_size = 0;
+	return -ENODATA;
+}
+
+static int nval_used(const char *xb, int xb_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return pos;
+}
+
+int nval_del(char *xb, int xb_size, const YCHAR *name)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos < 0 || pos >= xb_size)
+		return -ENODATA;
+
+	/* Find size, shift rest over this record,
+	 * then zero out the rest of buffer */
+	memcpy(&size, xb + pos, sizeof(int));
+	memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
+	memset(xb + (xb_size - size), 0, size);
+	return 0;
+}
+
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
+		int bsize, int flags)
+{
+	int pos;
+	int namelen = strnlen(name, xb_size);
+	int reclen;
+	int size_exist = 0;
+	int space;
+	int start;
+
+	pos = nval_find(xb, xb_size, name, &size_exist);
+
+	if (flags & XATTR_CREATE && pos >= 0)
+		return -EEXIST;
+	if (flags & XATTR_REPLACE && pos < 0)
+		return -ENODATA;
+
+	start = nval_used(xb, xb_size);
+	space = xb_size - start + size_exist;
+
+	reclen = (sizeof(int) + namelen + 1 + bsize);
+
+	if (reclen > space)
+		return -ENOSPC;
+
+	if (pos >= 0) {
+		nval_del(xb, xb_size, name);
+		start = nval_used(xb, xb_size);
+	}
+
+	pos = start;
+
+	memcpy(xb + pos, &reclen, sizeof(int));
+	pos += sizeof(int);
+	strncpy((YCHAR *) (xb + pos), name, reclen);
+	pos += (namelen + 1);
+	memcpy(xb + pos, buf, bsize);
+	return 0;
+}
+
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos >= 0 && pos < xb_size) {
+
+		memcpy(&size, xb + pos, sizeof(int));
+		pos += sizeof(int);	/* advance past record length */
+		size -= sizeof(int);
+
+		/* Advance over name string */
+		while (xb[pos] && size > 0 && pos < xb_size) {
+			pos++;
+			size--;
+		}
+		/*Advance over NUL */
+		pos++;
+		size--;
+
+		/* If bsize is zero then this is a size query.
+		 * Return the size, but don't copy.
+		 */
+		if (!bsize)
+			return size;
+
+		if (size <= bsize) {
+			memcpy(buf, xb + pos, size);
+			return size;
+		}
+	}
+	if (pos >= 0)
+		return -ERANGE;
+
+	return -ENODATA;
+}
+
+int nval_list(const char *xb, int xb_size, char *buf, int bsize)
+{
+	int pos = 0;
+	int size;
+	int name_len;
+	int ncopied = 0;
+	int filled = 0;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > sizeof(int) &&
+		size <= xb_size &&
+		(pos + size) < xb_size &&
+		!filled) {
+		pos += sizeof(int);
+		size -= sizeof(int);
+		name_len = strnlen((YCHAR *) (xb + pos), size);
+		if (ncopied + name_len + 1 < bsize) {
+			memcpy(buf, xb + pos, name_len * sizeof(YCHAR));
+			buf += name_len;
+			*buf = '\0';
+			buf++;
+			if (sizeof(YCHAR) > 1) {
+				*buf = '\0';
+				buf++;
+			}
+			ncopied += (name_len + 1);
+		} else {
+			filled = 1;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return ncopied;
+}
+
+int nval_hasvalues(const char *xb, int xb_size)
+{
+	return nval_used(xb, xb_size) > 0;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_nameval.h linux-3.1.5/fs/yaffs2/yaffs_nameval.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_nameval.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_nameval.h	2012-10-25 16:28:38.746881516 -0600
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __NAMEVAL_H__
+#define __NAMEVAL_H__
+
+#include "yportenv.h"
+
+int nval_del(char *xb, int xb_size, const YCHAR * name);
+int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
+	     int bsize, int flags);
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize);
+int nval_list(const char *xb, int xb_size, char *buf, int bsize);
+int nval_hasvalues(const char *xb, int xb_size);
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_nand.c linux-3.1.5/fs/yaffs2/yaffs_nand.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_nand.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_nand.c	2012-10-25 16:28:38.715881430 -0600
@@ -0,0 +1,120 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+
+#include "yaffs_getblockinfo.h"
+#include "yaffs_summary.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	struct yaffs_ext_tags local_tags;
+	int flash_chunk = nand_chunk - dev->chunk_offset;
+
+	dev->n_page_reads++;
+
+	/* If there are no tags provided use local tags. */
+	if (!tags)
+		tags = &local_tags;
+
+	if (dev->param.read_chunk_tags_fn)
+		result =
+		    dev->param.read_chunk_tags_fn(dev, flash_chunk, buffer,
+						  tags);
+	else
+		result = yaffs_tags_compat_rd(dev,
+					      flash_chunk, buffer, tags);
+	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		struct yaffs_block_info *bi;
+		bi = yaffs_get_block_info(dev,
+					  nand_chunk /
+					  dev->param.chunks_per_block);
+		yaffs_handle_chunk_error(dev, bi);
+	}
+	return result;
+}
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+				int nand_chunk,
+				const u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	int flash_chunk = nand_chunk - dev->chunk_offset;
+
+	dev->n_page_writes++;
+
+	if (tags) {
+		tags->seq_number = dev->seq_number;
+		tags->chunk_used = 1;
+		yaffs_trace(YAFFS_TRACE_WRITE,
+			"Writing chunk %d tags %d %d",
+			nand_chunk, tags->obj_id, tags->chunk_id);
+	} else {
+		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (dev->param.write_chunk_tags_fn)
+		result = dev->param.write_chunk_tags_fn(dev, flash_chunk,
+							buffer, tags);
+	else
+		result = yaffs_tags_compat_wr(dev, flash_chunk, buffer, tags);
+
+	yaffs_summary_add(dev, tags, nand_chunk);
+
+	return result;
+}
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	block_no -= dev->block_offset;
+	if (dev->param.bad_block_fn)
+		return dev->param.bad_block_fn(dev, block_no);
+
+	return yaffs_tags_compat_mark_bad(dev, block_no);
+}
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 u32 *seq_number)
+{
+	block_no -= dev->block_offset;
+	if (dev->param.query_block_fn)
+		return dev->param.query_block_fn(dev, block_no, state,
+						 seq_number);
+
+	return yaffs_tags_compat_query_block(dev, block_no, state, seq_number);
+}
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block)
+{
+	int result;
+
+	flash_block -= dev->block_offset;
+	dev->n_erasures++;
+	result = dev->param.erase_fn(dev, flash_block);
+	return result;
+}
+
+int yaffs_init_nand(struct yaffs_dev *dev)
+{
+	if (dev->param.initialise_flash_fn)
+		return dev->param.initialise_flash_fn(dev);
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_nand.h linux-3.1.5/fs/yaffs2/yaffs_nand.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_nand.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_nand.h	2012-10-25 16:28:38.746881516 -0600
@@ -0,0 +1,38 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+			     int nand_chunk,
+			     const u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 unsigned *seq_number);
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block);
+
+int yaffs_init_nand(struct yaffs_dev *dev);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags1.c linux-3.1.5/fs/yaffs2/yaffs_packedtags1.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags1.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_packedtags1.c	2012-10-25 16:28:38.716881432 -0600
@@ -0,0 +1,56 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+static const u8 all_ff[20] = {
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t)
+{
+	pt->chunk_id = t->chunk_id;
+	pt->serial_number = t->serial_number;
+	pt->n_bytes = t->n_bytes;
+	pt->obj_id = t->obj_id;
+	pt->ecc = 0;
+	pt->deleted = (t->is_deleted) ? 0 : 1;
+	pt->unused_stuff = 0;
+	pt->should_be_ff = 0xffffffff;
+}
+
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt)
+{
+
+	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
+		t->block_bad = 0;
+		if (pt->should_be_ff != 0xffffffff)
+			t->block_bad = 1;
+		t->chunk_used = 1;
+		t->obj_id = pt->obj_id;
+		t->chunk_id = pt->chunk_id;
+		t->n_bytes = pt->n_bytes;
+		t->ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		t->is_deleted = (pt->deleted) ? 0 : 1;
+		t->serial_number = pt->serial_number;
+	} else {
+		memset(t, 0, sizeof(struct yaffs_ext_tags));
+	}
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags1.h linux-3.1.5/fs/yaffs2/yaffs_packedtags1.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags1.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_packedtags1.h	2012-10-25 16:28:38.747881518 -0600
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+struct yaffs_packed_tags1 {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unused_stuff:1;
+	unsigned should_be_ff;
+
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt);
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags2.c linux-3.1.5/fs/yaffs2/yaffs_packedtags2.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags2.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_packedtags2.c	2012-10-25 16:28:38.716881432 -0600
@@ -0,0 +1,197 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunk_id */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xf0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
+
+static void yaffs_dump_packed_tags2_tags_only(
+				const struct yaffs_packed_tags2_tags_only *ptt)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"packed tags obj %d chunk %d byte %d seq %d",
+		ptt->obj_id, ptt->chunk_id, ptt->n_bytes, ptt->seq_number);
+}
+
+static void yaffs_dump_packed_tags2(const struct yaffs_packed_tags2 *pt)
+{
+	yaffs_dump_packed_tags2_tags_only(&pt->t);
+}
+
+static void yaffs_dump_tags2(const struct yaffs_ext_tags *t)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d",
+		t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
+		t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
+		t->seq_number);
+
+}
+
+static int yaffs_check_tags_extra_packable(const struct yaffs_ext_tags *t)
+{
+	if (t->chunk_id != 0 || !t->extra_available)
+		return 0;
+
+	/* Check if the file size is too long to store */
+	if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE &&
+	    (t->extra_file_size >> 31) != 0)
+		return 0;
+	return 1;
+}
+
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
+				const struct yaffs_ext_tags *t)
+{
+	ptt->chunk_id = t->chunk_id;
+	ptt->seq_number = t->seq_number;
+	ptt->n_bytes = t->n_bytes;
+	ptt->obj_id = t->obj_id;
+
+	/* Only store extra tags for object headers.
+	 * If it is a file then only store  if the file size is short\
+	 * enough to fit.
+	 */
+	if (yaffs_check_tags_extra_packable(t)) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunk_id */
+		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
+		if (t->extra_is_shrink)
+			ptt->chunk_id |= EXTRA_SHRINK_FLAG;
+		if (t->extra_shadows)
+			ptt->chunk_id |= EXTRA_SHADOWS_FLAG;
+
+		ptt->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->obj_id |= (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->n_bytes = t->extra_equiv_id;
+		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+			ptt->n_bytes = (unsigned) t->extra_file_size;
+		else
+			ptt->n_bytes = 0;
+	}
+
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc)
+{
+	yaffs_pack_tags2_tags_only(&pt->t, t);
+
+	if (tags_ecc)
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				    sizeof(struct yaffs_packed_tags2_tags_only),
+				    &pt->ecc);
+}
+
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *ptt)
+{
+	memset(t, 0, sizeof(struct yaffs_ext_tags));
+
+	if (ptt->seq_number == 0xffffffff)
+		return;
+
+	t->block_bad = 0;
+	t->chunk_used = 1;
+	t->obj_id = ptt->obj_id;
+	t->chunk_id = ptt->chunk_id;
+	t->n_bytes = ptt->n_bytes;
+	t->is_deleted = 0;
+	t->serial_number = 0;
+	t->seq_number = ptt->seq_number;
+
+	/* Do extra header info stuff */
+	if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
+		t->chunk_id = 0;
+		t->n_bytes = 0;
+
+		t->extra_available = 1;
+		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
+		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
+		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+		t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			t->extra_equiv_id = ptt->n_bytes;
+		else
+			t->extra_file_size = ptt->n_bytes;
+	}
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc)
+{
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
+		/* Chunk is in use and we need to do ECC */
+
+		struct yaffs_ecc_other ecc;
+		int result;
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&ecc);
+		result =
+		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&pt->ecc, &ecc);
+		switch (result) {
+		case 0:
+			ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+			break;
+		case 1:
+			ecc_result = YAFFS_ECC_RESULT_FIXED;
+			break;
+		case -1:
+			ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			break;
+		default:
+			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+		}
+	}
+	yaffs_unpack_tags2_tags_only(t, &pt->t);
+
+	t->ecc_result = ecc_result;
+
+	yaffs_dump_packed_tags2(pt);
+	yaffs_dump_tags2(t);
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags2.h linux-3.1.5/fs/yaffs2/yaffs_packedtags2.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_packedtags2.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_packedtags2.h	2012-10-25 16:28:38.747881518 -0600
@@ -0,0 +1,47 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+struct yaffs_packed_tags2_tags_only {
+	unsigned seq_number;
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+struct yaffs_packed_tags2 {
+	struct yaffs_packed_tags2_tags_only t;
+	struct yaffs_ecc_other ecc;
+};
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc);
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *pt,
+				const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *pt);
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_summary.c linux-3.1.5/fs/yaffs2/yaffs_summary.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_summary.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_summary.c	2012-10-25 16:28:38.717881435 -0600
@@ -0,0 +1,313 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Summaries write the useful part of the tags for the chunks in a block into an
+ * an array which is written to the last n chunks of the block.
+ * Reading the summaries gives all the tags for the block in one read. Much
+ * faster.
+ *
+ * Chunks holding summaries are marked with tags making it look like
+ * they are part of a fake file.
+ *
+ * The summary could also be used during gc.
+ *
+ */
+
+#include "yaffs_summary.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_bitmap.h"
+
+/*
+ * The summary is built up in an array of summary tags.
+ * This gets written to the last one or two (maybe more) chunks in a block.
+ * A summary header is written as the first part of each chunk of summary data.
+ * The summary header must match or the summary is rejected.
+ */
+
+/* Summary tags don't need the sequence number because that is redundant. */
+struct yaffs_summary_tags {
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+/* Summary header */
+struct yaffs_summary_header {
+	unsigned version;	/* Must match current version */
+	unsigned block;		/* Must be this block */
+	unsigned seq;		/* Must be this sequence number */
+	unsigned sum;		/* Just add up all the bytes in the tags */
+};
+
+
+static void yaffs_summary_clear(struct yaffs_dev *dev)
+{
+	if (!dev->sum_tags)
+		return;
+	memset(dev->sum_tags, 0, dev->chunks_per_summary *
+		sizeof(struct yaffs_summary_tags));
+}
+
+
+void yaffs_summary_deinit(struct yaffs_dev *dev)
+{
+	kfree(dev->sum_tags);
+	dev->sum_tags = NULL;
+	kfree(dev->gc_sum_tags);
+	dev->gc_sum_tags = NULL;
+	dev->chunks_per_summary = 0;
+}
+
+int yaffs_summary_init(struct yaffs_dev *dev)
+{
+	int sum_bytes;
+	int chunks_used; /* Number of chunks used by summary */
+	int sum_tags_bytes;
+
+	sum_bytes = dev->param.chunks_per_block *
+			sizeof(struct yaffs_summary_tags);
+
+	chunks_used = (sum_bytes + dev->data_bytes_per_chunk - 1)/
+			(dev->data_bytes_per_chunk -
+				sizeof(struct yaffs_summary_header));
+
+	dev->chunks_per_summary = dev->param.chunks_per_block - chunks_used;
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	dev->sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	dev->gc_sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	if (!dev->sum_tags || !dev->gc_sum_tags) {
+		yaffs_summary_deinit(dev);
+		return YAFFS_FAIL;
+	}
+
+	yaffs_summary_clear(dev);
+
+	return YAFFS_OK;
+}
+
+static unsigned yaffs_summary_sum(struct yaffs_dev *dev)
+{
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int i;
+	unsigned sum = 0;
+
+	i = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	while (i > 0) {
+		sum += *sum_buffer;
+		sum_buffer++;
+		i--;
+	}
+
+	return sum;
+}
+
+static int yaffs_summary_write(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int n_bytes;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	memset(&tags, 0, sizeof(struct yaffs_ext_tags));
+	tags.obj_id = YAFFS_OBJECTID_SUMMARY;
+	tags.chunk_id = 1;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = dev->alloc_block * dev->param.chunks_per_block +
+						dev->chunks_per_summary;
+	hdr.version = YAFFS_SUMMARY_VERSION;
+	hdr.block = blk;
+	hdr.seq = bi->seq_number;
+	hdr.sum = yaffs_summary_sum(dev);
+
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		memcpy(buffer, &hdr, sizeof(hdr));
+		memcpy(buffer + sizeof(hdr), sum_buffer, this_tx);
+		tags.n_bytes = this_tx + sizeof(hdr);
+		result = yaffs_wr_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (result != YAFFS_OK)
+			break;
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+		dev->n_free_chunks--;
+
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		tags.chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+
+	if (result == YAFFS_OK)
+		bi->has_summary = 1;
+
+
+	return result;
+}
+
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)st;
+	int n_bytes;
+	int chunk_id;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	int sum_tags_bytes;
+
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) * dev->chunks_per_summary;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = blk * dev->param.chunks_per_block +
+							dev->chunks_per_summary;
+	chunk_id = 1;
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		result = yaffs_rd_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (tags.chunk_id != chunk_id ||
+			tags.obj_id != YAFFS_OBJECTID_SUMMARY ||
+			tags.chunk_used == 0 ||
+			tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			tags.n_bytes != (this_tx + sizeof(hdr)))
+				result = YAFFS_FAIL;
+		if (result != YAFFS_OK)
+			break;
+
+		if (st == dev->sum_tags) {
+			/* If we're scanning then update the block info */
+			yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+			bi->pages_in_use++;
+		}
+		memcpy(&hdr, buffer, sizeof(hdr));
+		memcpy(sum_buffer, buffer + sizeof(hdr), this_tx);
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+	if (result == YAFFS_OK) {
+		/* Verify header */
+		if (hdr.version != YAFFS_SUMMARY_VERSION ||
+		    hdr.block != blk ||
+		    hdr.seq != bi->seq_number ||
+		    hdr.sum != yaffs_summary_sum(dev))
+			result = YAFFS_FAIL;
+	}
+
+	if (st == dev->sum_tags && result == YAFFS_OK)
+		bi->has_summary = 1;
+
+	return result;
+}
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_nand)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	int block_in_nand = chunk_in_nand / dev->param.chunks_per_block;
+	int chunk_in_block = chunk_in_nand % dev->param.chunks_per_block;
+
+	if (!dev->sum_tags)
+		return YAFFS_OK;
+
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		yaffs_pack_tags2_tags_only(&tags_only, tags);
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		sum_tags->chunk_id = tags_only.chunk_id;
+		sum_tags->n_bytes = tags_only.n_bytes;
+		sum_tags->obj_id = tags_only.obj_id;
+
+		if (chunk_in_block == dev->chunks_per_summary - 1) {
+			/* Time to write out the summary */
+			yaffs_summary_write(dev, block_in_nand);
+			yaffs_summary_clear(dev);
+			yaffs_skip_rest_of_block(dev);
+		}
+	}
+	return YAFFS_OK;
+}
+
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		tags_only.chunk_id = sum_tags->chunk_id;
+		tags_only.n_bytes = sum_tags->n_bytes;
+		tags_only.obj_id = sum_tags->obj_id;
+		yaffs_unpack_tags2_tags_only(tags, &tags_only);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int i;
+
+	if (!bi->has_summary)
+		return;
+
+	for (i = dev->chunks_per_summary;
+	     i < dev->param.chunks_per_block;
+	     i++) {
+		if (yaffs_check_chunk_bit(dev, blk, i)) {
+			yaffs_clear_chunk_bit(dev, blk, i);
+			bi->pages_in_use--;
+			dev->n_free_chunks++;
+		}
+	}
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_summary.h linux-3.1.5/fs/yaffs2/yaffs_summary.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_summary.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_summary.h	2012-10-25 16:28:38.747881518 -0600
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_SUMMARY_H__
+#define __YAFFS_SUMMARY_H__
+
+#include "yaffs_packedtags2.h"
+
+
+int yaffs_summary_init(struct yaffs_dev *dev);
+void yaffs_summary_deinit(struct yaffs_dev *dev);
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk);
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk);
+
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_tagscompat.c linux-3.1.5/fs/yaffs2/yaffs_tagscompat.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_tagscompat.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_tagscompat.c	2012-10-25 16:28:38.718881438 -0600
@@ -0,0 +1,407 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_trace.h"
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk);
+
+
+/********** Tags ECC calculations  *********/
+
+static void yaffs_calc_ecc(const u8 *data, struct yaffs_spare *spare)
+{
+	yaffs_ecc_calc(data, spare->ecc1);
+	yaffs_ecc_calc(&data[256], spare->ecc2);
+}
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
+{
+	/* Calculate an ecc */
+	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+	tags->ecc = ecc;
+}
+
+int yaffs_check_tags_ecc(struct yaffs_tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_calc_tags_ecc(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_calc_tags_ecc(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
+				     struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+
+	yaffs_calc_tags_ecc(tags_ptr);
+
+	spare_ptr->tb0 = tu->as_bytes[0];
+	spare_ptr->tb1 = tu->as_bytes[1];
+	spare_ptr->tb2 = tu->as_bytes[2];
+	spare_ptr->tb3 = tu->as_bytes[3];
+	spare_ptr->tb4 = tu->as_bytes[4];
+	spare_ptr->tb5 = tu->as_bytes[5];
+	spare_ptr->tb6 = tu->as_bytes[6];
+	spare_ptr->tb7 = tu->as_bytes[7];
+}
+
+static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
+				      struct yaffs_spare *spare_ptr,
+				      struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	int result;
+
+	tu->as_bytes[0] = spare_ptr->tb0;
+	tu->as_bytes[1] = spare_ptr->tb1;
+	tu->as_bytes[2] = spare_ptr->tb2;
+	tu->as_bytes[3] = spare_ptr->tb3;
+	tu->as_bytes[4] = spare_ptr->tb4;
+	tu->as_bytes[5] = spare_ptr->tb5;
+	tu->as_bytes[6] = spare_ptr->tb6;
+	tu->as_bytes[7] = spare_ptr->tb7;
+
+	result = yaffs_check_tags_ecc(tags_ptr);
+	if (result > 0)
+		dev->n_tags_ecc_fixed++;
+	else if (result < 0)
+		dev->n_tags_ecc_unfixed++;
+}
+
+static void yaffs_spare_init(struct yaffs_spare *spare)
+{
+	memset(spare, 0xff, sizeof(struct yaffs_spare));
+}
+
+static int yaffs_wr_nand(struct yaffs_dev *dev,
+			 int nand_chunk, const u8 *data,
+			 struct yaffs_spare *spare)
+{
+	if (nand_chunk < dev->param.start_block * dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs chunk %d is not valid",
+			nand_chunk);
+		return YAFFS_FAIL;
+	}
+
+	return dev->param.write_chunk_fn(dev, nand_chunk, data, spare);
+}
+
+static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
+			       int nand_chunk,
+			       u8 *data,
+			       struct yaffs_spare *spare,
+			       enum yaffs_ecc_result *ecc_result,
+			       int correct_errors)
+{
+	int ret_val;
+	struct yaffs_spare local_spare;
+
+	if (!spare) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &local_spare;
+	}
+
+	if (!dev->param.use_nand_ecc) {
+		ret_val =
+		    dev->param.read_chunk_fn(dev, nand_chunk, data, spare);
+		if (data && correct_errors) {
+			/* Do ECC correction */
+			/* Todo handle any errors */
+			int ecc_result1, ecc_result2;
+			u8 calc_ecc[3];
+
+			yaffs_ecc_calc(data, calc_ecc);
+			ecc_result1 =
+			    yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
+			yaffs_ecc_calc(&data[256], calc_ecc);
+			ecc_result2 =
+			    yaffs_ecc_correct(&data[256], spare->ecc2,
+					      calc_ecc);
+
+			if (ecc_result1 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error fix performed on chunk %d:0",
+					nand_chunk);
+				dev->n_ecc_fixed++;
+			} else if (ecc_result1 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error unfixed on chunk %d:0",
+					nand_chunk);
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result2 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error fix performed on chunk %d:1",
+					nand_chunk);
+				dev->n_ecc_fixed++;
+			} else if (ecc_result2 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error unfixed on chunk %d:1",
+					nand_chunk);
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result1 || ecc_result2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (ecc_result1 < 0 || ecc_result2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (ecc_result1 > 0 || ecc_result2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		}
+	} else {
+		/* Must allocate enough memory for spare+2*sizeof(int) */
+		/* for ecc results from device. */
+		struct yaffs_nand_spare nspare;
+
+		memset(&nspare, 0, sizeof(nspare));
+
+		ret_val = dev->param.read_chunk_fn(dev, nand_chunk, data,
+						   (struct yaffs_spare *)
+						   &nspare);
+		memcpy(spare, &nspare, sizeof(struct yaffs_spare));
+		if (data && correct_errors) {
+			if (nspare.eccres1 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error fix performed on chunk %d:0",
+					nand_chunk);
+			} else if (nspare.eccres1 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error unfixed on chunk %d:0",
+					nand_chunk);
+			}
+
+			if (nspare.eccres2 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error fix performed on chunk %d:1",
+					nand_chunk);
+			} else if (nspare.eccres2 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error unfixed on chunk %d:1",
+					nand_chunk);
+			}
+
+			if (nspare.eccres1 || nspare.eccres2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+		}
+	}
+	return ret_val;
+}
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+
+	/* Mark the block for retirement */
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
+		needs_retiring = 1;
+	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		"**>>Block %d marked for retirement",
+		flash_block);
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+
+	yaffs_spare_init(&spare);
+
+	if (ext_tags->is_deleted)
+		spare.page_status = 0;
+	else {
+		tags.obj_id = ext_tags->obj_id;
+		tags.chunk_id = ext_tags->chunk_id;
+
+		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
+		else
+			tags.n_bytes_msb = 3;
+
+		tags.serial_number = ext_tags->serial_number;
+
+		if (!dev->param.use_nand_ecc && data)
+			yaffs_calc_ecc(data, &spare);
+
+		yaffs_load_tags_to_spare(&spare, &tags);
+	}
+	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
+}
+
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	int deleted;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
+					data, &spare, &ecc_result, 1))
+		return YAFFS_FAIL;
+
+	/* ext_tags may be NULL */
+	if (!ext_tags)
+		return YAFFS_OK;
+
+	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
+
+	ext_tags->is_deleted = deleted;
+	ext_tags->ecc_result = ecc_result;
+	ext_tags->block_bad = 0;	/* We're reading it */
+	/* therefore it is not a bad block */
+	ext_tags->chunk_used =
+		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
+
+	if (ext_tags->chunk_used) {
+		yaffs_get_tags_from_spare(dev, &spare, &tags);
+		ext_tags->obj_id = tags.obj_id;
+		ext_tags->chunk_id = tags.chunk_id;
+		ext_tags->n_bytes = tags.n_bytes_lsb;
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			ext_tags->n_bytes |=
+				(((unsigned)tags.n_bytes_msb) << 10);
+
+		ext_tags->serial_number = tags.serial_number;
+	}
+
+	return YAFFS_OK;
+}
+
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_spare spare;
+
+	memset(&spare, 0xff, sizeof(struct yaffs_spare));
+
+	spare.block_status = 'Y';
+
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
+		      &spare);
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
+		      NULL, &spare);
+
+	return YAFFS_OK;
+}
+
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number)
+{
+	struct yaffs_spare spare0, spare1;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	enum yaffs_ecc_result dummy;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	*seq_number = 0;
+
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block, NULL,
+			    &spare0, &dummy, 1);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
+			    NULL, &spare1, &dummy, 1);
+
+	if (hweight8(spare0.block_status & spare1.block_status) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_tagscompat.h linux-3.1.5/fs/yaffs2/yaffs_tagscompat.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_tagscompat.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_tagscompat.h	2012-10-25 16:28:38.748881520 -0600
@@ -0,0 +1,36 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+#include "yaffs_guts.h"
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number);
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
+int yaffs_check_tags_ecc(struct yaffs_tags *tags);
+int yaffs_count_bits(u8 byte);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_trace.h linux-3.1.5/fs/yaffs2/yaffs_trace.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_trace.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_trace.h	2012-10-25 16:28:38.748881520 -0600
@@ -0,0 +1,57 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YTRACE_H__
+#define __YTRACE_H__
+
+extern unsigned int yaffs_trace_mask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
+
+#define YAFFS_TRACE_SYNC		0x00100000
+#define YAFFS_TRACE_BACKGROUND		0x00200000
+#define YAFFS_TRACE_LOCK		0x00400000
+#define YAFFS_TRACE_MOUNT		0x00800000
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xf0000000
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_verify.c linux-3.1.5/fs/yaffs2/yaffs_verify.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_verify.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_verify.c	2012-10-25 16:28:38.723881450 -0600
@@ -0,0 +1,529 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_verify.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+
+int yaffs_skip_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask &
+		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_full_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char * const block_state_name[] = {
+	"Unknown",
+	"Needs scan",
+	"Scanning",
+	"Empty",
+	"Allocating",
+	"Full",
+	"Dirty",
+	"Checkpoint",
+	"Collecting",
+	"Dead"
+};
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi, int n)
+{
+	int actually_used;
+	int in_use;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->block_state >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has undefined state %d",
+			n, bi->block_state);
+
+	switch (bi->block_state) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has bad run-state %s",
+			n, block_state_name[bi->block_state]);
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actually_used = bi->pages_in_use - bi->soft_del_pages;
+
+	if (bi->pages_in_use < 0 ||
+	    bi->pages_in_use > dev->param.chunks_per_block ||
+	    bi->soft_del_pages < 0 ||
+	    bi->soft_del_pages > dev->param.chunks_per_block ||
+	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
+			n, bi->pages_in_use, bi->soft_del_pages);
+
+	/* Check chunk bitmap legal */
+	in_use = yaffs_count_chunk_bits(dev, n);
+	if (in_use != bi->pages_in_use)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
+			n, bi->pages_in_use, in_use);
+}
+
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n)
+{
+	yaffs_verify_blk(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+
+	if (bi->block_state != YAFFS_BLOCK_STATE_COLLECTING &&
+	    bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Block %d is in state %d after gc, should be erased",
+			n, bi->block_state);
+	}
+}
+
+void yaffs_verify_blocks(struct yaffs_dev *dev)
+{
+	int i;
+	int state_count[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int illegal_states = 0;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	memset(state_count, 0, sizeof(state_count));
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		yaffs_verify_blk(dev, bi, i);
+
+		if (bi->block_state < YAFFS_NUMBER_OF_BLOCK_STATES)
+			state_count[bi->block_state]++;
+		else
+			illegal_states++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,	"Block summary");
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,
+		"%d blocks have illegal states",
+		illegal_states);
+	if (state_count[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many allocating blocks");
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"%s %d blocks",
+			block_state_name[i], state_count[i]);
+
+	if (dev->blocks_in_checkpt != state_count[YAFFS_BLOCK_STATE_CHECKPOINT])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Checkpoint block count wrong dev %d count %d",
+			dev->blocks_in_checkpt,
+			state_count[YAFFS_BLOCK_STATE_CHECKPOINT]);
+
+	if (dev->n_erased_blocks != state_count[YAFFS_BLOCK_STATE_EMPTY])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Erased block count wrong dev %d count %d",
+			dev->n_erased_blocks,
+			state_count[YAFFS_BLOCK_STATE_EMPTY]);
+
+	if (state_count[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many collecting blocks %d (max is 1)",
+			state_count[YAFFS_BLOCK_STATE_COLLECTING]);
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in
+ * which case those tests will not be performed.
+ */
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Verifying object header tags %p obj %p oh %p",
+			tags, obj, oh);
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+	    oh->type > YAFFS_OBJECT_TYPE_MAX)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header type is illegal value 0x%x",
+			tags->obj_id, oh->type);
+
+	if (tags->obj_id != obj->obj_id)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch obj_id %d",
+			tags->obj_id, obj->obj_id);
+
+	/*
+	 * Check that the object's parent ids match if parent_check requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parent_check && tags->obj_id > 1 && !obj->parent)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d obj->parent is NULL",
+			tags->obj_id, oh->parent_obj_id);
+
+	if (parent_check && obj->parent &&
+	    oh->parent_obj_id != obj->parent->obj_id &&
+	    (oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
+	     obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d parent_obj_id %d",
+			tags->obj_id, oh->parent_obj_id,
+			obj->parent->obj_id);
+
+	if (tags->obj_id > 1 && oh->name[0] == 0)	/* Null name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is NULL",
+			obj->obj_id);
+
+	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is 0xff",
+			obj->obj_id);
+}
+
+void yaffs_verify_file(struct yaffs_obj *obj)
+{
+	u32 x;
+	int required_depth;
+	int actual_depth;
+	int last_chunk;
+	u32 offset_in_chunk;
+	u32 the_chunk;
+
+	u32 i;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	struct yaffs_tnode *tn;
+	u32 obj_id;
+
+	if (!obj)
+		return;
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	dev = obj->my_dev;
+	obj_id = obj->obj_id;
+
+
+	/* Check file size is consistent with tnode depth */
+	yaffs_addr_to_chunk(dev, obj->variant.file_variant.file_size,
+				&last_chunk, &offset_in_chunk);
+	last_chunk++;
+	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	actual_depth = obj->variant.file_variant.top_level;
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_skip_nand_verification(dev))
+		return;
+
+	for (i = 1; i <= last_chunk; i++) {
+		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
+
+		if (!tn)
+			continue;
+
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk > 0) {
+			yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+						 &tags);
+			if (tags.obj_id != obj_id || tags.chunk_id != i)
+				yaffs_trace(YAFFS_TRACE_VERIFY,
+					"Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)",
+					obj_id, i, the_chunk,
+					tags.obj_id, tags.chunk_id);
+		}
+	}
+}
+
+void yaffs_verify_link(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+void yaffs_verify_symlink(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify symlink string */
+}
+
+void yaffs_verify_special(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+}
+
+void yaffs_verify_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+	u32 chunk_min;
+	u32 chunk_max;
+	u32 chunk_id_ok;
+	u32 chunk_in_range;
+	u32 chunk_wrongly_deleted;
+	u32 chunk_valid;
+
+	if (!obj)
+		return;
+
+	if (obj->being_created)
+		return;
+
+	dev = obj->my_dev;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunk_min = dev->internal_start_block * dev->param.chunks_per_block;
+	chunk_max =
+	    (dev->internal_end_block + 1) * dev->param.chunks_per_block - 1;
+
+	chunk_in_range = (((unsigned)(obj->hdr_chunk)) >= chunk_min &&
+			  ((unsigned)(obj->hdr_chunk)) <= chunk_max);
+	chunk_id_ok = chunk_in_range || (obj->hdr_chunk == 0);
+	chunk_valid = chunk_in_range &&
+	    yaffs_check_chunk_bit(dev,
+				  obj->hdr_chunk / dev->param.chunks_per_block,
+				  obj->hdr_chunk % dev->param.chunks_per_block);
+	chunk_wrongly_deleted = chunk_in_range && !chunk_valid;
+
+	if (!obj->fake && (!chunk_id_ok || chunk_wrongly_deleted))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has chunk_id %d %s %s",
+			obj->obj_id, obj->hdr_chunk,
+			chunk_id_ok ? "" : ",out of range",
+			chunk_wrongly_deleted ? ",marked as deleted" : "");
+
+	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
+		struct yaffs_ext_tags tags;
+		struct yaffs_obj_hdr *oh;
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		oh = (struct yaffs_obj_hdr *)buffer;
+
+		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer, &tags);
+
+		yaffs_verify_oh(obj, oh, &tags, 1);
+
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake && (!obj->parent || obj->parent->my_dev != dev)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has parent pointer %p which does not look like an object",
+			obj->obj_id, obj->parent);
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent &&
+	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d's parent is not a directory (type %d)",
+			obj->obj_id, obj->parent->variant_type);
+	}
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_verify_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_verify_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_verify_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_verify_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_verify_special(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has illegaltype %d",
+		   obj->obj_id, obj->variant_type);
+		break;
+	}
+}
+
+void yaffs_verify_objects(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int i;
+	struct list_head *lh;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			yaffs_verify_obj(obj);
+		}
+	}
+}
+
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+	int count = 0;
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!obj->parent) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
+		BUG();
+		return;
+	}
+
+	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		yaffs_verify_obj(list_obj);
+		if (obj == list_obj)
+			count++;
+	}
+
+	if (count != 1) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Object in directory %d times",
+			count);
+		BUG();
+	}
+}
+
+void yaffs_verify_dir(struct yaffs_obj *directory)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+
+	if (!directory) {
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_full_verification(directory->my_dev))
+		return;
+
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Directory has wrong type: %d",
+			directory->variant_type);
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &directory->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (list_obj->parent != directory) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Object in directory list has wrong parent %p",
+				list_obj->parent);
+			BUG();
+		}
+		yaffs_verify_obj_in_dir(list_obj);
+	}
+}
+
+static int yaffs_free_verification_failures;
+
+void yaffs_verify_free_chunks(struct yaffs_dev *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	counted = yaffs_count_free_chunks(dev);
+
+	difference = dev->n_free_chunks - counted;
+
+	if (difference) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Freechunks verification failure %d %d %d",
+			dev->n_free_chunks, counted, difference);
+		yaffs_free_verification_failures++;
+	}
+}
+
+int yaffs_verify_file_sane(struct yaffs_obj *in)
+{
+	(void) in;
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_verify.h linux-3.1.5/fs/yaffs2/yaffs_verify.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_verify.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_verify.h	2012-10-25 16:28:38.757881545 -0600
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_VERIFY_H__
+#define __YAFFS_VERIFY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi,
+		      int n);
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n);
+void yaffs_verify_blocks(struct yaffs_dev *dev);
+
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check);
+void yaffs_verify_file(struct yaffs_obj *obj);
+void yaffs_verify_link(struct yaffs_obj *obj);
+void yaffs_verify_symlink(struct yaffs_obj *obj);
+void yaffs_verify_special(struct yaffs_obj *obj);
+void yaffs_verify_obj(struct yaffs_obj *obj);
+void yaffs_verify_objects(struct yaffs_dev *dev);
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj);
+void yaffs_verify_dir(struct yaffs_obj *directory);
+void yaffs_verify_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_verify_file_sane(struct yaffs_obj *obj);
+
+int yaffs_skip_verification(struct yaffs_dev *dev);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_vfs.c linux-3.1.5/fs/yaffs2/yaffs_vfs.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_vfs.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_vfs.c	2012-10-25 16:28:38.777881601 -0600
@@ -0,0 +1,3464 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync);
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync);
+#endif
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+#ifdef YAFFS_HAS_EVICT_INODE
+static void yaffs_evict_inode(struct inode *);
+#else
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+#endif
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags);
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size);
+static int yaffs_removexattr(struct dentry *dentry, const char *name);
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size);
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen);
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias);
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static void yaffs_touch_super(struct yaffs_dev *dev);
+
+static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	if (inode && obj) {
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
+
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_inode_to_obj_lv(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
+{
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super %s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	if (yaffs_dev_to_lc(dev)->put_super_fn)
+		yaffs_dev_to_lc(dev)->put_super_fn(sb);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+static void yaffs_mtd_put_super(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_super_to_dev(sb));
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+	int disable_summary;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+
+	int read_only = 0;
+
+	struct yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
+	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
+	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
+	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
+	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		if (dev)
+			kfree(dev);
+		if (context)
+			kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	n_blocks =
+	    YCALCBLOCKS(mtd->size,
+			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+	param->refresh_period = 500;
+	param->disable_summary = options.disable_summary;
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
+		param->bad_block_fn = nandmtd2_mark_block_bad;
+		param->query_block_fn = nandmtd2_query_block;
+		yaffs_dev_to_lc(dev)->spare_buffer =
+				kmalloc(mtd->oobsize, GFP_NOFS);
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
+		param->bad_block_fn = nandmtd1_mark_block_bad;
+		param->query_block_fn = nandmtd1_query_block;
+#else
+		param->write_chunk_fn = nandmtd_write_chunk;
+		param->read_chunk_fn = nandmtd_read_chunk;
+#endif
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_erase_block;
+	param->initialise_flash_fn = nandmtd_initialise;
+
+	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+	param->use_nand_ecc = 1;
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = d_alloc_root(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
+        .get_sb = yaffs_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
+        .get_sb = yaffs2_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+                        }
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *data)
+{
+	return yaffs_proc_write_trace_options(file, buf, count, data);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+        }
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+    module_exit(exit_yaffs_fs)
+
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs1.c linux-3.1.5/fs/yaffs2/yaffs_yaffs1.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs1.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_yaffs1.c	2012-10-25 16:28:38.741881503 -0600
@@ -0,0 +1,422 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_yaffs1.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+#include "yaffs_attribs.h"
+
+int yaffs1_scan(struct yaffs_dev *dev)
+{
+	struct yaffs_ext_tags tags;
+	int blk;
+	int result;
+	int chunk;
+	int c;
+	int deleted;
+	enum yaffs_block_state state;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int alloc_failed = 0;
+	struct yaffs_shadow_fixer *shadow_fixers = NULL;
+	u8 *chunk_data;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs1_scan starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, state, seq_number);
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		}
+		bi++;
+	}
+
+	/* For each block.... */
+	for (blk = dev->internal_start_block;
+	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
+
+		cond_resched();
+
+		bi = yaffs_get_block_info(dev, blk);
+		state = bi->block_state;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		for (c = 0;
+			!alloc_failed && c < dev->param.chunks_per_block &&
+			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->param.chunks_per_block + c;
+
+			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
+							  &tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
+			    tags.is_deleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->n_free_chunks++;
+			} else if (!tags.chunk_used) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in
+					 *the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->n_erased_blocks++;
+				} else {
+					/* this is the block being allocated */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						" Allocating from %d %d",
+						blk, c);
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = c;
+					dev->alloc_block_finder = blk;
+
+				}
+
+				dev->n_free_chunks +=
+				    (dev->param.chunks_per_block - c);
+			} else if (tags.chunk_id > 0) {
+				/* chunk_id > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id,
+							YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash
+				 * (two data chunks with the same chunk_id).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_put_chunk_in_file
+					    (in, tags.chunk_id, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunk_id - 1) *
+				    dev->data_bytes_per_chunk +
+				    tags.n_bytes;
+				if (in &&
+				    in->variant_type ==
+				     YAFFS_OBJECT_TYPE_FILE &&
+				    in->variant.file_variant.scanned_size <
+				      endpos) {
+					in->variant.file_variant.scanned_size =
+					    endpos;
+					if (!dev->param.use_header_file_size) {
+						in->variant.
+						    file_variant.file_size =
+						    in->variant.
+						    file_variant.scanned_size;
+					}
+
+				}
+			} else {
+				/* chunk_id == 0, so it is an ObjectHeader.
+				 * Make the object
+				 */
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				result = yaffs_rd_chunk_tags_nand(dev, chunk,
+								  chunk_data,
+								  NULL);
+
+				oh = (struct yaffs_obj_hdr *)chunk_data;
+
+				in = yaffs_find_by_number(dev, tags.obj_id);
+				if (in && in->variant_type != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an obj_id that
+					 * has been reused but not yet deleted,
+					 * and worse still it has changed type.
+					 * Delete the old object.
+					 */
+
+					yaffs_del_obj(in);
+					in = NULL;
+				}
+
+				in = yaffs_find_or_create_by_number(dev,
+								tags.obj_id,
+								oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadows_obj > 0) {
+
+					struct yaffs_shadow_fixer *fixer;
+					fixer =
+						kmalloc(sizeof
+						(struct yaffs_shadow_fixer),
+						GFP_NOFS);
+					if (fixer) {
+						fixer->next = shadow_fixers;
+						shadow_fixers = fixer;
+						fixer->obj_id = tags.obj_id;
+						fixer->shadowed_id =
+						    oh->shadows_obj;
+						yaffs_trace(YAFFS_TRACE_SCAN,
+							" Shadow fixer: %d shadows %d",
+							fixer->obj_id,
+							fixer->shadowed_id);
+
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate and need to
+					 * resolve it. */
+
+					unsigned existing_serial = in->serial;
+					unsigned new_serial =
+					    tags.serial_number;
+
+					if (((existing_serial + 1) & 3) ==
+					    new_serial) {
+						/* Use new one - destroy the
+						 * exisiting one */
+						yaffs_chunk_del(dev,
+								in->hdr_chunk,
+								1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy
+						 * this one. */
+						yaffs_chunk_del(dev, chunk, 1,
+								__LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle
+					 * with directory structure */
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+					yaffs_set_obj_name_from_oh(in, oh);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_find_or_create_by_number
+					    (dev, oh->parent_obj_id,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variant_type ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variant_type =
+						    YAFFS_OBJECT_TYPE_DIRECTORY;
+						INIT_LIST_HEAD(&parent->
+							variant.dir_variant.
+							children);
+					} else if (!parent ||
+						parent->variant_type !=
+						YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, a problem....
+						 * We're trying to use a
+						 * non-directory as a directory
+						 */
+
+						yaffs_trace(YAFFS_TRACE_ERROR,
+							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+							);
+						parent = dev->lost_n_found;
+					}
+
+					yaffs_add_obj_to_dir(parent, in);
+
+					switch (in->variant_type) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->param.
+						    use_header_file_size)
+							in->variant.
+							file_variant.file_size
+							= yaffs_oh_to_size(oh);
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.
+						    hardlink_variant.equiv_id =
+						    oh->equiv_id;
+						list_add(&in->hard_links,
+								&hard_list);
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symlink_variant.
+						    alias =
+						    yaffs_clone_str(oh->alias);
+						if (!in->variant.
+						    symlink_variant.alias)
+							alloc_failed = 1;
+						break;
+					}
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning,
+			 * then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			/* If the block was partially allocated then
+			 * treat it as fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		bi->block_state = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
+			yaffs_block_became_dirty(dev, blk);
+	}
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add
+	 * these hardlinks.
+	 */
+
+	yaffs_link_fixup(dev, &hard_list);
+
+	/*
+	 * Fix up any shadowed objects.
+	 * There should not be more than one of these.
+	 */
+	{
+		struct yaffs_shadow_fixer *fixer;
+		struct yaffs_obj *obj;
+
+		while (shadow_fixers) {
+			fixer = shadow_fixers;
+			shadow_fixers = fixer->next;
+			/* Complete the rename transaction by deleting the
+			 * shadowed object then setting the object header
+			 to unshadowed.
+			 */
+			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
+			if (obj)
+				yaffs_del_obj(obj);
+
+			obj = yaffs_find_by_number(dev, fixer->obj_id);
+
+			if (obj)
+				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+			kfree(fixer);
+		}
+	}
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
+
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs1.h linux-3.1.5/fs/yaffs2/yaffs_yaffs1.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs1.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_yaffs1.h	2012-10-25 16:28:38.757881545 -0600
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS1_H__
+#define __YAFFS_YAFFS1_H__
+
+#include "yaffs_guts.h"
+int yaffs1_scan(struct yaffs_dev *dev);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs2.c linux-3.1.5/fs/yaffs2/yaffs_yaffs2.c
--- linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs2.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_yaffs2.c	2012-10-25 16:28:38.741881503 -0600
@@ -0,0 +1,1532 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_checkptrw.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_verify.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/*
+ * Checkpoints are really no benefit on very small partitions.
+ *
+ * To save space on small partitions don't bother with checkpoints unless
+ * the partition is at least this big.
+ */
+#define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+#define YAFFS_SMALL_HOLE_THRESHOLD 4
+
+/*
+ * Oldest Dirty Sequence Number handling.
+ */
+
+/* yaffs_calc_oldest_dirty_seq()
+ * yaffs2_find_oldest_dirty_seq()
+ * Calculate the oldest dirty sequence number if we don't know it.
+ */
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	int i;
+	unsigned seq;
+	unsigned block_no = 0;
+	struct yaffs_block_info *b;
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	/* Find the oldest dirty sequence number. */
+	seq = dev->seq_number + 1;
+	b = dev->block_info;
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
+		    (b->pages_in_use - b->soft_del_pages) <
+		    dev->param.chunks_per_block &&
+		    b->seq_number < seq) {
+			seq = b->seq_number;
+			block_no = i;
+		}
+		b++;
+	}
+
+	if (block_no) {
+		dev->oldest_dirty_seq = seq;
+		dev->oldest_dirty_block = block_no;
+	}
+}
+
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->oldest_dirty_seq)
+		yaffs_calc_oldest_dirty_seq(dev);
+}
+
+/*
+ * yaffs_clear_oldest_dirty_seq()
+ * Called when a block is erased or marked bad. (ie. when its seq_number
+ * becomes invalid). If the value matches the oldest then we clear
+ * dev->oldest_dirty_seq to force its recomputation.
+ */
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!bi || bi->seq_number == dev->oldest_dirty_seq) {
+		dev->oldest_dirty_seq = 0;
+		dev->oldest_dirty_block = 0;
+	}
+}
+
+/*
+ * yaffs2_update_oldest_dirty_seq()
+ * Update the oldest dirty sequence number whenever we dirty a block.
+ * Only do this if the oldest_dirty_seq is actually being tracked.
+ */
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (dev->oldest_dirty_seq) {
+		if (dev->oldest_dirty_seq > bi->seq_number) {
+			dev->oldest_dirty_seq = bi->seq_number;
+			dev->oldest_dirty_block = block_no;
+		}
+	}
+}
+
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->has_shrink_hdr)
+		return 1;	/* can gc */
+
+	yaffs2_find_oldest_dirty_seq(dev);
+
+	/* Can't do gc of this block if there are any blocks older than this
+	 * one that have discarded pages.
+	 */
+	return (bi->seq_number <= dev->oldest_dirty_seq);
+}
+
+/*
+ * yaffs2_find_refresh_block()
+ * periodically finds the oldest full block by sequence number for refreshing.
+ * Only for yaffs2.
+ */
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
+{
+	u32 b;
+	u32 oldest = 0;
+	u32 oldest_seq = 0;
+	struct yaffs_block_info *bi;
+
+	if (!dev->param.is_yaffs2)
+		return oldest;
+
+	/*
+	 * If refresh period < 10 then refreshing is disabled.
+	 */
+	if (dev->param.refresh_period < 10)
+		return oldest;
+
+	/*
+	 * Fix broken values.
+	 */
+	if (dev->refresh_skip > dev->param.refresh_period)
+		dev->refresh_skip = dev->param.refresh_period;
+
+	if (dev->refresh_skip > 0)
+		return oldest;
+
+	/*
+	 * Refresh skip is now zero.
+	 * We'll do a refresh this time around....
+	 * Update the refresh skip and find the oldest block.
+	 */
+	dev->refresh_skip = dev->param.refresh_period;
+	dev->refresh_count++;
+	bi = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+
+			if (oldest < 1 || bi->seq_number < oldest_seq) {
+				oldest = b;
+				oldest_seq = bi->seq_number;
+			}
+		}
+		bi++;
+	}
+
+	if (oldest > 0) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC refresh count %d selected block %d with seq_number %d",
+			dev->refresh_count, oldest, oldest_seq);
+	}
+
+	return oldest;
+}
+
+int yaffs2_checkpt_required(struct yaffs_dev *dev)
+{
+	int nblocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	nblocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	return !dev->param.skip_checkpt_wr &&
+	    !dev->read_only && (nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+}
+
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
+{
+	int retval;
+	int n_bytes = 0;
+	int n_blocks;
+	int dev_blocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
+		/* Not a valid value so recalculate */
+		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(struct yaffs_checkpt_dev);
+		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
+		n_bytes += dev_blocks * dev->chunk_bit_stride;
+		n_bytes +=
+		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
+		    dev->n_obj;
+		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(u32);	/* checksum */
+
+		/* Round up and add 2 blocks to allow for some bad blocks,
+		 * so add 3 */
+
+		n_blocks =
+		    (n_bytes /
+		     (dev->data_bytes_per_chunk *
+		      dev->param.chunks_per_block)) + 3;
+
+		dev->checkpoint_blocks_required = n_blocks;
+	}
+
+	retval = dev->checkpoint_blocks_required - dev->blocks_in_checkpt;
+	if (retval < 0)
+		retval = 0;
+	return retval;
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+static int yaffs2_wr_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.struct_type = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.struct_type == sizeof(cp)) &&
+		    (cp.magic == YAFFS_MAGIC) &&
+		    (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		    (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_dev_to_checkpt_dev(struct yaffs_checkpt_dev *cp,
+				      struct yaffs_dev *dev)
+{
+	cp->n_erased_blocks = dev->n_erased_blocks;
+	cp->alloc_block = dev->alloc_block;
+	cp->alloc_page = dev->alloc_page;
+	cp->n_free_chunks = dev->n_free_chunks;
+
+	cp->n_deleted_files = dev->n_deleted_files;
+	cp->n_unlinked_files = dev->n_unlinked_files;
+	cp->n_bg_deletions = dev->n_bg_deletions;
+	cp->seq_number = dev->seq_number;
+
+}
+
+static void yaffs_checkpt_dev_to_dev(struct yaffs_dev *dev,
+				     struct yaffs_checkpt_dev *cp)
+{
+	dev->n_erased_blocks = cp->n_erased_blocks;
+	dev->alloc_block = cp->alloc_block;
+	dev->alloc_page = cp->alloc_page;
+	dev->n_free_chunks = cp->n_free_chunks;
+
+	dev->n_deleted_files = cp->n_deleted_files;
+	dev->n_unlinked_files = cp->n_unlinked_files;
+	dev->n_bg_deletions = cp->n_bg_deletions;
+	dev->seq_number = cp->seq_number;
+}
+
+static int yaffs2_wr_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	int ok;
+
+	/* Write device runtime values */
+	yaffs2_dev_to_checkpt_dev(&cp, dev);
+	cp.struct_type = sizeof(cp);
+
+	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	/* Write block info */
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	if (!ok)
+		return 0;
+
+	/* Write chunk bits */
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks =
+	    (dev->internal_end_block - dev->internal_start_block + 1);
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.struct_type != sizeof(cp))
+		return 0;
+
+	yaffs_checkpt_dev_to_dev(dev, &cp);
+
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+
+	ok = (yaffs2_checkpt_rd(dev, dev->block_info, n_bytes) == n_bytes);
+
+	if (!ok)
+		return 0;
+
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+
+	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
+				   struct yaffs_obj *obj)
+{
+	cp->obj_id = obj->obj_id;
+	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
+	cp->hdr_chunk = obj->hdr_chunk;
+	cp->variant_type = obj->variant_type;
+	cp->deleted = obj->deleted;
+	cp->soft_del = obj->soft_del;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->rename_allowed = obj->rename_allowed;
+	cp->unlink_allowed = obj->unlink_allowed;
+	cp->serial = obj->serial;
+	cp->n_data_chunks = obj->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		cp->size_or_equiv_obj = obj->variant.file_variant.file_size;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
+}
+
+static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
+				     struct yaffs_checkpt_obj *cp)
+{
+	struct yaffs_obj *parent;
+
+	if (obj->variant_type != cp->variant_type) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Checkpoint read object %d type %d chunk %d does not match existing object type %d",
+			cp->obj_id, cp->variant_type, cp->hdr_chunk,
+			obj->variant_type);
+		return 0;
+	}
+
+	obj->obj_id = cp->obj_id;
+
+	if (cp->parent_id)
+		parent = yaffs_find_or_create_by_number(obj->my_dev,
+						cp->parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory",
+				cp->obj_id, cp->parent_id,
+				cp->variant_type, cp->hdr_chunk,
+				parent->variant_type);
+			return 0;
+		}
+		yaffs_add_obj_to_dir(parent, obj);
+	}
+
+	obj->hdr_chunk = cp->hdr_chunk;
+	obj->variant_type = cp->variant_type;
+	obj->deleted = cp->deleted;
+	obj->soft_del = cp->soft_del;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->rename_allowed = cp->rename_allowed;
+	obj->unlink_allowed = cp->unlink_allowed;
+	obj->serial = cp->serial;
+	obj->n_data_chunks = cp->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		obj->variant.file_variant.file_size = cp->size_or_equiv_obj;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		obj->variant.hardlink_variant.equiv_id = cp->size_or_equiv_obj;
+
+	if (obj->hdr_chunk > 0)
+		obj->lazy_loaded = 1;
+	return 1;
+}
+
+static int yaffs2_checkpt_tnode_worker(struct yaffs_obj *in,
+				       struct yaffs_tnode *tn, u32 level,
+				       int chunk_offset)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+	int ok = 1;
+	u32 base_offset;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+			if (!tn->internal[i])
+				continue;
+			ok = yaffs2_checkpt_tnode_worker(in,
+				 tn->internal[i],
+				 level - 1,
+				 (chunk_offset <<
+				  YAFFS_TNODES_INTERNAL_BITS) + i);
+		}
+		return ok;
+	}
+
+	/* Level 0 tnode */
+	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
+	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
+			sizeof(base_offset));
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
+			dev->tnode_size);
+
+	return ok;
+}
+
+static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 end_marker = ~0;
+	int ok = 1;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return ok;
+
+	ok = yaffs2_checkpt_tnode_worker(obj,
+					 obj->variant.file_variant.top,
+					 obj->variant.file_variant.
+					 top_level, 0);
+	if (ok)
+		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
+				sizeof(end_marker)) == sizeof(end_marker));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 base_chunk;
+	int ok = 1;
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_file_var *file_stuct_ptr = &obj->variant.file_variant;
+	struct yaffs_tnode *tn;
+	int nread = 0;
+
+	ok = (yaffs2_checkpt_rd(dev, &base_chunk, sizeof(base_chunk)) ==
+	      sizeof(base_chunk));
+
+	while (ok && (~base_chunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+		tn = yaffs_get_tnode(dev);
+		if (tn)
+			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
+				dev->tnode_size);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_add_find_tnode_0(dev,
+						    file_stuct_ptr,
+						    base_chunk, tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs2_checkpt_rd
+			      (dev, &base_chunk,
+			       sizeof(base_chunk)) == sizeof(base_chunk));
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"Checkpoint read tnodes %d records, last %d. ok %d",
+		nread, base_chunk, ok);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int i;
+	int ok = 1;
+	struct list_head *lh;
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			if (!obj->defered_free) {
+				yaffs2_obj_checkpt_obj(&cp, obj);
+				cp.struct_type = sizeof(cp);
+
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"Checkpoint write object %d parent %d type %d chunk %d obj addr %p",
+					cp.obj_id, cp.parent_id,
+					cp.variant_type, cp.hdr_chunk, obj);
+
+				ok = (yaffs2_checkpt_wr(dev, &cp,
+						sizeof(cp)) == sizeof(cp));
+
+				if (ok &&
+					obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE)
+					ok = yaffs2_wr_checkpt_tnodes(obj);
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
+	cp.struct_type = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int ok = 1;
+	int done = 0;
+	LIST_HEAD(hard_list);
+
+
+	while (ok && !done) {
+		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.struct_type != sizeof(cp)) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"struct size %d instead of %d ok %d",
+				cp.struct_type, (int)sizeof(cp), ok);
+			ok = 0;
+		}
+
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"Checkpoint read object %d parent %d type %d chunk %d ",
+			cp.obj_id, cp.parent_id, cp.variant_type,
+			cp.hdr_chunk);
+
+		if (ok && cp.obj_id == ~0) {
+			done = 1;
+		} else if (ok) {
+			obj =
+			    yaffs_find_or_create_by_number(dev, cp.obj_id,
+							   cp.variant_type);
+			if (obj) {
+				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs2_rd_checkpt_tnodes(obj);
+				} else if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_HARDLINK) {
+					list_add(&obj->hard_links, &hard_list);
+				}
+			} else {
+				ok = 0;
+			}
+		}
+	}
+
+	if (ok)
+		yaffs_link_fixup(dev, &hard_list);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum);
+
+	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) ==
+		sizeof(checkpt_sum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_rd_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum0;
+	u32 checkpt_sum1;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum0);
+
+	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) ==
+		sizeof(checkpt_sum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpt_sum0 != checkpt_sum1)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_wr_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!yaffs2_checkpt_required(dev)) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint write");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 1);
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint device");
+		ok = yaffs2_wr_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint objects");
+		ok = yaffs2_wr_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs2_wr_checkpt_sum(dev);
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return dev->is_checkpointed;
+}
+
+static int yaffs2_rd_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!dev->param.is_yaffs2)
+		ok = 0;
+
+	if (ok && dev->param.skip_checkpt_rd) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint read");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 0); /* open for read */
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint device");
+		ok = yaffs2_rd_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint objects");
+		ok = yaffs2_rd_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs2_rd_checkpt_sum(dev);
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint checksum %d", ok);
+	}
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return ok ? 1 : 0;
+}
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
+{
+	if (dev->is_checkpointed || dev->blocks_in_checkpt > 0) {
+		dev->is_checkpointed = 0;
+		yaffs2_checkpt_invalidate_stream(dev);
+	}
+	if (dev->param.sb_dirty_fn)
+		dev->param.sb_dirty_fn(dev);
+}
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"save entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_verify_objects(dev);
+	yaffs_verify_blocks(dev);
+	yaffs_verify_free_chunks(dev);
+
+	if (!dev->is_checkpointed) {
+		yaffs2_checkpt_invalidate(dev);
+		yaffs2_wr_checkpt_data(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
+		"save exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return dev->is_checkpointed;
+}
+
+int yaffs2_checkpt_restore(struct yaffs_dev *dev)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	retval = yaffs2_rd_checkpt_data(dev);
+
+	if (dev->is_checkpointed) {
+		yaffs_verify_objects(dev);
+		yaffs_verify_blocks(dev);
+		yaffs_verify_free_chunks(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return retval;
+}
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size)
+{
+	/* if new_size > old_file_size.
+	 * We're going to be writing a hole.
+	 * If the hole is small then write zeros otherwise write a start
+	 * of hole marker.
+	 */
+	loff_t old_file_size;
+	loff_t increase;
+	int small_hole;
+	int result = YAFFS_OK;
+	struct yaffs_dev *dev = NULL;
+	u8 *local_buffer = NULL;
+	int small_increase_ok = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	dev = obj->my_dev;
+
+	/* Bail out if not yaffs2 mode */
+	if (!dev->param.is_yaffs2)
+		return YAFFS_OK;
+
+	old_file_size = obj->variant.file_variant.file_size;
+
+	if (new_size <= old_file_size)
+		return YAFFS_OK;
+
+	increase = new_size - old_file_size;
+
+	if (increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
+	    yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+		small_hole = 1;
+	else
+		small_hole = 0;
+
+	if (small_hole)
+		local_buffer = yaffs_get_temp_buffer(dev);
+
+	if (local_buffer) {
+		/* fill hole with zero bytes */
+		loff_t pos = old_file_size;
+		int this_write;
+		int written;
+		memset(local_buffer, 0, dev->data_bytes_per_chunk);
+		small_increase_ok = 1;
+
+		while (increase > 0 && small_increase_ok) {
+			this_write = increase;
+			if (this_write > dev->data_bytes_per_chunk)
+				this_write = dev->data_bytes_per_chunk;
+			written =
+			    yaffs_do_file_wr(obj, local_buffer, pos, this_write,
+					     0);
+			if (written == this_write) {
+				pos += this_write;
+				increase -= this_write;
+			} else {
+				small_increase_ok = 0;
+			}
+		}
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+
+		/* If out of space then reverse any chunks we've added */
+		if (!small_increase_ok)
+			yaffs_resize_file_down(obj, old_file_size);
+	}
+
+	if (!small_increase_ok &&
+	    obj->parent &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_DELETED) {
+		/* Write a hole start header with the old file size */
+		yaffs_update_oh(obj, NULL, 0, 1, 0, NULL);
+	}
+
+	return result;
+}
+
+struct yaffs_block_index {
+	int seq;
+	int block;
+};
+
+static int yaffs2_ybicmp(const void *a, const void *b)
+{
+	int aseq = ((struct yaffs_block_index *)a)->seq;
+	int bseq = ((struct yaffs_block_index *)b)->seq;
+	int ablock = ((struct yaffs_block_index *)a)->block;
+	int bblock = ((struct yaffs_block_index *)b)->block;
+
+	if (aseq == bseq)
+		return ablock - bblock;
+
+	return aseq - bseq;
+}
+
+static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
+		struct yaffs_block_info *bi,
+		int blk, int chunk_in_block,
+		int *found_chunks,
+		u8 *chunk_data,
+		struct list_head *hard_list,
+		int summary_available)
+{
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int equiv_id;
+	loff_t file_size;
+	int is_shrink;
+	int is_unlinked;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
+	struct yaffs_file_var *file_var;
+	struct yaffs_hardlink_var *hl_var;
+	struct yaffs_symlink_var *sl_var;
+
+	if (summary_available) {
+		result = yaffs_summary_fetch(dev, &tags, chunk_in_block);
+		tags.seq_number = bi->seq_number;
+	}
+
+	if (!summary_available || tags.obj_id == 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
+		dev->tags_used++;
+	} else {
+		dev->summary_used++;
+	}
+
+	/* Let's have a good look at this chunk... */
+
+	if (!tags.chunk_used) {
+		/* An unassigned chunk in the block.
+		 * If there are used chunks after this one, then
+		 * it is a chunk that was skipped due to failing
+		 * the erased check. Just skip it so that it can
+		 * be deleted.
+		 * But, more typically, We get here when this is
+		 * an unallocated chunk and his means that
+		 * either the block is empty or this is the one
+		 * being allocated from
+		 */
+
+		if (*found_chunks) {
+			/* This is a chunk that was skipped due
+			 * to failing the erased check */
+		} else if (chunk_in_block == 0) {
+			/* We're looking at the first chunk in
+			 * the block so the block is unused */
+			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+			dev->n_erased_blocks++;
+		} else {
+			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+				if (dev->seq_number == bi->seq_number) {
+					/* Allocating from this block*/
+					yaffs_trace(YAFFS_TRACE_SCAN,
+					    " Allocating from %d %d",
+					    blk, chunk_in_block);
+
+					bi->block_state =
+						YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = chunk_in_block;
+					dev->alloc_block_finder = blk;
+				} else {
+					/* This is a partially written block
+					 * that is not the current
+					 * allocation block.
+					 */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						"Partially written block %d detected. gc will fix this.",
+						blk);
+				}
+			}
+		}
+
+		dev->n_free_chunks++;
+
+	} else if (tags.ecc_result ==
+		YAFFS_ECC_RESULT_UNFIXED) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			" Unfixed ECC in chunk(%d:%d), chunk ignored",
+			blk, chunk_in_block);
+			dev->n_free_chunks++;
+	} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
+		   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
+		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||
+		   (tags.chunk_id > 0 &&
+		     tags.n_bytes > dev->data_bytes_per_chunk) ||
+		   tags.seq_number != bi->seq_number) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
+			blk, chunk_in_block, tags.obj_id,
+			tags.chunk_id, tags.n_bytes);
+		dev->n_free_chunks++;
+	} else if (tags.chunk_id > 0) {
+		/* chunk_id > 0 so it is a data chunk... */
+		loff_t endpos;
+		loff_t chunk_base = (tags.chunk_id - 1) *
+					dev->data_bytes_per_chunk;
+
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					YAFFS_OBJECT_TYPE_FILE);
+		if (!in)
+			/* Out of memory */
+			alloc_failed = 1;
+
+		if (in &&
+		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
+		    chunk_base < in->variant.file_variant.shrink_size) {
+			/* This has not been invalidated by
+			 * a resize */
+			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
+								chunk, -1))
+				alloc_failed = 1;
+
+			/* File size is calculated by looking at
+			 * the data chunks if we have not
+			 * seen an object header yet.
+			 * Stop this practice once we find an
+			 * object header.
+			 */
+			endpos = chunk_base + tags.n_bytes;
+
+			if (!in->valid &&
+			    in->variant.file_variant.scanned_size < endpos) {
+				in->variant.file_variant.
+				    scanned_size = endpos;
+				in->variant.file_variant.
+				    file_size = endpos;
+			}
+		} else if (in) {
+			/* This chunk has been invalidated by a
+			 * resize, or a past file deletion
+			 * so delete the chunk*/
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+	} else {
+		/* chunk_id == 0, so it is an ObjectHeader.
+		 * Thus, we read in the object header and make
+		 * the object
+		 */
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		oh = NULL;
+		in = NULL;
+
+		if (tags.extra_available) {
+			in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					tags.extra_obj_type);
+			if (!in)
+				alloc_failed = 1;
+		}
+
+		if (!in ||
+		    (!in->valid && dev->param.disable_lazy_load) ||
+		    tags.extra_shadows ||
+		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+			/* If we don't have  valid info then we
+			 * need to read the chunk
+			 * TODO In future we can probably defer
+			 * reading the chunk and living with
+			 * invalid data until needed.
+			 */
+
+			result = yaffs_rd_chunk_tags_nand(dev,
+						  chunk,
+						  chunk_data,
+						  NULL);
+
+			oh = (struct yaffs_obj_hdr *)chunk_data;
+
+			if (dev->param.inband_tags) {
+				/* Fix up the header if they got
+				 * corrupted by inband tags */
+				oh->shadows_obj =
+				    oh->inband_shadowed_obj_id;
+				oh->is_shrink =
+				    oh->inband_is_shrink;
+			}
+
+			if (!in) {
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id, oh->type);
+				if (!in)
+					alloc_failed = 1;
+			}
+		}
+
+		if (!in) {
+			/* TODO Hoosterman we have a problem! */
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
+				tags.obj_id, chunk);
+			return YAFFS_FAIL;
+		}
+
+		if (in->valid) {
+			/* We have already filled this one.
+			 * We have a duplicate that will be
+			 * discarded, but we first have to suck
+			 * out resize info if it is a file.
+			 */
+			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+				 (tags.extra_available &&
+				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+				)) {
+				loff_t this_size = (oh) ?
+					yaffs_oh_to_size(oh) :
+					tags.extra_file_size;
+				u32 parent_obj_id = (oh) ?
+					oh->parent_obj_id :
+					tags.extra_parent_id;
+
+				is_shrink = (oh) ?
+					oh->is_shrink :
+					tags.extra_is_shrink;
+
+				/* If it is deleted (unlinked
+				 * at start also means deleted)
+				 * we treat the file size as
+				 * being zeroed at this point.
+				 */
+				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
+				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
+					this_size = 0;
+					is_shrink = 1;
+				}
+
+				if (is_shrink &&
+				    in->variant.file_variant.shrink_size >
+				    this_size)
+					in->variant.file_variant.shrink_size =
+					this_size;
+
+				if (is_shrink)
+					bi->has_shrink_hdr = 1;
+			}
+			/* Use existing - destroy this one. */
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+
+		if (!in->valid && in->variant_type !=
+		    (oh ? oh->type : tags.extra_obj_type))
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Bad object type, %d != %d, for object %d at chunk %d during scan",
+				oh ? oh->type : tags.extra_obj_type,
+				in->variant_type, tags.obj_id,
+				chunk);
+
+		if (!in->valid &&
+		    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+			/* We only load some info, don't fiddle
+			 * with directory structure */
+			in->valid = 1;
+
+			if (oh) {
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+				in->lazy_loaded = 0;
+			} else {
+				in->lazy_loaded = 1;
+			}
+			in->hdr_chunk = chunk;
+
+		} else if (!in->valid) {
+			/* we need to load this info */
+			in->valid = 1;
+			in->hdr_chunk = chunk;
+			if (oh) {
+				in->variant_type = oh->type;
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+
+				if (oh->shadows_obj > 0)
+					yaffs_handle_shadowed_obj(dev,
+					     oh->shadows_obj, 1);
+
+				yaffs_set_obj_name_from_oh(in, oh);
+				parent = yaffs_find_or_create_by_number(dev,
+						oh->parent_obj_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = yaffs_oh_to_size(oh);
+				is_shrink = oh->is_shrink;
+				equiv_id = oh->equiv_id;
+			} else {
+				in->variant_type = tags.extra_obj_type;
+				parent = yaffs_find_or_create_by_number(dev,
+						tags.extra_parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = tags.extra_file_size;
+				is_shrink = tags.extra_is_shrink;
+				equiv_id = tags.extra_equiv_id;
+				in->lazy_loaded = 1;
+			}
+			in->dirty = 0;
+
+			if (!parent)
+				alloc_failed = 1;
+
+			/* directory stuff...
+			 * hook up to parent
+			 */
+
+			if (parent &&
+			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
+				/* Set up as a directory */
+				parent->variant_type =
+					YAFFS_OBJECT_TYPE_DIRECTORY;
+				INIT_LIST_HEAD(&parent->
+						variant.dir_variant.children);
+			} else if (!parent ||
+				   parent->variant_type !=
+					YAFFS_OBJECT_TYPE_DIRECTORY) {
+				/* Hoosterman, another problem....
+				 * Trying to use a non-directory as a directory
+				 */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+					);
+				parent = dev->lost_n_found;
+			}
+			yaffs_add_obj_to_dir(parent, in);
+
+			is_unlinked = (parent == dev->del_dir) ||
+					(parent == dev->unlinked_dir);
+
+			if (is_shrink)
+				/* Mark the block */
+				bi->has_shrink_hdr = 1;
+
+			/* Note re hardlinks.
+			 * Since we might scan a hardlink before its equivalent
+			 * object is scanned we put them all in a list.
+			 * After scanning is complete, we should have all the
+			 * objects, so we run through this list and fix up all
+			 * the chains.
+			 */
+
+			switch (in->variant_type) {
+			case YAFFS_OBJECT_TYPE_UNKNOWN:
+				/* Todo got a problem */
+				break;
+			case YAFFS_OBJECT_TYPE_FILE:
+				file_var = &in->variant.file_variant;
+				if (file_var->scanned_size < file_size) {
+					/* This covers the case where the file
+					 * size is greater than the data held.
+					 * This will happen if the file is
+					 * resized to be larger than its
+					 * current data extents.
+					 */
+					file_var->file_size = file_size;
+					file_var->scanned_size = file_size;
+				}
+
+				if (file_var->shrink_size > file_size)
+					file_var->shrink_size = file_size;
+
+				break;
+			case YAFFS_OBJECT_TYPE_HARDLINK:
+				hl_var = &in->variant.hardlink_variant;
+				if (!is_unlinked) {
+					hl_var->equiv_id = equiv_id;
+					list_add(&in->hard_links, hard_list);
+				}
+				break;
+			case YAFFS_OBJECT_TYPE_DIRECTORY:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SPECIAL:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SYMLINK:
+				sl_var = &in->variant.symlink_variant;
+				if (oh) {
+					sl_var->alias =
+					    yaffs_clone_str(oh->alias);
+					if (!sl_var->alias)
+						alloc_failed = 1;
+				}
+				break;
+			}
+		}
+	}
+	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+int yaffs2_scan_backwards(struct yaffs_dev *dev)
+{
+	int blk;
+	int block_iter;
+	int start_iter;
+	int end_iter;
+	int n_to_scan = 0;
+	enum yaffs_block_state state;
+	int c;
+	int deleted;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	u8 *chunk_data;
+	int found_chunks;
+	int alloc_failed = 0;
+	struct yaffs_block_index *block_index = NULL;
+	int alt_block_index = 0;
+	int summary_available;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	block_index =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+
+	if (!block_index) {
+		block_index =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
+		alt_block_index = 1;
+	}
+
+	if (!block_index) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"yaffs2_scan_backwards() could not allocate block index!"
+			);
+		return YAFFS_FAIL;
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, bi->block_state, seq_number);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocks_in_checkpt++;
+
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		} else if (bi->block_state ==
+				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* Determine the highest sequence number */
+			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+				block_index[n_to_scan].seq = seq_number;
+				block_index[n_to_scan].block = blk;
+				n_to_scan++;
+				if (seq_number >= dev->seq_number)
+					dev->seq_number = seq_number;
+			} else {
+				/* TODO: Nasty sequence number! */
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Block scanning block %d has bad sequence number %d",
+					blk, seq_number);
+			}
+		}
+		bi++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "%d blocks to be sorted...", n_to_scan);
+
+	cond_resched();
+
+	/* Sort the blocks by sequence number */
+	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
+		   yaffs2_ybicmp, NULL);
+
+	cond_resched();
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+
+	/* Now scan the blocks looking at the data. */
+	start_iter = 0;
+	end_iter = n_to_scan - 1;
+	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+
+	/* For each block.... backwards */
+	for (block_iter = end_iter;
+	     !alloc_failed && block_iter >= start_iter;
+	     block_iter--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		cond_resched();
+
+		/* get the block to scan in the correct order */
+		blk = block_index[block_iter].block;
+		bi = yaffs_get_block_info(dev, blk);
+		deleted = 0;
+
+		summary_available = yaffs_summary_read(dev, dev->sum_tags, blk);
+
+		/* For each chunk in each block that needs scanning.... */
+		found_chunks = 0;
+		if (summary_available)
+			c = dev->chunks_per_summary - 1;
+		else
+			c = dev->param.chunks_per_block - 1;
+
+		for (/* c is already initialised */;
+		     !alloc_failed && c >= 0 &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING);
+		      c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+			if (yaffs2_scan_chunk(dev, bi, blk, c,
+					&found_chunks, chunk_data,
+					&hard_list, summary_available) ==
+					YAFFS_FAIL)
+				alloc_failed = 1;
+		}
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning, then the block
+			 * is fully allocated. */
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_block_became_dirty(dev, blk);
+		}
+	}
+
+	yaffs_skip_rest_of_block(dev);
+
+	if (alt_block_index)
+		vfree(block_index);
+	else
+		kfree(block_index);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_link_fixup(dev, &hard_list);
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs2_scan_backwards ends");
+
+	return YAFFS_OK;
+}
diff -uprN linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs2.h linux-3.1.5/fs/yaffs2/yaffs_yaffs2.h
--- linux-3.1.5-orig/fs/yaffs2/yaffs_yaffs2.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yaffs_yaffs2.h	2012-10-25 16:28:38.763881560 -0600
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS2_H__
+#define __YAFFS_YAFFS2_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi);
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi);
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi);
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev);
+int yaffs2_checkpt_required(struct yaffs_dev *dev);
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev);
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev);
+int yaffs2_checkpt_save(struct yaffs_dev *dev);
+int yaffs2_checkpt_restore(struct yaffs_dev *dev);
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size);
+int yaffs2_scan_backwards(struct yaffs_dev *dev);
+
+#endif
diff -uprN linux-3.1.5-orig/fs/yaffs2/yportenv.h linux-3.1.5/fs/yaffs2/yportenv.h
--- linux-3.1.5-orig/fs/yaffs2/yportenv.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/fs/yaffs2/yportenv.h	2012-10-25 16:28:38.785881623 -0600
@@ -0,0 +1,82 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+
+
+#endif
diff -uprN linux-3.1.5-orig/include/config/auto.conf linux-3.1.5/include/config/auto.conf
--- linux-3.1.5-orig/include/config/auto.conf	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/config/auto.conf	2012-10-25 20:03:20.208349882 -0600
@@ -0,0 +1,569 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.1.5 Kernel Configuration
+#
+CONFIG_KERNEL_GZIP=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_CRC32=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_HAVE_AOUT=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_AEABI=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_MTD_NAND_S3C2410=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_INOTIFY_USER=y
+CONFIG_SPI_S3C24XX=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_NET_ETHERNET=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_USB_G_SERIAL=m
+CONFIG_ARM_UNWIND=y
+CONFIG_BINFMT_MISC=m
+CONFIG_SSB_POSSIBLE=y
+CONFIG_S3C2410_GPIO=y
+CONFIG_S3C_ADC=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_FSNOTIFY=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_HIDRAW=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_FIB_RULES=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_S3C2410_WATCHDOG=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_USB_DEVICEFS=y
+CONFIG_CPU_LLSERIAL_S3C2440_ONLY=y
+CONFIG_S3C_GPIO_PULL_UP=y
+CONFIG_MMC_S3C_PIO=y
+CONFIG_S3C24XX_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C2410_CLOCK=y
+CONFIG_NAMESPACES=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_CONNECTOR=m
+CONFIG_ATAGS_PROC=y
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_NFTL_RW=y
+CONFIG_MSDOS_FS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_HID_BELKIN=y
+CONFIG_RD_LZMA=y
+CONFIG_USB=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_CRC_ITU_T=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_BCMA_POSSIBLE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_PRINTK=y
+CONFIG_TIMERFD=y
+CONFIG_DNS_RESOLVER=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_SHMEM=y
+CONFIG_MTD=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DNOTIFY=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_SERIO=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_MTD_NAND_PLATFORM=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_CRC_T10DIF=y
+CONFIG_HWMON=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_IP_PNP=y
+CONFIG_LEDS_S3C24XX=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_PM_CLK=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKD=y
+CONFIG_ARM=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_LOGO=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_STANDALONE=y
+CONFIG_SERIAL_S3C2440=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_BLOCK=y
+CONFIG_HAVE_IDE=y
+CONFIG_HID_APPLE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_GENERIC_GPIO=y
+CONFIG_ROOT_NFS=y
+CONFIG_USER_NS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_BUG=y
+CONFIG_PM=y
+CONFIG_SPI=y
+CONFIG_MINI2440_BUTTONS=y
+CONFIG_DEVKMEM=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_VT=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_NLS=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_MFD_SUPPORT=y
+CONFIG_SYN_COOKIES=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_SPI_BITBANG=y
+CONFIG_CPU_S3C2440=y
+CONFIG_HID_CYPRESS=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_KEY=m
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_EVENTFD=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFRM=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_FTL=y
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_RD_LZO=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_MTD_CFI=y
+CONFIG_CPU_32v4T=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_ROMFS_ON_MTD=y
+CONFIG_DEFAULT_CFQ=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_EXT3_FS=y
+CONFIG_FAT_FS=y
+CONFIG_SENSORS_LM75=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_ROMFS_FS=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_RTC_DRV_S3C=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_INFTL=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_RD_GZIP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_LBDAF=y
+CONFIG_DEBUG_USER=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_BINFMT_ELF=y
+CONFIG_HOTPLUG=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_CPU_CP15=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_KEYS=y
+CONFIG_IPMI_POWEROFF=m
+CONFIG_SLABINFO=y
+CONFIG_IPMI_SI=m
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_SPI_MASTER=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_HID_GYRATION=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_TMPFS=y
+CONFIG_ANON_INODES=y
+CONFIG_FUTEX=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_MMC_SPI=y
+CONFIG_VMSPLIT_3G=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_USB_HID=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_DMADEVICES=y
+CONFIG_SYSVIPC=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_MODULES=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_HIDDEV=y
+CONFIG_CPU_S3C244X=y
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_UNIX=y
+CONFIG_YAFFS_YAFFS1=y
+CONFIG_HAVE_CLK=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_NFS_FS=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_FONTS=y
+CONFIG_RD_BZIP2=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_CPU_IDLE=y
+CONFIG_NFS_COMMON=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_EFI_PARTITION=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_VIRT_TO_BUS=y
+CONFIG_VFAT_FS=y
+CONFIG_PID_NS=y
+CONFIG_KEXEC=y
+CONFIG_ROMFS_ON_BLOCK=y
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_IPMI_HANDLER=m
+CONFIG_PLAT_SAMSUNG=y
+CONFIG_SUSPEND=y
+CONFIG_MTD_NAND_ECC=y
+CONFIG_FS_MBCACHE=y
+CONFIG_RTC_CLASS=y
+CONFIG_CRC7=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_ARCH_S3C2410=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_NO_IOPORT=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_SLUB=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_PM_SLEEP=y
+CONFIG_I2C=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RELAY=y
+CONFIG_CRYPTO_ECB=m
+CONFIG_USB_LIBUSUAL=y
+CONFIG_DEBUG_FS=y
+CONFIG_NET_PKTGEN=m
+CONFIG_BASE_FULL=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_SUNRPC=y
+CONFIG_YAFFS_FS=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_FW_LOADER=y
+CONFIG_KALLSYMS=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_MII=y
+CONFIG_SIGNALFD=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_S3C_DEV_NAND=y
+CONFIG_MTD_LPDDR=y
+CONFIG_CRYPTO_SHA1=m
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_XZ_DEC=y
+CONFIG_LOCKD_V4=y
+CONFIG_WATCHDOG=y
+CONFIG_HAS_IOMEM=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_NFTL=y
+CONFIG_USB_GADGETFS=m
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_APM_EMULATION=y
+CONFIG_HAVE_PWM=y
+CONFIG_EPOLL=y
+CONFIG_S3C2410_PM=y
+CONFIG_SDIO_UART=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_YAFFS_XATTR=y
+CONFIG_NET=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_PACKET=y
+CONFIG_NFS_V3=y
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_INET=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FREEZER=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_RTC_LIB=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_CRYPTO_AES=m
+CONFIG_GPIOLIB=y
+CONFIG_HID_PID=y
+CONFIG_NETFILTER=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_S3C_DEV_USB_HOST=y
+CONFIG_DM9000_DEBUGLEVEL=4
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_RD_XZ=y
+CONFIG_IP_MROUTE=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_SERIAL_SAMSUNG_UARTS=3
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BINFMT_AOUT=m
+CONFIG_MTD_BLKDEVS=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_I2C_S3C2410=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_FONT_8x8=y
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_PREEMPT_NONE=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_LIBCRC32C=m
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_INET_TCP_DIAG=m
+CONFIG_HID_SONY=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_HW_CONSOLE=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_EZKEY=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_GENERIC_ACL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MTD_RAM=y
+CONFIG_LOCALVERSION="-FriendlyARM"
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CRYPTO=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CMDLINE=""
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_DM9000=y
+CONFIG_FB_S3C2410=y
+CONFIG_SCSI_MOD=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_CRYPTO_CRC32C=m
+CONFIG_SERIAL_CORE=y
+CONFIG_UID16=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_NFS_V4=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_MTD_ROM=y
+CONFIG_HAS_DMA=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_HID_CHICONY=y
+CONFIG_HID=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_FONT_8x16=y
+CONFIG_ARCH_USES_GETTIMEOFFSET=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_IPC_NS=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_FTRACE=y
+CONFIG_HID_TOPSEED=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_HID_A4TECH=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_EEPROM_AT24=y
+CONFIG_MTD_NAND=y
+CONFIG_RT_MUTEXES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_I2C_ALGOBIT=y
+CONFIG_MMC_BLOCK=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_SERIO_RAW=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FRAME_WARN=1024
+CONFIG_USB_ETH=m
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_MMC=y
+CONFIG_HID_LOGITECH=y
+CONFIG_INLINE_SPIN_UNLOCK=y
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_HZ=200
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_PLAT_S3C24XX=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_NLATTR=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_MMC_SDHCI=y
+CONFIG_SAMSUNG_DEV_PWM=y
+CONFIG_HID_KYE=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_SYSFS=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_ARM_THUMB=y
+CONFIG_MMC_S3C=y
+CONFIG_I2C_SIMTEC=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_FB=y
+CONFIG_I2C_COMPAT=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_LEGACY_PTY_COUNT=128
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_USB_ZERO=m
+CONFIG_IP_MULTICAST=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_TINY_RCU=y
+CONFIG_HW_RANDOM=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_DEBUG_S3C_UART=0
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_BASE_SMALL=0
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_PROC_FS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_QINFO_PROBE=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_FLATMEM=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_SYSCTL=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_LDM_PARTITION=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_NS=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_MACH_MINI2440=y
+CONFIG_CRAMFS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_BLK_DEV=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_JBD=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_RFD_FTL=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_INET_DIAG=m
+CONFIG_ELF_CORE=y
+CONFIG_CPU_ARM920T=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_USB_SUPPORT=y
+CONFIG_MTD_CHAR=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_VT_CONSOLE=y
+CONFIG_LEDS_GPIO=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_BSD_DISKLABEL=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_ROMFS_BACKED_BY_BOTH=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HID_NTRIG=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=0
+CONFIG_CPU_USE_DOMAINS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_MINI2440_ADC=y
+CONFIG_NEW_LEDS=y
+CONFIG_SWAP=y
+CONFIG_CRC_CCITT=m
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_AVERAGE=y
+CONFIG_CPU_LLSERIAL_S3C2440=y
+CONFIG_BITREVERSE=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_FILE_LOCKING=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_AIO=y
+CONFIG_LEDS_CLASS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_HID_SUPPORT=y
+CONFIG_LEDS_MINI2440=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_UTS_NS=y
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MOUSE_PS2=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_INPUT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_MMU=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_FONT_MINI_4x6=y
diff -uprN linux-3.1.5-orig/include/config/auto.conf.cmd linux-3.1.5/include/config/auto.conf.cmd
--- linux-3.1.5-orig/include/config/auto.conf.cmd	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/config/auto.conf.cmd	2012-10-25 20:03:20.185349869 -0600
@@ -0,0 +1,679 @@
+deps_config := \
+	lib/xz/Kconfig \
+	lib/Kconfig \
+	drivers/crypto/caam/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/apparmor/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/ceph/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/pstore/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/logfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/yaffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/fanotify/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/virt/Kconfig \
+	drivers/iommu/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/hwspinlock/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/nvec/Kconfig \
+	drivers/staging/mei/Kconfig \
+	drivers/staging/altera-stapl/Kconfig \
+	drivers/staging/gma500/Kconfig \
+	drivers/staging/ste_rmi4/Kconfig \
+	drivers/staging/cptm1217/Kconfig \
+	drivers/staging/speakup/Kconfig \
+	drivers/staging/intel_sst/Kconfig \
+	drivers/staging/ft1000/Kconfig \
+	drivers/staging/bcm/Kconfig \
+	drivers/staging/keucr/Kconfig \
+	drivers/staging/ath6kl/Kconfig \
+	drivers/staging/sbe-2t3e3/Kconfig \
+	drivers/staging/quickstart/Kconfig \
+	drivers/staging/tidspbridge/Kconfig \
+	drivers/staging/solo6x10/Kconfig \
+	drivers/staging/easycap/Kconfig \
+	drivers/staging/lirc/Kconfig \
+	drivers/staging/xgifb/Kconfig \
+	drivers/staging/cxt1e1/Kconfig \
+	drivers/staging/crystalhd/Kconfig \
+	drivers/staging/dt3155v4l/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/zcache/Kconfig \
+	drivers/staging/zram/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/resolver/Kconfig \
+	drivers/staging/iio/meter/Kconfig \
+	drivers/staging/iio/magnetometer/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/imu/Kconfig \
+	drivers/staging/iio/gyro/Kconfig \
+	drivers/staging/iio/dds/Kconfig \
+	drivers/staging/iio/dac/Kconfig \
+	drivers/staging/iio/addac/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/vme/boards/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/spectra/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/rts_pstor/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/olpc_dcon/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/brcm80211/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cxd2099/Kconfig \
+	drivers/staging/tm6000/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/qib/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/renesas_usbhs/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/tegra/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/samsung/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/mid-x86/Kconfig \
+	sound/soc/kirkwood/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/nuc900/Kconfig \
+	sound/soc/jz4740/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/ep93xx/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/firewire/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/stub/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/ddbridge/Kconfig \
+	drivers/media/dvb/ngene/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/wl128x/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/tlg2300/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/s5p-tv/Kconfig \
+	drivers/media/video/m5mols/Kconfig \
+	drivers/media/video/marvell-ccic/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/omap/Kconfig \
+	drivers/media/video/davinci/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/rc/keymaps/Kconfig \
+	drivers/media/rc/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/bcma/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/pmbus/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/ptp/Kconfig \
+	drivers/pps/generators/Kconfig \
+	drivers/pps/clients/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/tty/hvc/Kconfig \
+	drivers/tty/serial/Kconfig \
+	drivers/tty/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/net/caif/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/mwifiex/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/wl1251/Kconfig \
+	drivers/net/wireless/rtlwifi/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlegacy/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/carl9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/rtl818x/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/octeon/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/target/iscsi/Kconfig \
+	drivers/target/tcm_fc/Kconfig \
+	drivers/target/loopback/Kconfig \
+	drivers/target/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2fc/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgbi/cxgb4i/Kconfig \
+	drivers/scsi/cxgbi/cxgb3i/Kconfig \
+	drivers/scsi/cxgbi/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/carma/Kconfig \
+	drivers/misc/lis3lv02d/Kconfig \
+	drivers/misc/ti-st/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/regmap/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	drivers/nfc/Kconfig \
+	net/nfc/Kconfig \
+	net/ceph/Kconfig \
+	net/caif/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/softing/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/c_can/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/batman-adv/Kconfig \
+	net/dns_resolver/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/l2tp/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/ipset/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig.powerpc \
+	drivers/cpufreq/Kconfig.arm \
+	drivers/cpufreq/Kconfig.x86 \
+	drivers/cpufreq/Kconfig \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	kernel/time/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	arch/arm/mach-w90x900/Kconfig \
+	arch/arm/mach-vt8500/Kconfig \
+	arch/arm/plat-versatile/Kconfig \
+	arch/arm/mach-vexpress/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-ux500/Kconfig \
+	arch/arm/mach-u300/Kconfig \
+	arch/arm/mach-tegra/Kconfig \
+	drivers/sh/intc/Kconfig \
+	drivers/sh/Kconfig \
+	arch/arm/mach-shmobile/Kconfig \
+	arch/arm/mach-exynos4/Kconfig \
+	arch/arm/mach-s5pv210/Kconfig \
+	arch/arm/mach-s5pc100/Kconfig \
+	arch/arm/mach-s5p64x0/Kconfig \
+	arch/arm/mach-s3c64xx/Kconfig \
+	arch/arm/mach-s3c2443/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2416/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c2410/Kconfig \
+	arch/arm/mach-tcc8k/Kconfig \
+	arch/arm/plat-tcc/Kconfig \
+	arch/arm/mach-spear6xx/Kconfig \
+	arch/arm/mach-spear3xx/Kconfig \
+	arch/arm/plat-spear/Kconfig \
+	arch/arm/plat-s5p/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/plat-samsung/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-mmp/Kconfig \
+	arch/arm/plat-pxa/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/mach-nuc93x/Kconfig \
+	arch/arm/plat-nomadik/Kconfig \
+	arch/arm/mach-nomadik/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-mxs/devices/Kconfig \
+	arch/arm/mach-mxs/Kconfig \
+	arch/arm/mach-mx5/Kconfig \
+	arch/arm/mach-imx/Kconfig \
+	arch/arm/plat-mxc/devices/Kconfig \
+	arch/arm/plat-mxc/Kconfig \
+	arch/arm/mach-mv78xx0/Kconfig \
+	arch/arm/mach-msm/Kconfig \
+	arch/arm/mach-lpc32xx/Kconfig \
+	arch/arm/mach-ks8695/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-gemini/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-dove/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-cns3xxx/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	arch/arm/mach-bcmring/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	kernel/irq/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "3.1.5"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(SRCARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -uprN linux-3.1.5-orig/include/config/kernel.release linux-3.1.5/include/config/kernel.release
--- linux-3.1.5-orig/include/config/kernel.release	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/config/kernel.release	2012-10-25 20:17:53.356835154 -0600
@@ -0,0 +1 @@
+3.1.5-FriendlyARM
diff -uprN linux-3.1.5-orig/include/config/tristate.conf linux-3.1.5/include/config/tristate.conf
--- linux-3.1.5-orig/include/config/tristate.conf	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/config/tristate.conf	2012-10-25 20:03:20.208349882 -0600
@@ -0,0 +1,189 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.1.5 Kernel Configuration
+#
+CONFIG_CRC32=Y
+CONFIG_MTD_NAND_S3C2410=Y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=Y
+CONFIG_SPI_S3C24XX=Y
+CONFIG_USB_G_SERIAL=M
+CONFIG_BINFMT_MISC=M
+CONFIG_S3C2410_WATCHDOG=Y
+CONFIG_CONNECTOR=M
+CONFIG_SERIAL_SAMSUNG=Y
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_MSDOS_FS=Y
+CONFIG_LZO_DECOMPRESS=Y
+CONFIG_HID_BELKIN=Y
+CONFIG_USB=Y
+CONFIG_CRC_ITU_T=Y
+CONFIG_FRAMEBUFFER_CONSOLE=Y
+CONFIG_HID_CHERRY=Y
+CONFIG_HID_SUNPLUS=Y
+CONFIG_DNS_RESOLVER=Y
+CONFIG_MTD=Y
+CONFIG_DECOMPRESS_LZMA=Y
+CONFIG_INPUT_MOUSEDEV=Y
+CONFIG_MTD_NAND_IDS=Y
+CONFIG_SERIO=Y
+CONFIG_SUNRPC_GSS=Y
+CONFIG_LEDS_TRIGGER_TIMER=Y
+CONFIG_MTD_NAND_PLATFORM=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_CRC_T10DIF=Y
+CONFIG_HWMON=Y
+CONFIG_LEDS_S3C24XX=Y
+CONFIG_LOCKD=Y
+CONFIG_VIDEO_OUTPUT_CONTROL=Y
+CONFIG_MTD_CFI_UTIL=Y
+CONFIG_DISPLAY_SUPPORT=Y
+CONFIG_SERIAL_S3C2440=Y
+CONFIG_HID_APPLE=Y
+CONFIG_MINI2440_BUTTONS=Y
+CONFIG_NLS=Y
+CONFIG_SPI_SPIDEV=Y
+CONFIG_SPI_BITBANG=Y
+CONFIG_HID_CYPRESS=Y
+CONFIG_CRYPTO_WORKQUEUE=Y
+CONFIG_HID_KENSINGTON=Y
+CONFIG_NET_KEY=M
+CONFIG_IOSCHED_DEADLINE=Y
+CONFIG_FTL=Y
+CONFIG_IPMI_DEVICE_INTERFACE=M
+CONFIG_BACKLIGHT_CLASS_DEVICE=Y
+CONFIG_MTD_CFI=Y
+CONFIG_EXT3_FS=Y
+CONFIG_FAT_FS=Y
+CONFIG_SENSORS_LM75=Y
+CONFIG_ROMFS_FS=Y
+CONFIG_IOSCHED_CFQ=Y
+CONFIG_RTC_DRV_S3C=Y
+CONFIG_MTD_CFI_STAA=Y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=Y
+CONFIG_USB_OHCI_HCD=Y
+CONFIG_INFTL=Y
+CONFIG_IPMI_POWEROFF=M
+CONFIG_IPMI_SI=M
+CONFIG_HID_GYRATION=Y
+CONFIG_MMC_SPI=Y
+CONFIG_USB_HID=Y
+CONFIG_CRYPTO_PCOMP2=Y
+CONFIG_KEYBOARD_GPIO=Y
+CONFIG_USB_GADGET=Y
+CONFIG_UNIX=Y
+CONFIG_CRYPTO_HASH2=Y
+CONFIG_NFS_FS=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_LEDS_TRIGGER_GPIO=Y
+CONFIG_CRYPTO_HASH=M
+CONFIG_VFAT_FS=Y
+CONFIG_BLK_DEV_LOOP=M
+CONFIG_IPMI_HANDLER=M
+CONFIG_MTD_NAND_ECC=Y
+CONFIG_FS_MBCACHE=Y
+CONFIG_CRC7=Y
+CONFIG_CRYPTO_MANAGER2=Y
+CONFIG_CONFIGFS_FS=M
+CONFIG_I2C=Y
+CONFIG_CRYPTO_ECB=M
+CONFIG_NET_PKTGEN=M
+CONFIG_FB_CFB_IMAGEBLIT=Y
+CONFIG_SUNRPC=Y
+CONFIG_YAFFS_FS=Y
+CONFIG_FW_LOADER=Y
+CONFIG_DECOMPRESS_XZ=Y
+CONFIG_MII=Y
+CONFIG_MTD_LPDDR=Y
+CONFIG_CRYPTO_SHA1=M
+CONFIG_IPMI_WATCHDOG=M
+CONFIG_XZ_DEC=Y
+CONFIG_NFTL=Y
+CONFIG_USB_GADGETFS=M
+CONFIG_APM_EMULATION=Y
+CONFIG_SDIO_UART=Y
+CONFIG_INPUT_EVDEV=Y
+CONFIG_MTD_GEN_PROBE=Y
+CONFIG_PACKET=Y
+CONFIG_USB_FILE_STORAGE=M
+CONFIG_LCD_PLATFORM=Y
+CONFIG_CRYPTO_AES=M
+CONFIG_SERIO_SERPORT=Y
+CONFIG_BINFMT_AOUT=M
+CONFIG_MTD_BLKDEVS=Y
+CONFIG_AUTOFS4_FS=Y
+CONFIG_I2C_S3C2410=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_LIBCRC32C=M
+CONFIG_INET_TCP_DIAG=M
+CONFIG_HID_SONY=Y
+CONFIG_HID_MONTEREY=Y
+CONFIG_HID_EZKEY=Y
+CONFIG_BACKLIGHT_PWM=Y
+CONFIG_MTD_RAM=Y
+CONFIG_CRYPTO=Y
+CONFIG_HID_SAMSUNG=Y
+CONFIG_DM9000=Y
+CONFIG_FB_S3C2410=Y
+CONFIG_SCSI_MOD=Y
+CONFIG_CRYPTO_CRC32C=M
+CONFIG_SERIAL_CORE=Y
+CONFIG_HID_MICROSOFT=Y
+CONFIG_MTD_ROM=Y
+CONFIG_FB_CFB_FILLRECT=Y
+CONFIG_HID_CHICONY=Y
+CONFIG_HID=Y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=Y
+CONFIG_HID_TOPSEED=Y
+CONFIG_DECOMPRESS_BZIP2=Y
+CONFIG_HID_A4TECH=Y
+CONFIG_INPUT_FF_MEMLESS=Y
+CONFIG_CRYPTO_ARC4=Y
+CONFIG_CRYPTO_MANAGER=Y
+CONFIG_EEPROM_AT24=Y
+CONFIG_MTD_NAND=Y
+CONFIG_I2C_ALGOBIT=Y
+CONFIG_MMC_BLOCK=Y
+CONFIG_SERIO_RAW=Y
+CONFIG_USB_ETH=M
+CONFIG_MMC=Y
+CONFIG_HID_LOGITECH=Y
+CONFIG_USB_CDC_COMPOSITE=M
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_MMC_SDHCI=Y
+CONFIG_HID_KYE=Y
+CONFIG_MMC_S3C=Y
+CONFIG_I2C_SIMTEC=Y
+CONFIG_FB=Y
+CONFIG_HID_PETALYNX=Y
+CONFIG_USB_ZERO=M
+CONFIG_HW_RANDOM=Y
+CONFIG_CRYPTO_BLKCIPHER2=Y
+CONFIG_MTD_BLOCK=Y
+CONFIG_MTD_QINFO_PROBE=Y
+CONFIG_HID_PANTHERLORD=Y
+CONFIG_XFRM_USER=M
+CONFIG_CRAMFS=Y
+CONFIG_NFS_ACL_SUPPORT=Y
+CONFIG_JBD=Y
+CONFIG_RFD_FTL=Y
+CONFIG_INET_DIAG=M
+CONFIG_MTD_JEDECPROBE=Y
+CONFIG_MTD_CHAR=Y
+CONFIG_LEDS_GPIO=Y
+CONFIG_BLK_DEV_RAM=Y
+CONFIG_INPUT_EVBUG=M
+CONFIG_FB_CFB_COPYAREA=Y
+CONFIG_MTD_CFI_AMDSTD=Y
+CONFIG_HID_NTRIG=Y
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_DECOMPRESS_LZO=Y
+CONFIG_I2C_CHARDEV=Y
+CONFIG_CRC_CCITT=M
+CONFIG_BITREVERSE=Y
+CONFIG_CRYPTO_BLKCIPHER=M
+CONFIG_LCD_CLASS_DEVICE=Y
+CONFIG_LEDS_MINI2440=Y
+CONFIG_CRYPTO_AEAD2=Y
+CONFIG_MOUSE_PS2=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_INPUT=Y
diff -uprN linux-3.1.5-orig/include/generated/asm-offsets.h linux-3.1.5/include/generated/asm-offsets.h
--- linux-3.1.5-orig/include/generated/asm-offsets.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/asm-offsets.h	2012-10-25 20:03:21.625350757 -0600
@@ -0,0 +1,69 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 168 /* offsetof(struct task_struct, active_mm)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 80 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 96 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 288 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 24 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 60 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 4 /* offsetof(struct machine_desc, name)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#define CACHE_FLUSH_KERN_ALL 4 /* offsetof(struct cpu_cache_fns, flush_kern_all)	@ */
+
+#define DMA_BIDIRECTIONAL 0 /* DMA_BIDIRECTIONAL	@ */
+#define DMA_TO_DEVICE 1 /* DMA_TO_DEVICE	@ */
+#define DMA_FROM_DEVICE 2 /* DMA_FROM_DEVICE	@ */
+
+#endif
diff -uprN linux-3.1.5-orig/include/generated/autoconf.h linux-3.1.5/include/generated/autoconf.h
--- linux-3.1.5-orig/include/generated/autoconf.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/autoconf.h	2012-10-25 20:03:20.208349882 -0600
@@ -0,0 +1,3717 @@
+/*
+ *
+ * Automatically generated file; DO NOT EDIT.
+ * Linux/arm 3.1.5 Kernel Configuration
+ *
+ */
+#define __enabled_CONFIG_ARCH_OMAP 0
+#define __enabled_CONFIG_ARCH_OMAP_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_861 0
+#define __enabled_CONFIG_NLS_CODEPAGE_861_MODULE 0
+#define __enabled_CONFIG_DMA_API_DEBUG 0
+#define __enabled_CONFIG_DMA_API_DEBUG_MODULE 0
+#define __enabled_CONFIG_SCSI_DMA 0
+#define __enabled_CONFIG_SCSI_DMA_MODULE 0
+#define __enabled_CONFIG_TCP_MD5SIG 0
+#define __enabled_CONFIG_TCP_MD5SIG_MODULE 0
+#define CONFIG_KERNEL_GZIP 1
+#define __enabled_CONFIG_KERNEL_GZIP 1
+#define __enabled_CONFIG_KERNEL_GZIP_MODULE 0
+#define __enabled_CONFIG_MACH_AML_M5900 0
+#define __enabled_CONFIG_MACH_AML_M5900_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_INEXIO 0
+#define __enabled_CONFIG_TOUCHSCREEN_INEXIO_MODULE 0
+#define __enabled_CONFIG_DW_WATCHDOG 0
+#define __enabled_CONFIG_DW_WATCHDOG_MODULE 0
+#define CONFIG_INPUT_KEYBOARD 1
+#define __enabled_CONFIG_INPUT_KEYBOARD 1
+#define __enabled_CONFIG_INPUT_KEYBOARD_MODULE 0
+#define __enabled_CONFIG_USB_C67X00_HCD 0
+#define __enabled_CONFIG_USB_C67X00_HCD_MODULE 0
+#define __enabled_CONFIG_SERIO_ALTERA_PS2 0
+#define __enabled_CONFIG_SERIO_ALTERA_PS2_MODULE 0
+#define CONFIG_CRC32 1
+#define __enabled_CONFIG_CRC32 1
+#define __enabled_CONFIG_CRC32_MODULE 0
+#define CONFIG_I2C_BOARDINFO 1
+#define __enabled_CONFIG_I2C_BOARDINFO 1
+#define __enabled_CONFIG_I2C_BOARDINFO_MODULE 0
+#define CONFIG_HAVE_AOUT 1
+#define __enabled_CONFIG_HAVE_AOUT 1
+#define __enabled_CONFIG_HAVE_AOUT_MODULE 0
+#define __enabled_CONFIG_GPIO_IT8761E 0
+#define __enabled_CONFIG_GPIO_IT8761E_MODULE 0
+#define __enabled_CONFIG_MFD_WM831X_I2C 0
+#define __enabled_CONFIG_MFD_WM831X_I2C_MODULE 0
+#define __enabled_CONFIG_CAIF 0
+#define __enabled_CONFIG_CAIF_MODULE 0
+#define __enabled_CONFIG_FSCACHE 0
+#define __enabled_CONFIG_FSCACHE_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX1668 0
+#define __enabled_CONFIG_SENSORS_MAX1668_MODULE 0
+#define CONFIG_EXT3_FS_XATTR 1
+#define __enabled_CONFIG_EXT3_FS_XATTR 1
+#define __enabled_CONFIG_EXT3_FS_XATTR_MODULE 0
+#define CONFIG_AEABI 1
+#define __enabled_CONFIG_AEABI 1
+#define __enabled_CONFIG_AEABI_MODULE 0
+#define CONFIG_FB_TILEBLITTING 1
+#define __enabled_CONFIG_FB_TILEBLITTING 1
+#define __enabled_CONFIG_FB_TILEBLITTING_MODULE 0
+#define __enabled_CONFIG_SECCOMP 0
+#define __enabled_CONFIG_SECCOMP_MODULE 0
+#define __enabled_CONFIG_R3964 0
+#define __enabled_CONFIG_R3964_MODULE 0
+#define CONFIG_MTD_NAND_S3C2410 1
+#define __enabled_CONFIG_MTD_NAND_S3C2410 1
+#define __enabled_CONFIG_MTD_NAND_S3C2410_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_ECC_BCH 0
+#define __enabled_CONFIG_MTD_NAND_ECC_BCH_MODULE 0
+#define __enabled_CONFIG_VLAN_8021Q 0
+#define __enabled_CONFIG_VLAN_8021Q_MODULE 0
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define __enabled_CONFIG_IP_MULTIPLE_TABLES 1
+#define __enabled_CONFIG_IP_MULTIPLE_TABLES_MODULE 0
+#define CONFIG_FLATMEM_MANUAL 1
+#define __enabled_CONFIG_FLATMEM_MANUAL 1
+#define __enabled_CONFIG_FLATMEM_MANUAL_MODULE 0
+#define __enabled_CONFIG_MTD_DOC2001 0
+#define __enabled_CONFIG_MTD_DOC2001_MODULE 0
+#define CONFIG_LEDS_TRIGGER_HEARTBEAT 1
+#define __enabled_CONFIG_LEDS_TRIGGER_HEARTBEAT 1
+#define __enabled_CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE 0
+#define __enabled_CONFIG_UACCESS_WITH_MEMCPY 0
+#define __enabled_CONFIG_UACCESS_WITH_MEMCPY_MODULE 0
+#define CONFIG_EXT3_DEFAULTS_TO_ORDERED 1
+#define __enabled_CONFIG_EXT3_DEFAULTS_TO_ORDERED 1
+#define __enabled_CONFIG_EXT3_DEFAULTS_TO_ORDERED_MODULE 0
+#define CONFIG_XZ_DEC_IA64 1
+#define __enabled_CONFIG_XZ_DEC_IA64 1
+#define __enabled_CONFIG_XZ_DEC_IA64_MODULE 0
+#define CONFIG_INOTIFY_USER 1
+#define __enabled_CONFIG_INOTIFY_USER 1
+#define __enabled_CONFIG_INOTIFY_USER_MODULE 0
+#define CONFIG_SPI_S3C24XX 1
+#define __enabled_CONFIG_SPI_S3C24XX 1
+#define __enabled_CONFIG_SPI_S3C24XX_MODULE 0
+#define __enabled_CONFIG_SAMPLES 0
+#define __enabled_CONFIG_SAMPLES_MODULE 0
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define __enabled_CONFIG_NETWORK_FILESYSTEMS 1
+#define __enabled_CONFIG_NETWORK_FILESYSTEMS_MODULE 0
+#define __enabled_CONFIG_MACH_NEO1973_GTA02 0
+#define __enabled_CONFIG_MACH_NEO1973_GTA02_MODULE 0
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define __enabled_CONFIG_MODULE_FORCE_UNLOAD 1
+#define __enabled_CONFIG_MODULE_FORCE_UNLOAD_MODULE 0
+#define __enabled_CONFIG_CRYPTO_MD4 0
+#define __enabled_CONFIG_CRYPTO_MD4_MODULE 0
+#define __enabled_CONFIG_ARCH_TEGRA 0
+#define __enabled_CONFIG_ARCH_TEGRA_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM95245 0
+#define __enabled_CONFIG_SENSORS_LM95245_MODULE 0
+#define CONFIG_NET_ETHERNET 1
+#define __enabled_CONFIG_NET_ETHERNET 1
+#define __enabled_CONFIG_NET_ETHERNET_MODULE 0
+#define CONFIG_EXPERIMENTAL 1
+#define __enabled_CONFIG_EXPERIMENTAL 1
+#define __enabled_CONFIG_EXPERIMENTAL_MODULE 0
+#define __enabled_CONFIG_MTD_AFS_PARTS 0
+#define __enabled_CONFIG_MTD_AFS_PARTS_MODULE 0
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define __enabled_CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define __enabled_CONFIG_ARCH_SUSPEND_POSSIBLE_MODULE 0
+#define CONFIG_INLINE_WRITE_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_IRQ_MODULE 0
+#define CONFIG_USB_G_SERIAL_MODULE 1
+#define __enabled_CONFIG_USB_G_SERIAL 0
+#define __enabled_CONFIG_USB_G_SERIAL_MODULE 1
+#define __enabled_CONFIG_LEDS_PCA955X 0
+#define __enabled_CONFIG_LEDS_PCA955X_MODULE 0
+#define __enabled_CONFIG_SENSORS_LTC4245 0
+#define __enabled_CONFIG_SENSORS_LTC4245_MODULE 0
+#define __enabled_CONFIG_HID_SPEEDLINK 0
+#define __enabled_CONFIG_HID_SPEEDLINK_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_NBD 0
+#define __enabled_CONFIG_BLK_DEV_NBD_MODULE 0
+#define CONFIG_ARM_UNWIND 1
+#define __enabled_CONFIG_ARM_UNWIND 1
+#define __enabled_CONFIG_ARM_UNWIND_MODULE 0
+#define __enabled_CONFIG_ARCH_VERSATILE 0
+#define __enabled_CONFIG_ARCH_VERSATILE_MODULE 0
+#define CONFIG_BINFMT_MISC_MODULE 1
+#define __enabled_CONFIG_BINFMT_MISC 0
+#define __enabled_CONFIG_BINFMT_MISC_MODULE 1
+#define CONFIG_SSB_POSSIBLE 1
+#define __enabled_CONFIG_SSB_POSSIBLE 1
+#define __enabled_CONFIG_SSB_POSSIBLE_MODULE 0
+#define CONFIG_S3C2410_GPIO 1
+#define __enabled_CONFIG_S3C2410_GPIO 1
+#define __enabled_CONFIG_S3C2410_GPIO_MODULE 0
+#define __enabled_CONFIG_MACH_SMDK2413 0
+#define __enabled_CONFIG_MACH_SMDK2413_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83792D 0
+#define __enabled_CONFIG_SENSORS_W83792D_MODULE 0
+#define __enabled_CONFIG_SYSV68_PARTITION 0
+#define __enabled_CONFIG_SYSV68_PARTITION_MODULE 0
+#define CONFIG_S3C_ADC 1
+#define __enabled_CONFIG_S3C_ADC 1
+#define __enabled_CONFIG_S3C_ADC_MODULE 0
+#define __enabled_CONFIG_MACH_RX3715 0
+#define __enabled_CONFIG_MACH_RX3715_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_855 0
+#define __enabled_CONFIG_NLS_CODEPAGE_855_MODULE 0
+#define __enabled_CONFIG_MFD_T7L66XB 0
+#define __enabled_CONFIG_MFD_T7L66XB_MODULE 0
+#define CONFIG_MTD_CMDLINE_PARTS 1
+#define __enabled_CONFIG_MTD_CMDLINE_PARTS 1
+#define __enabled_CONFIG_MTD_CMDLINE_PARTS_MODULE 0
+#define CONFIG_USB_OHCI_LITTLE_ENDIAN 1
+#define __enabled_CONFIG_USB_OHCI_LITTLE_ENDIAN 1
+#define __enabled_CONFIG_USB_OHCI_LITTLE_ENDIAN_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_RGMII 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_RGMII_MODULE 0
+#define __enabled_CONFIG_REISERFS_FS 0
+#define __enabled_CONFIG_REISERFS_FS_MODULE 0
+#define __enabled_CONFIG_ARCH_SHMOBILE 0
+#define __enabled_CONFIG_ARCH_SHMOBILE_MODULE 0
+#define CONFIG_FSNOTIFY 1
+#define __enabled_CONFIG_FSNOTIFY 1
+#define __enabled_CONFIG_FSNOTIFY_MODULE 0
+#define __enabled_CONFIG_CRYPTO_RMD128 0
+#define __enabled_CONFIG_CRYPTO_RMD128_MODULE 0
+#define CONFIG_BLK_DEV_LOOP_MIN_COUNT 8
+#define __enabled_CONFIG_MFD_TPS65910 0
+#define __enabled_CONFIG_MFD_TPS65910_MODULE 0
+#define __enabled_CONFIG_STACK_TRACER 0
+#define __enabled_CONFIG_STACK_TRACER_MODULE 0
+#define __enabled_CONFIG_CRYPTO_MANAGER_DISABLE_TESTS 0
+#define __enabled_CONFIG_CRYPTO_MANAGER_DISABLE_TESTS_MODULE 0
+#define CONFIG_HIDRAW 1
+#define __enabled_CONFIG_HIDRAW 1
+#define __enabled_CONFIG_HIDRAW_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADM1025 0
+#define __enabled_CONFIG_SENSORS_ADM1025_MODULE 0
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define __enabled_CONFIG_HAVE_KERNEL_LZMA 1
+#define __enabled_CONFIG_HAVE_KERNEL_LZMA_MODULE 0
+#define __enabled_CONFIG_IP_NF_QUEUE 0
+#define __enabled_CONFIG_IP_NF_QUEUE_MODULE 0
+#define __enabled_CONFIG_FB_S1D13XXX 0
+#define __enabled_CONFIG_FB_S1D13XXX_MODULE 0
+#define __enabled_CONFIG_MTD_SST25L 0
+#define __enabled_CONFIG_MTD_SST25L_MODULE 0
+#define __enabled_CONFIG_ARCH_ZYNQ 0
+#define __enabled_CONFIG_ARCH_ZYNQ_MODULE 0
+#define __enabled_CONFIG_DYNAMIC_DEBUG 0
+#define __enabled_CONFIG_DYNAMIC_DEBUG_MODULE 0
+#define CONFIG_DEFAULT_SECURITY_DAC 1
+#define __enabled_CONFIG_DEFAULT_SECURITY_DAC 1
+#define __enabled_CONFIG_DEFAULT_SECURITY_DAC_MODULE 0
+#define CONFIG_FIB_RULES 1
+#define __enabled_CONFIG_FIB_RULES 1
+#define __enabled_CONFIG_FIB_RULES_MODULE 0
+#define __enabled_CONFIG_HID_EMS_FF 0
+#define __enabled_CONFIG_HID_EMS_FF_MODULE 0
+#define CONFIG_KTIME_SCALAR 1
+#define __enabled_CONFIG_KTIME_SCALAR 1
+#define __enabled_CONFIG_KTIME_SCALAR_MODULE 0
+#define __enabled_CONFIG_MTD_PLATRAM 0
+#define __enabled_CONFIG_MTD_PLATRAM_MODULE 0
+#define __enabled_CONFIG_ARCH_KS8695 0
+#define __enabled_CONFIG_ARCH_KS8695_MODULE 0
+#define __enabled_CONFIG_NETDEV_1000 0
+#define __enabled_CONFIG_NETDEV_1000_MODULE 0
+#define CONFIG_S3C2410_WATCHDOG 1
+#define __enabled_CONFIG_S3C2410_WATCHDOG 1
+#define __enabled_CONFIG_S3C2410_WATCHDOG_MODULE 0
+#define __enabled_CONFIG_HWMON_DEBUG_CHIP 0
+#define __enabled_CONFIG_HWMON_DEBUG_CHIP_MODULE 0
+#define __enabled_CONFIG_IPV6 0
+#define __enabled_CONFIG_IPV6_MODULE 0
+#define __enabled_CONFIG_NET_9P 0
+#define __enabled_CONFIG_NET_9P_MODULE 0
+#define CONFIG_INPUT_MOUSEDEV_PSAUX 1
+#define __enabled_CONFIG_INPUT_MOUSEDEV_PSAUX 1
+#define __enabled_CONFIG_INPUT_MOUSEDEV_PSAUX_MODULE 0
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define __enabled_CONFIG_ARCH_EBSA110 0
+#define __enabled_CONFIG_ARCH_EBSA110_MODULE 0
+#define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
+#define CONFIG_USB_DEVICEFS 1
+#define __enabled_CONFIG_USB_DEVICEFS 1
+#define __enabled_CONFIG_USB_DEVICEFS_MODULE 0
+#define __enabled_CONFIG_DEVTMPFS 0
+#define __enabled_CONFIG_DEVTMPFS_MODULE 0
+#define CONFIG_CPU_LLSERIAL_S3C2440_ONLY 1
+#define __enabled_CONFIG_CPU_LLSERIAL_S3C2440_ONLY 1
+#define __enabled_CONFIG_CPU_LLSERIAL_S3C2440_ONLY_MODULE 0
+#define __enabled_CONFIG_SENSORS_PC87427 0
+#define __enabled_CONFIG_SENSORS_PC87427_MODULE 0
+#define __enabled_CONFIG_SM_FTL 0
+#define __enabled_CONFIG_SM_FTL_MODULE 0
+#define CONFIG_S3C_GPIO_PULL_UP 1
+#define __enabled_CONFIG_S3C_GPIO_PULL_UP 1
+#define __enabled_CONFIG_S3C_GPIO_PULL_UP_MODULE 0
+#define __enabled_CONFIG_ARCH_KIRKWOOD 0
+#define __enabled_CONFIG_ARCH_KIRKWOOD_MODULE 0
+#define __enabled_CONFIG_GPIO_MAX7301 0
+#define __enabled_CONFIG_GPIO_MAX7301_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_7 0
+#define __enabled_CONFIG_NLS_ISO8859_7_MODULE 0
+#define CONFIG_MMC_S3C_PIO 1
+#define __enabled_CONFIG_MMC_S3C_PIO 1
+#define __enabled_CONFIG_MMC_S3C_PIO_MODULE 0
+#define CONFIG_S3C24XX_GPIO_EXTRA 0
+#define __enabled_CONFIG_CRYPTO_PCBC 0
+#define __enabled_CONFIG_CRYPTO_PCBC_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1305 0
+#define __enabled_CONFIG_RTC_DRV_DS1305_MODULE 0
+#define CONFIG_S3C_GPIO_CFG_S3C24XX 1
+#define __enabled_CONFIG_S3C_GPIO_CFG_S3C24XX 1
+#define __enabled_CONFIG_S3C_GPIO_CFG_S3C24XX_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_S3C2410 0
+#define __enabled_CONFIG_TOUCHSCREEN_S3C2410_MODULE 0
+#define __enabled_CONFIG_WLAN 0
+#define __enabled_CONFIG_WLAN_MODULE 0
+#define __enabled_CONFIG_AFFS_FS 0
+#define __enabled_CONFIG_AFFS_FS_MODULE 0
+#define CONFIG_S3C2410_CLOCK 1
+#define __enabled_CONFIG_S3C2410_CLOCK 1
+#define __enabled_CONFIG_S3C2410_CLOCK_MODULE 0
+#define CONFIG_NAMESPACES 1
+#define __enabled_CONFIG_NAMESPACES 1
+#define __enabled_CONFIG_NAMESPACES_MODULE 0
+#define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
+#define CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_BH 0
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_BH_MODULE 0
+#define __enabled_CONFIG_SECURITY_DMESG_RESTRICT 0
+#define __enabled_CONFIG_SECURITY_DMESG_RESTRICT_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_BSG 0
+#define __enabled_CONFIG_BLK_DEV_BSG_MODULE 0
+#define CONFIG_CONNECTOR_MODULE 1
+#define __enabled_CONFIG_CONNECTOR 0
+#define __enabled_CONFIG_CONNECTOR_MODULE 1
+#define CONFIG_ATAGS_PROC 1
+#define __enabled_CONFIG_ATAGS_PROC 1
+#define __enabled_CONFIG_ATAGS_PROC_MODULE 0
+#define CONFIG_SERIAL_SAMSUNG 1
+#define __enabled_CONFIG_SERIAL_SAMSUNG 1
+#define __enabled_CONFIG_SERIAL_SAMSUNG_MODULE 0
+#define __enabled_CONFIG_DEBUG_RT_MUTEXES 0
+#define __enabled_CONFIG_DEBUG_RT_MUTEXES_MODULE 0
+#define __enabled_CONFIG_MINI2440_BUZZER 0
+#define __enabled_CONFIG_MINI2440_BUZZER_MODULE 0
+#define CONFIG_LEGACY_PTYS 1
+#define __enabled_CONFIG_LEGACY_PTYS 1
+#define __enabled_CONFIG_LEGACY_PTYS_MODULE 0
+#define __enabled_CONFIG_JFS_FS 0
+#define __enabled_CONFIG_JFS_FS_MODULE 0
+#define __enabled_CONFIG_ARCH_BAST 0
+#define __enabled_CONFIG_ARCH_BAST_MODULE 0
+#define CONFIG_CRYPTO_RNG2 1
+#define __enabled_CONFIG_CRYPTO_RNG2 1
+#define __enabled_CONFIG_CRYPTO_RNG2_MODULE 0
+#define __enabled_CONFIG_NETFILTER_NETLINK_QUEUE 0
+#define __enabled_CONFIG_NETFILTER_NETLINK_QUEUE_MODULE 0
+#define CONFIG_NFTL_RW 1
+#define __enabled_CONFIG_NFTL_RW 1
+#define __enabled_CONFIG_NFTL_RW_MODULE 0
+#define __enabled_CONFIG_MFD_MC13XXX 0
+#define __enabled_CONFIG_MFD_MC13XXX_MODULE 0
+#define __enabled_CONFIG_NETWORK_PHY_TIMESTAMPING 0
+#define __enabled_CONFIG_NETWORK_PHY_TIMESTAMPING_MODULE 0
+#define CONFIG_MSDOS_FS 1
+#define __enabled_CONFIG_MSDOS_FS 1
+#define __enabled_CONFIG_MSDOS_FS_MODULE 0
+#define __enabled_CONFIG_TUN 0
+#define __enabled_CONFIG_TUN_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADS1015 0
+#define __enabled_CONFIG_SENSORS_ADS1015_MODULE 0
+#define __enabled_CONFIG_CAN 0
+#define __enabled_CONFIG_CAN_MODULE 0
+#define __enabled_CONFIG_FONT_7x14 0
+#define __enabled_CONFIG_FONT_7x14_MODULE 0
+#define __enabled_CONFIG_EQUALIZER 0
+#define __enabled_CONFIG_EQUALIZER_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_1250 0
+#define __enabled_CONFIG_NLS_CODEPAGE_1250_MODULE 0
+#define __enabled_CONFIG_JBD_DEBUG 0
+#define __enabled_CONFIG_JBD_DEBUG_MODULE 0
+#define __enabled_CONFIG_SERIAL_8250 0
+#define __enabled_CONFIG_SERIAL_8250_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_ISL12022 0
+#define __enabled_CONFIG_RTC_DRV_ISL12022_MODULE 0
+#define __enabled_CONFIG_NCP_FS 0
+#define __enabled_CONFIG_NCP_FS_MODULE 0
+#define __enabled_CONFIG_XZ_DEC_TEST 0
+#define __enabled_CONFIG_XZ_DEC_TEST_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83793 0
+#define __enabled_CONFIG_SENSORS_W83793_MODULE 0
+#define CONFIG_HAVE_PROC_CPU 1
+#define __enabled_CONFIG_HAVE_PROC_CPU 1
+#define __enabled_CONFIG_HAVE_PROC_CPU_MODULE 0
+#define CONFIG_LZO_DECOMPRESS 1
+#define __enabled_CONFIG_LZO_DECOMPRESS 1
+#define __enabled_CONFIG_LZO_DECOMPRESS_MODULE 0
+#define CONFIG_IOMMU_SUPPORT 1
+#define __enabled_CONFIG_IOMMU_SUPPORT 1
+#define __enabled_CONFIG_IOMMU_SUPPORT_MODULE 0
+#define CONFIG_HID_BELKIN 1
+#define __enabled_CONFIG_HID_BELKIN 1
+#define __enabled_CONFIG_HID_BELKIN_MODULE 0
+#define __enabled_CONFIG_ROMFS_BACKED_BY_BLOCK 0
+#define __enabled_CONFIG_ROMFS_BACKED_BY_BLOCK_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_862 0
+#define __enabled_CONFIG_NLS_CODEPAGE_862_MODULE 0
+#define __enabled_CONFIG_NFSD 0
+#define __enabled_CONFIG_NFSD_MODULE 0
+#define __enabled_CONFIG_HID_ACRUX 0
+#define __enabled_CONFIG_HID_ACRUX_MODULE 0
+#define CONFIG_RD_LZMA 1
+#define __enabled_CONFIG_RD_LZMA 1
+#define __enabled_CONFIG_RD_LZMA_MODULE 0
+#define __enabled_CONFIG_BACKTRACE_SELF_TEST 0
+#define __enabled_CONFIG_BACKTRACE_SELF_TEST_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SALSA20 0
+#define __enabled_CONFIG_CRYPTO_SALSA20_MODULE 0
+#define CONFIG_USB 1
+#define __enabled_CONFIG_USB 1
+#define __enabled_CONFIG_USB_MODULE 0
+#define __enabled_CONFIG_I2C_XILINX 0
+#define __enabled_CONFIG_I2C_XILINX_MODULE 0
+#define __enabled_CONFIG_CRYPTO_HMAC 0
+#define __enabled_CONFIG_CRYPTO_HMAC_MODULE 0
+#define __enabled_CONFIG_S3C2410_DMA 0
+#define __enabled_CONFIG_S3C2410_DMA_MODULE 0
+#define CONFIG_FRAMEBUFFER_CONSOLE_ROTATION 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE_ROTATION 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE_ROTATION_MODULE 0
+#define __enabled_CONFIG_USB_OHCI_BIG_ENDIAN_MMIO 0
+#define __enabled_CONFIG_USB_OHCI_BIG_ENDIAN_MMIO_MODULE 0
+#define __enabled_CONFIG_ARCH_MV78XX0 0
+#define __enabled_CONFIG_ARCH_MV78XX0_MODULE 0
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define __enabled_CONFIG_BRANCH_PROFILE_NONE 1
+#define __enabled_CONFIG_BRANCH_PROFILE_NONE_MODULE 0
+#define CONFIG_CRC_ITU_T 1
+#define __enabled_CONFIG_CRC_ITU_T 1
+#define __enabled_CONFIG_CRC_ITU_T_MODULE 0
+#define __enabled_CONFIG_YAFFS_DOES_ECC 0
+#define __enabled_CONFIG_YAFFS_DOES_ECC_MODULE 0
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE 1
+#define __enabled_CONFIG_FRAMEBUFFER_CONSOLE_MODULE 0
+#define __enabled_CONFIG_ARCH_MMP 0
+#define __enabled_CONFIG_ARCH_MMP_MODULE 0
+#define __enabled_CONFIG_GPIO_74X164 0
+#define __enabled_CONFIG_GPIO_74X164_MODULE 0
+#define __enabled_CONFIG_IP_NF_ARPTABLES 0
+#define __enabled_CONFIG_IP_NF_ARPTABLES_MODULE 0
+#define CONFIG_HID_CHERRY 1
+#define __enabled_CONFIG_HID_CHERRY 1
+#define __enabled_CONFIG_HID_CHERRY_MODULE 0
+#define __enabled_CONFIG_ACCESSIBILITY 0
+#define __enabled_CONFIG_ACCESSIBILITY_MODULE 0
+#define CONFIG_HID_SUNPLUS 1
+#define __enabled_CONFIG_HID_SUNPLUS 1
+#define __enabled_CONFIG_HID_SUNPLUS_MODULE 0
+#define __enabled_CONFIG_HID_PICOLCD 0
+#define __enabled_CONFIG_HID_PICOLCD_MODULE 0
+#define CONFIG_BCMA_POSSIBLE 1
+#define __enabled_CONFIG_BCMA_POSSIBLE 1
+#define __enabled_CONFIG_BCMA_POSSIBLE_MODULE 0
+#define __enabled_CONFIG_LEDS_LP5521 0
+#define __enabled_CONFIG_LEDS_LP5521_MODULE 0
+#define __enabled_CONFIG_AF_RXRPC 0
+#define __enabled_CONFIG_AF_RXRPC_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CAST5 0
+#define __enabled_CONFIG_CRYPTO_CAST5_MODULE 0
+#define CONFIG_FORCE_MAX_ZONEORDER 11
+#define __enabled_CONFIG_DEBUG_LOCK_ALLOC 0
+#define __enabled_CONFIG_DEBUG_LOCK_ALLOC_MODULE 0
+#define __enabled_CONFIG_NET_IPGRE_DEMUX 0
+#define __enabled_CONFIG_NET_IPGRE_DEMUX_MODULE 0
+#define __enabled_CONFIG_NET_POLL_CONTROLLER 0
+#define __enabled_CONFIG_NET_POLL_CONTROLLER_MODULE 0
+#define CONFIG_PRINTK 1
+#define __enabled_CONFIG_PRINTK 1
+#define __enabled_CONFIG_PRINTK_MODULE 0
+#define __enabled_CONFIG_HTC_I2CPLD 0
+#define __enabled_CONFIG_HTC_I2CPLD_MODULE 0
+#define __enabled_CONFIG_ARCH_PRIMA2 0
+#define __enabled_CONFIG_ARCH_PRIMA2_MODULE 0
+#define __enabled_CONFIG_FB_SYS_FILLRECT 0
+#define __enabled_CONFIG_FB_SYS_FILLRECT_MODULE 0
+#define CONFIG_TIMERFD 1
+#define __enabled_CONFIG_TIMERFD 1
+#define __enabled_CONFIG_TIMERFD_MODULE 0
+#define __enabled_CONFIG_HID_THRUSTMASTER 0
+#define __enabled_CONFIG_HID_THRUSTMASTER_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_TRYLOCK 0
+#define __enabled_CONFIG_INLINE_READ_TRYLOCK_MODULE 0
+#define __enabled_CONFIG_USB_DYNAMIC_MINORS 0
+#define __enabled_CONFIG_USB_DYNAMIC_MINORS_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX16065 0
+#define __enabled_CONFIG_SENSORS_MAX16065_MODULE 0
+#define CONFIG_DNS_RESOLVER 1
+#define __enabled_CONFIG_DNS_RESOLVER 1
+#define __enabled_CONFIG_DNS_RESOLVER_MODULE 0
+#define __enabled_CONFIG_FB_S3C2410_DEBUG 0
+#define __enabled_CONFIG_FB_S3C2410_DEBUG_MODULE 0
+#define CONFIG_MTD_CFI_I2 1
+#define __enabled_CONFIG_MTD_CFI_I2 1
+#define __enabled_CONFIG_MTD_CFI_I2_MODULE 0
+#define __enabled_CONFIG_CRYPTO_AUTHENC 0
+#define __enabled_CONFIG_CRYPTO_AUTHENC_MODULE 0
+#define __enabled_CONFIG_USB_GPIO_VBUS 0
+#define __enabled_CONFIG_USB_GPIO_VBUS_MODULE 0
+#define __enabled_CONFIG_IRDA 0
+#define __enabled_CONFIG_IRDA_MODULE 0
+#define CONFIG_SHMEM 1
+#define __enabled_CONFIG_SHMEM 1
+#define __enabled_CONFIG_SHMEM_MODULE 0
+#define CONFIG_MTD 1
+#define __enabled_CONFIG_MTD 1
+#define __enabled_CONFIG_MTD_MODULE 0
+#define __enabled_CONFIG_MACH_SMDK2416 0
+#define __enabled_CONFIG_MACH_SMDK2416_MODULE 0
+#define CONFIG_MMC_BLOCK_MINORS 8
+#define CONFIG_DECOMPRESS_LZMA 1
+#define __enabled_CONFIG_DECOMPRESS_LZMA 1
+#define __enabled_CONFIG_DECOMPRESS_LZMA_MODULE 0
+#define __enabled_CONFIG_SENSORS_AMC6821 0
+#define __enabled_CONFIG_SENSORS_AMC6821_MODULE 0
+#define __enabled_CONFIG_USB_IPHETH 0
+#define __enabled_CONFIG_USB_IPHETH_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_850 0
+#define __enabled_CONFIG_NLS_CODEPAGE_850_MODULE 0
+#define CONFIG_DNOTIFY 1
+#define __enabled_CONFIG_DNOTIFY 1
+#define __enabled_CONFIG_DNOTIFY_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CTS 0
+#define __enabled_CONFIG_CRYPTO_CTS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_R9701 0
+#define __enabled_CONFIG_RTC_DRV_R9701_MODULE 0
+#define CONFIG_INPUT_MOUSEDEV 1
+#define __enabled_CONFIG_INPUT_MOUSEDEV 1
+#define __enabled_CONFIG_INPUT_MOUSEDEV_MODULE 0
+#define __enabled_CONFIG_USB_ISP1362_HCD 0
+#define __enabled_CONFIG_USB_ISP1362_HCD_MODULE 0
+#define __enabled_CONFIG_ATA 0
+#define __enabled_CONFIG_ATA_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_SUNKBD 0
+#define __enabled_CONFIG_KEYBOARD_SUNKBD_MODULE 0
+#define __enabled_CONFIG_MTD_TESTS 0
+#define __enabled_CONFIG_MTD_TESTS_MODULE 0
+#define __enabled_CONFIG_MFD_WM8994 0
+#define __enabled_CONFIG_MFD_WM8994_MODULE 0
+#define __enabled_CONFIG_CRYPTO_DES 0
+#define __enabled_CONFIG_CRYPTO_DES_MODULE 0
+#define __enabled_CONFIG_ENABLE_MUST_CHECK 0
+#define __enabled_CONFIG_ENABLE_MUST_CHECK_MODULE 0
+#define __enabled_CONFIG_CEPH_LIB 0
+#define __enabled_CONFIG_CEPH_LIB_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_437 0
+#define __enabled_CONFIG_NLS_CODEPAGE_437_MODULE 0
+#define CONFIG_MTD_NAND_IDS 1
+#define __enabled_CONFIG_MTD_NAND_IDS 1
+#define __enabled_CONFIG_MTD_NAND_IDS_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_PENMOUNT 0
+#define __enabled_CONFIG_TOUCHSCREEN_PENMOUNT_MODULE 0
+#define __enabled_CONFIG_SLUB_DEBUG_ON 0
+#define __enabled_CONFIG_SLUB_DEBUG_ON_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX1619 0
+#define __enabled_CONFIG_SENSORS_MAX1619_MODULE 0
+#define CONFIG_SERIO 1
+#define __enabled_CONFIG_SERIO 1
+#define __enabled_CONFIG_SERIO_MODULE 0
+#define __enabled_CONFIG_SCHEDSTATS 0
+#define __enabled_CONFIG_SCHEDSTATS_MODULE 0
+#define CONFIG_INPUT_MOUSE 1
+#define __enabled_CONFIG_INPUT_MOUSE 1
+#define __enabled_CONFIG_INPUT_MOUSE_MODULE 0
+#define __enabled_CONFIG_FB_SYS_IMAGEBLIT 0
+#define __enabled_CONFIG_FB_SYS_IMAGEBLIT_MODULE 0
+#define CONFIG_SUNRPC_GSS 1
+#define __enabled_CONFIG_SUNRPC_GSS 1
+#define __enabled_CONFIG_SUNRPC_GSS_MODULE 0
+#define CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
+#define __enabled_CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
+#define __enabled_CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM90 0
+#define __enabled_CONFIG_SENSORS_LM90_MODULE 0
+#define __enabled_CONFIG_NETCONSOLE 0
+#define __enabled_CONFIG_NETCONSOLE_MODULE 0
+#define CONFIG_RTC_INTF_SYSFS 1
+#define __enabled_CONFIG_RTC_INTF_SYSFS 1
+#define __enabled_CONFIG_RTC_INTF_SYSFS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RS5C372 0
+#define __enabled_CONFIG_RTC_DRV_RS5C372_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHWIN 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE 0
+#define CONFIG_BLK_DEV_INITRD 1
+#define __enabled_CONFIG_BLK_DEV_INITRD 1
+#define __enabled_CONFIG_BLK_DEV_INITRD_MODULE 0
+#define __enabled_CONFIG_USB_EMI62 0
+#define __enabled_CONFIG_USB_EMI62_MODULE 0
+#define CONFIG_LEDS_TRIGGER_TIMER 1
+#define __enabled_CONFIG_LEDS_TRIGGER_TIMER 1
+#define __enabled_CONFIG_LEDS_TRIGGER_TIMER_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M48T59 0
+#define __enabled_CONFIG_RTC_DRV_M48T59_MODULE 0
+#define CONFIG_MTD_NAND_PLATFORM 1
+#define __enabled_CONFIG_MTD_NAND_PLATFORM 1
+#define __enabled_CONFIG_MTD_NAND_PLATFORM_MODULE 0
+#define __enabled_CONFIG_GPIO_PCF857X 0
+#define __enabled_CONFIG_GPIO_PCF857X_MODULE 0
+#define __enabled_CONFIG_SPI_XILINX 0
+#define __enabled_CONFIG_SPI_XILINX_MODULE 0
+#define CONFIG_ZLIB_INFLATE 1
+#define __enabled_CONFIG_ZLIB_INFLATE 1
+#define __enabled_CONFIG_ZLIB_INFLATE_MODULE 0
+#define __enabled_CONFIG_USB_FUNCTIONFS 0
+#define __enabled_CONFIG_USB_FUNCTIONFS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_V3020 0
+#define __enabled_CONFIG_RTC_DRV_V3020_MODULE 0
+#define CONFIG_CRC_T10DIF 1
+#define __enabled_CONFIG_CRC_T10DIF 1
+#define __enabled_CONFIG_CRC_T10DIF_MODULE 0
+#define __enabled_CONFIG_DEBUG_LL 0
+#define __enabled_CONFIG_DEBUG_LL_MODULE 0
+#define __enabled_CONFIG_LCD_LMS283GF05 0
+#define __enabled_CONFIG_LCD_LMS283GF05_MODULE 0
+#define CONFIG_HWMON 1
+#define __enabled_CONFIG_HWMON 1
+#define __enabled_CONFIG_HWMON_MODULE 0
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define __enabled_CONFIG_LOGO_LINUX_CLUT224 1
+#define __enabled_CONFIG_LOGO_LINUX_CLUT224_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_2 0
+#define __enabled_CONFIG_NLS_ISO8859_2_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM63 0
+#define __enabled_CONFIG_SENSORS_LM63_MODULE 0
+#define CONFIG_IP_PNP 1
+#define __enabled_CONFIG_IP_PNP 1
+#define __enabled_CONFIG_IP_PNP_MODULE 0
+#define CONFIG_LEDS_S3C24XX 1
+#define __enabled_CONFIG_LEDS_S3C24XX 1
+#define __enabled_CONFIG_LEDS_S3C24XX_MODULE 0
+#define CONFIG_RTC_INTF_PROC 1
+#define __enabled_CONFIG_RTC_INTF_PROC 1
+#define __enabled_CONFIG_RTC_INTF_PROC_MODULE 0
+#define CONFIG_PM_CLK 1
+#define __enabled_CONFIG_PM_CLK 1
+#define __enabled_CONFIG_PM_CLK_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SERPENT 0
+#define __enabled_CONFIG_CRYPTO_SERPENT_MODULE 0
+#define __enabled_CONFIG_MOUSE_PS2_SENTELIC 0
+#define __enabled_CONFIG_MOUSE_PS2_SENTELIC_MODULE 0
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define __enabled_CONFIG_STACKTRACE_SUPPORT 1
+#define __enabled_CONFIG_STACKTRACE_SUPPORT_MODULE 0
+#define __enabled_CONFIG_SERIAL_MAX3100 0
+#define __enabled_CONFIG_SERIAL_MAX3100_MODULE 0
+#define __enabled_CONFIG_MTD_CFI_I8 0
+#define __enabled_CONFIG_MTD_CFI_I8_MODULE 0
+#define __enabled_CONFIG_SENSORS_EMC1403 0
+#define __enabled_CONFIG_SENSORS_EMC1403_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR_MODULE 0
+#define __enabled_CONFIG_MACH_JIVE 0
+#define __enabled_CONFIG_MACH_JIVE_MODULE 0
+#define __enabled_CONFIG_RCU_TRACE 0
+#define __enabled_CONFIG_RCU_TRACE_MODULE 0
+#define __enabled_CONFIG_SENSORS_SHT15 0
+#define __enabled_CONFIG_SENSORS_SHT15_MODULE 0
+#define __enabled_CONFIG_USB_DEVICE_CLASS 0
+#define __enabled_CONFIG_USB_DEVICE_CLASS_MODULE 0
+#define CONFIG_LOCKD 1
+#define __enabled_CONFIG_LOCKD 1
+#define __enabled_CONFIG_LOCKD_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS3234 0
+#define __enabled_CONFIG_RTC_DRV_DS3234_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_COW_COMMON 0
+#define __enabled_CONFIG_BLK_DEV_COW_COMMON_MODULE 0
+#define __enabled_CONFIG_MTD_IMPA7 0
+#define __enabled_CONFIG_MTD_IMPA7_MODULE 0
+#define CONFIG_ARM 1
+#define __enabled_CONFIG_ARM 1
+#define __enabled_CONFIG_ARM_MODULE 0
+#define __enabled_CONFIG_LATENCYTOP 0
+#define __enabled_CONFIG_LATENCYTOP_MODULE 0
+#define __enabled_CONFIG_JFFS2_FS 0
+#define __enabled_CONFIG_JFFS2_FS_MODULE 0
+#define CONFIG_ARM_L1_CACHE_SHIFT 5
+#define CONFIG_VIDEO_OUTPUT_CONTROL 1
+#define __enabled_CONFIG_VIDEO_OUTPUT_CONTROL 1
+#define __enabled_CONFIG_VIDEO_OUTPUT_CONTROL_MODULE 0
+#define __enabled_CONFIG_ARCH_CLPS711X 0
+#define __enabled_CONFIG_ARCH_CLPS711X_MODULE 0
+#define __enabled_CONFIG_USB_G_NCM 0
+#define __enabled_CONFIG_USB_G_NCM_MODULE 0
+#define __enabled_CONFIG_I2C_DESIGNWARE 0
+#define __enabled_CONFIG_I2C_DESIGNWARE_MODULE 0
+#define CONFIG_MTD_CFI_UTIL 1
+#define __enabled_CONFIG_MTD_CFI_UTIL 1
+#define __enabled_CONFIG_MTD_CFI_UTIL_MODULE 0
+#define __enabled_CONFIG_SENSORS_PCF8591 0
+#define __enabled_CONFIG_SENSORS_PCF8591_MODULE 0
+#define CONFIG_DISPLAY_SUPPORT 1
+#define __enabled_CONFIG_DISPLAY_SUPPORT 1
+#define __enabled_CONFIG_DISPLAY_SUPPORT_MODULE 0
+#define CONFIG_CPU_TLB_V4WBI 1
+#define __enabled_CONFIG_CPU_TLB_V4WBI 1
+#define __enabled_CONFIG_CPU_TLB_V4WBI_MODULE 0
+#define __enabled_CONFIG_ARCH_IOP33X 0
+#define __enabled_CONFIG_ARCH_IOP33X_MODULE 0
+#define __enabled_CONFIG_ARCH_U300 0
+#define __enabled_CONFIG_ARCH_U300_MODULE 0
+#define __enabled_CONFIG_RAMOOPS 0
+#define __enabled_CONFIG_RAMOOPS_MODULE 0
+#define __enabled_CONFIG_BSD_PROCESS_ACCT 0
+#define __enabled_CONFIG_BSD_PROCESS_ACCT_MODULE 0
+#define __enabled_CONFIG_INPUT_TABLET 0
+#define __enabled_CONFIG_INPUT_TABLET_MODULE 0
+#define __enabled_CONFIG_MTD_CFI_INTELEXT 0
+#define __enabled_CONFIG_MTD_CFI_INTELEXT_MODULE 0
+#define __enabled_CONFIG_LLC2 0
+#define __enabled_CONFIG_LLC2_MODULE 0
+#define CONFIG_LOGO 1
+#define __enabled_CONFIG_LOGO 1
+#define __enabled_CONFIG_LOGO_MODULE 0
+#define __enabled_CONFIG_DLM 0
+#define __enabled_CONFIG_DLM_MODULE 0
+#define CONFIG_CPU_COPY_V4WB 1
+#define __enabled_CONFIG_CPU_COPY_V4WB 1
+#define __enabled_CONFIG_CPU_COPY_V4WB_MODULE 0
+#define __enabled_CONFIG_IPMI_PANIC_EVENT 0
+#define __enabled_CONFIG_IPMI_PANIC_EVENT_MODULE 0
+#define CONFIG_STANDALONE 1
+#define __enabled_CONFIG_STANDALONE 1
+#define __enabled_CONFIG_STANDALONE_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SEED 0
+#define __enabled_CONFIG_CRYPTO_SEED_MODULE 0
+#define __enabled_CONFIG_I2C_MUX 0
+#define __enabled_CONFIG_I2C_MUX_MODULE 0
+#define __enabled_CONFIG_S3C_BOOT_ERROR_RESET 0
+#define __enabled_CONFIG_S3C_BOOT_ERROR_RESET_MODULE 0
+#define CONFIG_SERIAL_S3C2440 1
+#define __enabled_CONFIG_SERIAL_S3C2440 1
+#define __enabled_CONFIG_SERIAL_S3C2440_MODULE 0
+#define __enabled_CONFIG_WATCHDOG_CORE 0
+#define __enabled_CONFIG_WATCHDOG_CORE_MODULE 0
+#define CONFIG_ARCH_HAS_CPUFREQ 1
+#define __enabled_CONFIG_ARCH_HAS_CPUFREQ 1
+#define __enabled_CONFIG_ARCH_HAS_CPUFREQ_MODULE 0
+#define __enabled_CONFIG_LCD_AMS369FG06 0
+#define __enabled_CONFIG_LCD_AMS369FG06_MODULE 0
+#define __enabled_CONFIG_X25 0
+#define __enabled_CONFIG_X25_MODULE 0
+#define __enabled_CONFIG_IEEE802154 0
+#define __enabled_CONFIG_IEEE802154_MODULE 0
+#define CONFIG_BLOCK 1
+#define __enabled_CONFIG_BLOCK 1
+#define __enabled_CONFIG_BLOCK_MODULE 0
+#define CONFIG_HAVE_IDE 1
+#define __enabled_CONFIG_HAVE_IDE 1
+#define __enabled_CONFIG_HAVE_IDE_MODULE 0
+#define CONFIG_HID_APPLE 1
+#define __enabled_CONFIG_HID_APPLE 1
+#define __enabled_CONFIG_HID_APPLE_MODULE 0
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define __enabled_CONFIG_USB_WUSB 0
+#define __enabled_CONFIG_USB_WUSB_MODULE 0
+#define __enabled_CONFIG_SENSORS_G760A 0
+#define __enabled_CONFIG_SENSORS_G760A_MODULE 0
+#define __enabled_CONFIG_RDS 0
+#define __enabled_CONFIG_RDS_MODULE 0
+#define CONFIG_GENERIC_GPIO 1
+#define __enabled_CONFIG_GENERIC_GPIO 1
+#define __enabled_CONFIG_GENERIC_GPIO_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_BH 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_BH_MODULE 0
+#define CONFIG_ROOT_NFS 1
+#define __enabled_CONFIG_ROOT_NFS 1
+#define __enabled_CONFIG_ROOT_NFS_MODULE 0
+#define __enabled_CONFIG_LKDTM 0
+#define __enabled_CONFIG_LKDTM_MODULE 0
+#define CONFIG_USER_NS 1
+#define __enabled_CONFIG_USER_NS 1
+#define __enabled_CONFIG_USER_NS_MODULE 0
+#define __enabled_CONFIG_HFSPLUS_FS 0
+#define __enabled_CONFIG_HFSPLUS_FS_MODULE 0
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define __enabled_CONFIG_TMPFS_POSIX_ACL 1
+#define __enabled_CONFIG_TMPFS_POSIX_ACL_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADM9240 0
+#define __enabled_CONFIG_SENSORS_ADM9240_MODULE 0
+#define CONFIG_BUG 1
+#define __enabled_CONFIG_BUG 1
+#define __enabled_CONFIG_BUG_MODULE 0
+#define __enabled_CONFIG_USB_SL811_HCD 0
+#define __enabled_CONFIG_USB_SL811_HCD_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CAST6 0
+#define __enabled_CONFIG_CRYPTO_CAST6_MODULE 0
+#define __enabled_CONFIG_PANTHERLORD_FF 0
+#define __enabled_CONFIG_PANTHERLORD_FF_MODULE 0
+#define __enabled_CONFIG_I2C_DIOLAN_U2C 0
+#define __enabled_CONFIG_I2C_DIOLAN_U2C_MODULE 0
+#define CONFIG_PM 1
+#define __enabled_CONFIG_PM 1
+#define __enabled_CONFIG_PM_MODULE 0
+#define __enabled_CONFIG_PPS 0
+#define __enabled_CONFIG_PPS_MODULE 0
+#define __enabled_CONFIG_USB_LCD 0
+#define __enabled_CONFIG_USB_LCD_MODULE 0
+#define CONFIG_SPI 1
+#define __enabled_CONFIG_SPI 1
+#define __enabled_CONFIG_SPI_MODULE 0
+#define __enabled_CONFIG_SENSORS_DS620 0
+#define __enabled_CONFIG_SENSORS_DS620_MODULE 0
+#define __enabled_CONFIG_MFD_TPS65912_SPI 0
+#define __enabled_CONFIG_MFD_TPS65912_SPI_MODULE 0
+#define CONFIG_MINI2440_BUTTONS 1
+#define __enabled_CONFIG_MINI2440_BUTTONS 1
+#define __enabled_CONFIG_MINI2440_BUTTONS_MODULE 0
+#define __enabled_CONFIG_SENSORS_GPIO_FAN 0
+#define __enabled_CONFIG_SENSORS_GPIO_FAN_MODULE 0
+#define __enabled_CONFIG_ARCH_MXC 0
+#define __enabled_CONFIG_ARCH_MXC_MODULE 0
+#define __enabled_CONFIG_MTD_REDBOOT_PARTS 0
+#define __enabled_CONFIG_MTD_REDBOOT_PARTS_MODULE 0
+#define CONFIG_DEVKMEM 1
+#define __enabled_CONFIG_DEVKMEM 1
+#define __enabled_CONFIG_DEVKMEM_MODULE 0
+#define __enabled_CONFIG_NFS_USE_NEW_IDMAPPER 0
+#define __enabled_CONFIG_NFS_USE_NEW_IDMAPPER_MODULE 0
+#define CONFIG_STRIP_ASM_SYMS 1
+#define __enabled_CONFIG_STRIP_ASM_SYMS 1
+#define __enabled_CONFIG_STRIP_ASM_SYMS_MODULE 0
+#define CONFIG_VT 1
+#define __enabled_CONFIG_VT 1
+#define __enabled_CONFIG_VT_MODULE 0
+#define __enabled_CONFIG_SENSORS_F71805F 0
+#define __enabled_CONFIG_SENSORS_F71805F_MODULE 0
+#define __enabled_CONFIG_DEBUG_BLOCK_EXT_DEVT 0
+#define __enabled_CONFIG_DEBUG_BLOCK_EXT_DEVT_MODULE 0
+#define CONFIG_SPLIT_PTLOCK_CPUS 999999
+#define __enabled_CONFIG_USB_R8A66597 0
+#define __enabled_CONFIG_USB_R8A66597_MODULE 0
+#define __enabled_CONFIG_POWER_SUPPLY 0
+#define __enabled_CONFIG_POWER_SUPPLY_MODULE 0
+#define __enabled_CONFIG_I2C_PCA_PLATFORM 0
+#define __enabled_CONFIG_I2C_PCA_PLATFORM_MODULE 0
+#define CONFIG_GENERIC_IRQ_CHIP 1
+#define __enabled_CONFIG_GENERIC_IRQ_CHIP 1
+#define __enabled_CONFIG_GENERIC_IRQ_CHIP_MODULE 0
+#define CONFIG_NLS 1
+#define __enabled_CONFIG_NLS 1
+#define __enabled_CONFIG_NLS_MODULE 0
+#define __enabled_CONFIG_SCHED_AUTOGROUP 0
+#define __enabled_CONFIG_SCHED_AUTOGROUP_MODULE 0
+#define CONFIG_SPI_SPIDEV 1
+#define __enabled_CONFIG_SPI_SPIDEV 1
+#define __enabled_CONFIG_SPI_SPIDEV_MODULE 0
+#define __enabled_CONFIG_ARCH_INTEGRATOR 0
+#define __enabled_CONFIG_ARCH_INTEGRATOR_MODULE 0
+#define __enabled_CONFIG_MACH_VR1000 0
+#define __enabled_CONFIG_MACH_VR1000_MODULE 0
+#define __enabled_CONFIG_I2C_GPIO 0
+#define __enabled_CONFIG_I2C_GPIO_MODULE 0
+#define CONFIG_MFD_SUPPORT 1
+#define __enabled_CONFIG_MFD_SUPPORT 1
+#define __enabled_CONFIG_MFD_SUPPORT_MODULE 0
+#define __enabled_CONFIG_XFRM_MIGRATE 0
+#define __enabled_CONFIG_XFRM_MIGRATE_MODULE 0
+#define __enabled_CONFIG_USB_LEGOTOWER 0
+#define __enabled_CONFIG_USB_LEGOTOWER_MODULE 0
+#define __enabled_CONFIG_MTD_DATAFLASH 0
+#define __enabled_CONFIG_MTD_DATAFLASH_MODULE 0
+#define __enabled_CONFIG_ARCH_AT91 0
+#define __enabled_CONFIG_ARCH_AT91_MODULE 0
+#define __enabled_CONFIG_MTD_ALAUDA 0
+#define __enabled_CONFIG_MTD_ALAUDA_MODULE 0
+#define __enabled_CONFIG_SUN_PARTITION 0
+#define __enabled_CONFIG_SUN_PARTITION_MODULE 0
+#define CONFIG_SYN_COOKIES 1
+#define __enabled_CONFIG_SYN_COOKIES 1
+#define __enabled_CONFIG_SYN_COOKIES_MODULE 0
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define __enabled_CONFIG_IP_ADVANCED_ROUTER 1
+#define __enabled_CONFIG_IP_ADVANCED_ROUTER_MODULE 0
+#define __enabled_CONFIG_ENABLE_WARN_DEPRECATED 0
+#define __enabled_CONFIG_ENABLE_WARN_DEPRECATED_MODULE 0
+#define __enabled_CONFIG_FB_SYS_COPYAREA 0
+#define __enabled_CONFIG_FB_SYS_COPYAREA_MODULE 0
+#define __enabled_CONFIG_CLEANCACHE 0
+#define __enabled_CONFIG_CLEANCACHE_MODULE 0
+#define CONFIG_SPI_BITBANG 1
+#define __enabled_CONFIG_SPI_BITBANG 1
+#define __enabled_CONFIG_SPI_BITBANG_MODULE 0
+#define __enabled_CONFIG_PROFILE_ALL_BRANCHES 0
+#define __enabled_CONFIG_PROFILE_ALL_BRANCHES_MODULE 0
+#define __enabled_CONFIG_FONT_6x11 0
+#define __enabled_CONFIG_FONT_6x11_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADM1031 0
+#define __enabled_CONFIG_SENSORS_ADM1031_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_MUSEUM_IDS 0
+#define __enabled_CONFIG_MTD_NAND_MUSEUM_IDS_MODULE 0
+#define __enabled_CONFIG_MFD_MAX8998 0
+#define __enabled_CONFIG_MFD_MAX8998_MODULE 0
+#define __enabled_CONFIG_MACH_AT2440EVB 0
+#define __enabled_CONFIG_MACH_AT2440EVB_MODULE 0
+#define __enabled_CONFIG_INET_IPCOMP 0
+#define __enabled_CONFIG_INET_IPCOMP_MODULE 0
+#define __enabled_CONFIG_KERNEL_LZMA 0
+#define __enabled_CONFIG_KERNEL_LZMA_MODULE 0
+#define __enabled_CONFIG_ARCH_S3C64XX 0
+#define __enabled_CONFIG_ARCH_S3C64XX_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_FUJITSU 0
+#define __enabled_CONFIG_TOUCHSCREEN_FUJITSU_MODULE 0
+#define __enabled_CONFIG_MMC_SDHCI_PXAV2 0
+#define __enabled_CONFIG_MMC_SDHCI_PXAV2_MODULE 0
+#define CONFIG_CPU_S3C2440 1
+#define __enabled_CONFIG_CPU_S3C2440 1
+#define __enabled_CONFIG_CPU_S3C2440_MODULE 0
+#define __enabled_CONFIG_DEBUG_SG 0
+#define __enabled_CONFIG_DEBUG_SG_MODULE 0
+#define __enabled_CONFIG_HID_KEYTOUCH 0
+#define __enabled_CONFIG_HID_KEYTOUCH_MODULE 0
+#define CONFIG_HID_CYPRESS 1
+#define __enabled_CONFIG_HID_CYPRESS 1
+#define __enabled_CONFIG_HID_CYPRESS_MODULE 0
+#define __enabled_CONFIG_N_GSM 0
+#define __enabled_CONFIG_N_GSM_MODULE 0
+#define __enabled_CONFIG_TRACE_SINK 0
+#define __enabled_CONFIG_TRACE_SINK_MODULE 0
+#define __enabled_CONFIG_SYSFS_DEPRECATED 0
+#define __enabled_CONFIG_SYSFS_DEPRECATED_MODULE 0
+#define __enabled_CONFIG_ATA_OVER_ETH 0
+#define __enabled_CONFIG_ATA_OVER_ETH_MODULE 0
+#define __enabled_CONFIG_HTC_EGPIO 0
+#define __enabled_CONFIG_HTC_EGPIO_MODULE 0
+#define __enabled_CONFIG_MFD_WM831X_SPI 0
+#define __enabled_CONFIG_MFD_WM831X_SPI_MODULE 0
+#define __enabled_CONFIG_PREEMPT_VOLUNTARY 0
+#define __enabled_CONFIG_PREEMPT_VOLUNTARY_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_1 0
+#define __enabled_CONFIG_NLS_ISO8859_1_MODULE 0
+#define __enabled_CONFIG_MFD_WM8400 0
+#define __enabled_CONFIG_MFD_WM8400_MODULE 0
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define __enabled_CONFIG_CRYPTO_WORKQUEUE 1
+#define __enabled_CONFIG_CRYPTO_WORKQUEUE_MODULE 0
+#define __enabled_CONFIG_NFC 0
+#define __enabled_CONFIG_NFC_MODULE 0
+#define __enabled_CONFIG_ATOMIC64_SELFTEST 0
+#define __enabled_CONFIG_ATOMIC64_SELFTEST_MODULE 0
+#define CONFIG_HID_KENSINGTON 1
+#define __enabled_CONFIG_HID_KENSINGTON 1
+#define __enabled_CONFIG_HID_KENSINGTON_MODULE 0
+#define __enabled_CONFIG_BACKLIGHT_GENERIC 0
+#define __enabled_CONFIG_BACKLIGHT_GENERIC_MODULE 0
+#define __enabled_CONFIG_HID_ZYDACRON 0
+#define __enabled_CONFIG_HID_ZYDACRON_MODULE 0
+#define __enabled_CONFIG_RFKILL 0
+#define __enabled_CONFIG_RFKILL_MODULE 0
+#define CONFIG_NETDEVICES 1
+#define __enabled_CONFIG_NETDEVICES 1
+#define __enabled_CONFIG_NETDEVICES_MODULE 0
+#define __enabled_CONFIG_ARCH_ORION5X 0
+#define __enabled_CONFIG_ARCH_ORION5X_MODULE 0
+#define CONFIG_NET_KEY_MODULE 1
+#define __enabled_CONFIG_NET_KEY 0
+#define __enabled_CONFIG_NET_KEY_MODULE 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define __enabled_CONFIG_IOSCHED_DEADLINE 1
+#define __enabled_CONFIG_IOSCHED_DEADLINE_MODULE 0
+#define __enabled_CONFIG_SERIAL_ALTERA_JTAGUART 0
+#define __enabled_CONFIG_SERIAL_ALTERA_JTAGUART_MODULE 0
+#define CONFIG_EVENTFD 1
+#define __enabled_CONFIG_EVENTFD 1
+#define __enabled_CONFIG_EVENTFD_MODULE 0
+#define __enabled_CONFIG_SPI_DESIGNWARE 0
+#define __enabled_CONFIG_SPI_DESIGNWARE_MODULE 0
+#define __enabled_CONFIG_WAN 0
+#define __enabled_CONFIG_WAN_MODULE 0
+#define CONFIG_FS_POSIX_ACL 1
+#define __enabled_CONFIG_FS_POSIX_ACL 1
+#define __enabled_CONFIG_FS_POSIX_ACL_MODULE 0
+#define CONFIG_XFRM 1
+#define __enabled_CONFIG_XFRM 1
+#define __enabled_CONFIG_XFRM_MODULE 0
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define __enabled_CONFIG_USB_ANNOUNCE_NEW_DEVICES 0
+#define __enabled_CONFIG_USB_ANNOUNCE_NEW_DEVICES_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_QT1070 0
+#define __enabled_CONFIG_KEYBOARD_QT1070_MODULE 0
+#define __enabled_CONFIG_USB_NET2272 0
+#define __enabled_CONFIG_USB_NET2272_MODULE 0
+#define __enabled_CONFIG_MFD_AAT2870_CORE 0
+#define __enabled_CONFIG_MFD_AAT2870_CORE_MODULE 0
+#define __enabled_CONFIG_WAN_ROUTER 0
+#define __enabled_CONFIG_WAN_ROUTER_MODULE 0
+#define __enabled_CONFIG_ECRYPT_FS 0
+#define __enabled_CONFIG_ECRYPT_FS_MODULE 0
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define __enabled_CONFIG_PROC_PAGE_MONITOR 1
+#define __enabled_CONFIG_PROC_PAGE_MONITOR_MODULE 0
+#define __enabled_CONFIG_CC_OPTIMIZE_FOR_SIZE 0
+#define __enabled_CONFIG_CC_OPTIMIZE_FOR_SIZE_MODULE 0
+#define CONFIG_FTL 1
+#define __enabled_CONFIG_FTL 1
+#define __enabled_CONFIG_FTL_MODULE 0
+#define CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
+#define __enabled_CONFIG_IPMI_DEVICE_INTERFACE 0
+#define __enabled_CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
+#define __enabled_CONFIG_SENSORS_ADM1021 0
+#define __enabled_CONFIG_SENSORS_ADM1021_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_IRQSAVE 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_IRQSAVE_MODULE 0
+#define __enabled_CONFIG_USB_FTDI_ELAN 0
+#define __enabled_CONFIG_USB_FTDI_ELAN_MODULE 0
+#define __enabled_CONFIG_DEBUG_GPIO 0
+#define __enabled_CONFIG_DEBUG_GPIO_MODULE 0
+#define CONFIG_RD_LZO 1
+#define __enabled_CONFIG_RD_LZO 1
+#define __enabled_CONFIG_RD_LZO_MODULE 0
+#define __enabled_CONFIG_PERF_COUNTERS 0
+#define __enabled_CONFIG_PERF_COUNTERS_MODULE 0
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define __enabled_CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define __enabled_CONFIG_ARCH_HAS_CPU_IDLE_WAIT_MODULE 0
+#define __enabled_CONFIG_SENSORS_SHT21 0
+#define __enabled_CONFIG_SENSORS_SHT21_MODULE 0
+#define __enabled_CONFIG_USB_IOWARRIOR 0
+#define __enabled_CONFIG_USB_IOWARRIOR_MODULE 0
+#define __enabled_CONFIG_USBPCWATCHDOG 0
+#define __enabled_CONFIG_USBPCWATCHDOG_MODULE 0
+#define __enabled_CONFIG_ARCH_DAVINCI 0
+#define __enabled_CONFIG_ARCH_DAVINCI_MODULE 0
+#define __enabled_CONFIG_ECONET 0
+#define __enabled_CONFIG_ECONET_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SHA512 0
+#define __enabled_CONFIG_CRYPTO_SHA512_MODULE 0
+#define __enabled_CONFIG_PHONET 0
+#define __enabled_CONFIG_PHONET_MODULE 0
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define __enabled_CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define __enabled_CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE 0
+#define CONFIG_CPU_CACHE_VIVT 1
+#define __enabled_CONFIG_CPU_CACHE_VIVT 1
+#define __enabled_CONFIG_CPU_CACHE_VIVT_MODULE 0
+#define __enabled_CONFIG_CRYPTO_NULL 0
+#define __enabled_CONFIG_CRYPTO_NULL_MODULE 0
+#define __enabled_CONFIG_NF_DEFRAG_IPV4 0
+#define __enabled_CONFIG_NF_DEFRAG_IPV4_MODULE 0
+#define __enabled_CONFIG_USB_IDMOUSE 0
+#define __enabled_CONFIG_USB_IDMOUSE_MODULE 0
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define __enabled_CONFIG_SELECT_MEMORY_MODEL 1
+#define __enabled_CONFIG_SELECT_MEMORY_MODEL_MODULE 0
+#define __enabled_CONFIG_INET_XFRM_MODE_BEET 0
+#define __enabled_CONFIG_INET_XFRM_MODE_BEET_MODULE 0
+#define __enabled_CONFIG_HID_LCPOWER 0
+#define __enabled_CONFIG_HID_LCPOWER_MODULE 0
+#define __enabled_CONFIG_MMC_UNSAFE_RESUME 0
+#define __enabled_CONFIG_MMC_UNSAFE_RESUME_MODULE 0
+#define CONFIG_HAVE_ARCH_PFN_VALID 1
+#define __enabled_CONFIG_HAVE_ARCH_PFN_VALID 1
+#define __enabled_CONFIG_HAVE_ARCH_PFN_VALID_MODULE 0
+#define __enabled_CONFIG_BFS_FS 0
+#define __enabled_CONFIG_BFS_FS_MODULE 0
+#define __enabled_CONFIG_PM_DEBUG 0
+#define __enabled_CONFIG_PM_DEBUG_MODULE 0
+#define CONFIG_NETFILTER_ADVANCED 1
+#define __enabled_CONFIG_NETFILTER_ADVANCED 1
+#define __enabled_CONFIG_NETFILTER_ADVANCED_MODULE 0
+#define __enabled_CONFIG_CRYPTO_DEFLATE 0
+#define __enabled_CONFIG_CRYPTO_DEFLATE_MODULE 0
+#define __enabled_CONFIG_MFD_WM8350_I2C 0
+#define __enabled_CONFIG_MFD_WM8350_I2C_MODULE 0
+#define __enabled_CONFIG_USB_APPLEDISPLAY 0
+#define __enabled_CONFIG_USB_APPLEDISPLAY_MODULE 0
+#define CONFIG_MTD_CFI 1
+#define __enabled_CONFIG_MTD_CFI 1
+#define __enabled_CONFIG_MTD_CFI_MODULE 0
+#define CONFIG_CPU_32v4T 1
+#define __enabled_CONFIG_CPU_32v4T 1
+#define __enabled_CONFIG_CPU_32v4T_MODULE 0
+#define __enabled_CONFIG_CRYPTO_GCM 0
+#define __enabled_CONFIG_CRYPTO_GCM_MODULE 0
+#define __enabled_CONFIG_NETFILTER_NETLINK_LOG 0
+#define __enabled_CONFIG_NETFILTER_NETLINK_LOG_MODULE 0
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define __enabled_CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define __enabled_CONFIG_HAVE_DYNAMIC_FTRACE_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_14 0
+#define __enabled_CONFIG_NLS_ISO8859_14_MODULE 0
+#define __enabled_CONFIG_MTD_PHRAM 0
+#define __enabled_CONFIG_MTD_PHRAM_MODULE 0
+#define __enabled_CONFIG_MAGIC_SYSRQ 0
+#define __enabled_CONFIG_MAGIC_SYSRQ_MODULE 0
+#define __enabled_CONFIG_MFD_88PM860X 0
+#define __enabled_CONFIG_MFD_88PM860X_MODULE 0
+#define __enabled_CONFIG_ARCH_PNX4008 0
+#define __enabled_CONFIG_ARCH_PNX4008_MODULE 0
+#define __enabled_CONFIG_ARCH_RPC 0
+#define __enabled_CONFIG_ARCH_RPC_MODULE 0
+#define CONFIG_ROMFS_ON_MTD 1
+#define __enabled_CONFIG_ROMFS_ON_MTD 1
+#define __enabled_CONFIG_ROMFS_ON_MTD_MODULE 0
+#define __enabled_CONFIG_ISDN 0
+#define __enabled_CONFIG_ISDN_MODULE 0
+#define __enabled_CONFIG_YAFFS_9BYTE_TAGS 0
+#define __enabled_CONFIG_YAFFS_9BYTE_TAGS_MODULE 0
+#define __enabled_CONFIG_SPARSE_IRQ 0
+#define __enabled_CONFIG_SPARSE_IRQ_MODULE 0
+#define __enabled_CONFIG_SSFDC 0
+#define __enabled_CONFIG_SSFDC_MODULE 0
+#define __enabled_CONFIG_USB_MASS_STORAGE 0
+#define __enabled_CONFIG_USB_MASS_STORAGE_MODULE 0
+#define __enabled_CONFIG_MACH_QT2410 0
+#define __enabled_CONFIG_MACH_QT2410_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1286 0
+#define __enabled_CONFIG_RTC_DRV_DS1286_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_MCS5000 0
+#define __enabled_CONFIG_TOUCHSCREEN_MCS5000_MODULE 0
+#define __enabled_CONFIG_SECURITYFS 0
+#define __enabled_CONFIG_SECURITYFS_MODULE 0
+#define CONFIG_DEFAULT_CFQ 1
+#define __enabled_CONFIG_DEFAULT_CFQ 1
+#define __enabled_CONFIG_DEFAULT_CFQ_MODULE 0
+#define __enabled_CONFIG_MEDIA_SUPPORT 0
+#define __enabled_CONFIG_MEDIA_SUPPORT_MODULE 0
+#define __enabled_CONFIG_SENSORS_F75375S 0
+#define __enabled_CONFIG_SENSORS_F75375S_MODULE 0
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define __enabled_CONFIG_DEBUG_BUGVERBOSE 1
+#define __enabled_CONFIG_DEBUG_BUGVERBOSE_MODULE 0
+#define __enabled_CONFIG_I2C_DEBUG_BUS 0
+#define __enabled_CONFIG_I2C_DEBUG_BUS_MODULE 0
+#define __enabled_CONFIG_FONT_10x18 0
+#define __enabled_CONFIG_FONT_10x18_MODULE 0
+#define __enabled_CONFIG_HID_ZEROPLUS 0
+#define __enabled_CONFIG_HID_ZEROPLUS_MODULE 0
+#define CONFIG_EXT3_FS 1
+#define __enabled_CONFIG_EXT3_FS 1
+#define __enabled_CONFIG_EXT3_FS_MODULE 0
+#define __enabled_CONFIG_MFD_TC6387XB 0
+#define __enabled_CONFIG_MFD_TC6387XB_MODULE 0
+#define CONFIG_FAT_FS 1
+#define __enabled_CONFIG_FAT_FS 1
+#define __enabled_CONFIG_FAT_FS_MODULE 0
+#define CONFIG_SENSORS_LM75 1
+#define __enabled_CONFIG_SENSORS_LM75 1
+#define __enabled_CONFIG_SENSORS_LM75_MODULE 0
+#define __enabled_CONFIG_HIGHMEM 0
+#define __enabled_CONFIG_HIGHMEM_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1742 0
+#define __enabled_CONFIG_RTC_DRV_DS1742_MODULE 0
+#define __enabled_CONFIG_INET_TUNNEL 0
+#define __enabled_CONFIG_INET_TUNNEL_MODULE 0
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define __enabled_CONFIG_MMC_BLOCK_BOUNCE 1
+#define __enabled_CONFIG_MMC_BLOCK_BOUNCE_MODULE 0
+#define CONFIG_ROMFS_FS 1
+#define __enabled_CONFIG_ROMFS_FS 1
+#define __enabled_CONFIG_ROMFS_FS_MODULE 0
+#define CONFIG_IOSCHED_CFQ 1
+#define __enabled_CONFIG_IOSCHED_CFQ 1
+#define __enabled_CONFIG_IOSCHED_CFQ_MODULE 0
+#define __enabled_CONFIG_MFD_CORE 0
+#define __enabled_CONFIG_MFD_CORE_MODULE 0
+#define CONFIG_RTC_DRV_S3C 1
+#define __enabled_CONFIG_RTC_DRV_S3C 1
+#define __enabled_CONFIG_RTC_DRV_S3C_MODULE 0
+#define CONFIG_CPU_CP15_MMU 1
+#define __enabled_CONFIG_CPU_CP15_MMU 1
+#define __enabled_CONFIG_CPU_CP15_MMU_MODULE 0
+#define __enabled_CONFIG_RAID_ATTRS 0
+#define __enabled_CONFIG_RAID_ATTRS_MODULE 0
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define __enabled_CONFIG_CONSOLE_TRANSLATIONS 1
+#define __enabled_CONFIG_CONSOLE_TRANSLATIONS_MODULE 0
+#define CONFIG_MTD_CFI_STAA 1
+#define __enabled_CONFIG_MTD_CFI_STAA 1
+#define __enabled_CONFIG_MTD_CFI_STAA_MODULE 0
+#define __enabled_CONFIG_PHONE 0
+#define __enabled_CONFIG_PHONE_MODULE 0
+#define __enabled_CONFIG_HW_RANDOM_TIMERIOMEM 0
+#define __enabled_CONFIG_HW_RANDOM_TIMERIOMEM_MODULE 0
+#define __enabled_CONFIG_DEBUG_DEVRES 0
+#define __enabled_CONFIG_DEBUG_DEVRES_MODULE 0
+#define CONFIG_LEDS_TRIGGER_BACKLIGHT 1
+#define __enabled_CONFIG_LEDS_TRIGGER_BACKLIGHT 1
+#define __enabled_CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE 0
+#define __enabled_CONFIG_CPU_FREQ 0
+#define __enabled_CONFIG_CPU_FREQ_MODULE 0
+#define CONFIG_USB_OHCI_HCD 1
+#define __enabled_CONFIG_USB_OHCI_HCD 1
+#define __enabled_CONFIG_USB_OHCI_HCD_MODULE 0
+#define __enabled_CONFIG_CRYPTO_BLOWFISH 0
+#define __enabled_CONFIG_CRYPTO_BLOWFISH_MODULE 0
+#define CONFIG_DUMMY_CONSOLE 1
+#define __enabled_CONFIG_DUMMY_CONSOLE 1
+#define __enabled_CONFIG_DUMMY_CONSOLE_MODULE 0
+#define CONFIG_MODULE_FORCE_LOAD 1
+#define __enabled_CONFIG_MODULE_FORCE_LOAD 1
+#define __enabled_CONFIG_MODULE_FORCE_LOAD_MODULE 0
+#define __enabled_CONFIG_NLS_ASCII 0
+#define __enabled_CONFIG_NLS_ASCII_MODULE 0
+#define __enabled_CONFIG_USB_G_PRINTER 0
+#define __enabled_CONFIG_USB_G_PRINTER_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M41T94 0
+#define __enabled_CONFIG_RTC_DRV_M41T94_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT_MODULE 0
+#define __enabled_CONFIG_USB_RIO500 0
+#define __enabled_CONFIG_USB_RIO500_MODULE 0
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define __enabled_CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define __enabled_CONFIG_TRACE_IRQFLAGS_SUPPORT_MODULE 0
+#define __enabled_CONFIG_MTD_PHYSMAP 0
+#define __enabled_CONFIG_MTD_PHYSMAP_MODULE 0
+#define CONFIG_NFS_V3_ACL 1
+#define __enabled_CONFIG_NFS_V3_ACL 1
+#define __enabled_CONFIG_NFS_V3_ACL_MODULE 0
+#define CONFIG_INFTL 1
+#define __enabled_CONFIG_INFTL 1
+#define __enabled_CONFIG_INFTL_MODULE 0
+#define __enabled_CONFIG_YAFFS_DISABLE_BACKGROUND 0
+#define __enabled_CONFIG_YAFFS_DISABLE_BACKGROUND_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADT7462 0
+#define __enabled_CONFIG_SENSORS_ADT7462_MODULE 0
+#define __enabled_CONFIG_DETECT_HUNG_TASK 0
+#define __enabled_CONFIG_DETECT_HUNG_TASK_MODULE 0
+#define __enabled_CONFIG_SMDK2440_CPU2440 0
+#define __enabled_CONFIG_SMDK2440_CPU2440_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CCM 0
+#define __enabled_CONFIG_CRYPTO_CCM_MODULE 0
+#define __enabled_CONFIG_TCP_CONG_ADVANCED 0
+#define __enabled_CONFIG_TCP_CONG_ADVANCED_MODULE 0
+#define CONFIG_LEDS_TRIGGERS 1
+#define __enabled_CONFIG_LEDS_TRIGGERS 1
+#define __enabled_CONFIG_LEDS_TRIGGERS_MODULE 0
+#define __enabled_CONFIG_RAW_DRIVER 0
+#define __enabled_CONFIG_RAW_DRIVER_MODULE 0
+#define __enabled_CONFIG_LOGIG940_FF 0
+#define __enabled_CONFIG_LOGIG940_FF_MODULE 0
+#define CONFIG_RD_GZIP 1
+#define __enabled_CONFIG_RD_GZIP 1
+#define __enabled_CONFIG_RD_GZIP_MODULE 0
+#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define __enabled_CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define __enabled_CONFIG_HAVE_REGS_AND_STACK_ACCESS_API_MODULE 0
+#define __enabled_CONFIG_SENSORS_LTC4261 0
+#define __enabled_CONFIG_SENSORS_LTC4261_MODULE 0
+#define __enabled_CONFIG_MTD_DOC2000 0
+#define __enabled_CONFIG_MTD_DOC2000_MODULE 0
+#define CONFIG_LBDAF 1
+#define __enabled_CONFIG_LBDAF 1
+#define __enabled_CONFIG_LBDAF_MODULE 0
+#define __enabled_CONFIG_MFD_ASIC3 0
+#define __enabled_CONFIG_MFD_ASIC3_MODULE 0
+#define __enabled_CONFIG_BEFS_FS 0
+#define __enabled_CONFIG_BEFS_FS_MODULE 0
+#define __enabled_CONFIG_HID_ROCCAT 0
+#define __enabled_CONFIG_HID_ROCCAT_MODULE 0
+#define __enabled_CONFIG_INET_XFRM_MODE_TRANSPORT 0
+#define __enabled_CONFIG_INET_XFRM_MODE_TRANSPORT_MODULE 0
+#define __enabled_CONFIG_CRYPTO_MD5 0
+#define __enabled_CONFIG_CRYPTO_MD5_MODULE 0
+#define CONFIG_DEBUG_USER 1
+#define __enabled_CONFIG_DEBUG_USER 1
+#define __enabled_CONFIG_DEBUG_USER_MODULE 0
+#define __enabled_CONFIG_MFD_WL1273_CORE 0
+#define __enabled_CONFIG_MFD_WL1273_CORE_MODULE 0
+#define __enabled_CONFIG_BATMAN_ADV 0
+#define __enabled_CONFIG_BATMAN_ADV_MODULE 0
+#define __enabled_CONFIG_OABI_COMPAT 0
+#define __enabled_CONFIG_OABI_COMPAT_MODULE 0
+#define __enabled_CONFIG_PCCARD 0
+#define __enabled_CONFIG_PCCARD_MODULE 0
+#define CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define __enabled_CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define __enabled_CONFIG_HAVE_GENERIC_HARDIRQS_MODULE 0
+#define CONFIG_BINFMT_ELF 1
+#define __enabled_CONFIG_BINFMT_ELF 1
+#define __enabled_CONFIG_BINFMT_ELF_MODULE 0
+#define __enabled_CONFIG_ARCH_MXS 0
+#define __enabled_CONFIG_ARCH_MXS_MODULE 0
+#define CONFIG_HOTPLUG 1
+#define __enabled_CONFIG_HOTPLUG 1
+#define __enabled_CONFIG_HOTPLUG_MODULE 0
+#define __enabled_CONFIG_SCHED_TRACER 0
+#define __enabled_CONFIG_SCHED_TRACER_MODULE 0
+#define CONFIG_IP_PIMSM_V1 1
+#define __enabled_CONFIG_IP_PIMSM_V1 1
+#define __enabled_CONFIG_IP_PIMSM_V1_MODULE 0
+#define __enabled_CONFIG_FONT_SUN8x16 0
+#define __enabled_CONFIG_FONT_SUN8x16_MODULE 0
+#define CONFIG_CPU_CP15 1
+#define __enabled_CONFIG_CPU_CP15 1
+#define __enabled_CONFIG_CPU_CP15_MODULE 0
+#define __enabled_CONFIG_MACH_SMDK2412 0
+#define __enabled_CONFIG_MACH_SMDK2412_MODULE 0
+#define __enabled_CONFIG_USB_SERIAL 0
+#define __enabled_CONFIG_USB_SERIAL_MODULE 0
+#define CONFIG_S3C24XX_PWM 1
+#define __enabled_CONFIG_S3C24XX_PWM 1
+#define __enabled_CONFIG_S3C24XX_PWM_MODULE 0
+#define __enabled_CONFIG_SENSORS_GL518SM 0
+#define __enabled_CONFIG_SENSORS_GL518SM_MODULE 0
+#define __enabled_CONFIG_USB_MON 0
+#define __enabled_CONFIG_USB_MON_MODULE 0
+#define __enabled_CONFIG_VGASTATE 0
+#define __enabled_CONFIG_VGASTATE_MODULE 0
+#define __enabled_CONFIG_LCD_L4F00242T03 0
+#define __enabled_CONFIG_LCD_L4F00242T03_MODULE 0
+#define __enabled_CONFIG_TIMB_DMA 0
+#define __enabled_CONFIG_TIMB_DMA_MODULE 0
+#define __enabled_CONFIG_MACH_NEXCODER_2440 0
+#define __enabled_CONFIG_MACH_NEXCODER_2440_MODULE 0
+#define CONFIG_KEYS 1
+#define __enabled_CONFIG_KEYS 1
+#define __enabled_CONFIG_KEYS_MODULE 0
+#define __enabled_CONFIG_INET_XFRM_TUNNEL 0
+#define __enabled_CONFIG_INET_XFRM_TUNNEL_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_FM3130 0
+#define __enabled_CONFIG_RTC_DRV_FM3130_MODULE 0
+#define __enabled_CONFIG_DEBUG_MUTEXES 0
+#define __enabled_CONFIG_DEBUG_MUTEXES_MODULE 0
+#define CONFIG_IPMI_POWEROFF_MODULE 1
+#define __enabled_CONFIG_IPMI_POWEROFF 0
+#define __enabled_CONFIG_IPMI_POWEROFF_MODULE 1
+#define __enabled_CONFIG_NETFILTER_XTABLES 0
+#define __enabled_CONFIG_NETFILTER_XTABLES_MODULE 0
+#define __enabled_CONFIG_VMSPLIT_1G 0
+#define __enabled_CONFIG_VMSPLIT_1G_MODULE 0
+#define __enabled_CONFIG_USB_ISP1760_HCD 0
+#define __enabled_CONFIG_USB_ISP1760_HCD_MODULE 0
+#define __enabled_CONFIG_MFD_STMPE 0
+#define __enabled_CONFIG_MFD_STMPE_MODULE 0
+#define __enabled_CONFIG_LEDS_BD2802 0
+#define __enabled_CONFIG_LEDS_BD2802_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_STOWAWAY 0
+#define __enabled_CONFIG_KEYBOARD_STOWAWAY_MODULE 0
+#define CONFIG_SLABINFO 1
+#define __enabled_CONFIG_SLABINFO 1
+#define __enabled_CONFIG_SLABINFO_MODULE 0
+#define __enabled_CONFIG_KEYS_DEBUG_PROC_KEYS 0
+#define __enabled_CONFIG_KEYS_DEBUG_PROC_KEYS_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE 0
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE_MODULE 0
+#define CONFIG_IPMI_SI_MODULE 1
+#define __enabled_CONFIG_IPMI_SI 0
+#define __enabled_CONFIG_IPMI_SI_MODULE 1
+#define __enabled_CONFIG_MG_DISK 0
+#define __enabled_CONFIG_MG_DISK_MODULE 0
+#define __enabled_CONFIG_CRYPTO_USER_API_HASH 0
+#define __enabled_CONFIG_CRYPTO_USER_API_HASH_MODULE 0
+#define __enabled_CONFIG_MTD_CFI_ADV_OPTIONS 0
+#define __enabled_CONFIG_MTD_CFI_ADV_OPTIONS_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_IRQ 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_IRQ_MODULE 0
+#define __enabled_CONFIG_TIMER_STATS 0
+#define __enabled_CONFIG_TIMER_STATS_MODULE 0
+#define __enabled_CONFIG_SENSORS_IBMPEX 0
+#define __enabled_CONFIG_SENSORS_IBMPEX_MODULE 0
+#define __enabled_CONFIG_BOOT_PRINTK_DELAY 0
+#define __enabled_CONFIG_BOOT_PRINTK_DELAY_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADM1026 0
+#define __enabled_CONFIG_SENSORS_ADM1026_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADT7470 0
+#define __enabled_CONFIG_SENSORS_ADT7470_MODULE 0
+#define __enabled_CONFIG_SPI_PXA2XX_PCI 0
+#define __enabled_CONFIG_SPI_PXA2XX_PCI_MODULE 0
+#define __enabled_CONFIG_CRYPTO_HW 0
+#define __enabled_CONFIG_CRYPTO_HW_MODULE 0
+#define __enabled_CONFIG_USE_OF 0
+#define __enabled_CONFIG_USE_OF_MODULE 0
+#define __enabled_CONFIG_HID_GREENASIA 0
+#define __enabled_CONFIG_HID_GREENASIA_MODULE 0
+#define __enabled_CONFIG_LOGO_LINUX_MONO 0
+#define __enabled_CONFIG_LOGO_LINUX_MONO_MODULE 0
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define __enabled_CONFIG_HARDIRQS_SW_RESEND 1
+#define __enabled_CONFIG_HARDIRQS_SW_RESEND_MODULE 0
+#define CONFIG_SPI_MASTER 1
+#define __enabled_CONFIG_SPI_MASTER 1
+#define __enabled_CONFIG_SPI_MASTER_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM87 0
+#define __enabled_CONFIG_SENSORS_LM87_MODULE 0
+#define CONFIG_VT_HW_CONSOLE_BINDING 1
+#define __enabled_CONFIG_VT_HW_CONSOLE_BINDING 1
+#define __enabled_CONFIG_VT_HW_CONSOLE_BINDING_MODULE 0
+#define __enabled_CONFIG_ARCH_BCMRING 0
+#define __enabled_CONFIG_ARCH_BCMRING_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_IRQSAVE 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_IRQSAVE_MODULE 0
+#define CONFIG_HID_GYRATION 1
+#define __enabled_CONFIG_HID_GYRATION 1
+#define __enabled_CONFIG_HID_GYRATION_MODULE 0
+#define __enabled_CONFIG_DEBUG_KOBJECT 0
+#define __enabled_CONFIG_DEBUG_KOBJECT_MODULE 0
+#define __enabled_CONFIG_USB_WDM 0
+#define __enabled_CONFIG_USB_WDM_MODULE 0
+#define __enabled_CONFIG_MFD_TMIO 0
+#define __enabled_CONFIG_MFD_TMIO_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_USB_COMPOSITE 0
+#define __enabled_CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE 0
+#define __enabled_CONFIG_AX88796 0
+#define __enabled_CONFIG_AX88796_MODULE 0
+#define CONFIG_XZ_DEC_X86 1
+#define __enabled_CONFIG_XZ_DEC_X86 1
+#define __enabled_CONFIG_XZ_DEC_X86_MODULE 0
+#define __enabled_CONFIG_INPUT_JOYDEV 0
+#define __enabled_CONFIG_INPUT_JOYDEV_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_LKKBD 0
+#define __enabled_CONFIG_KEYBOARD_LKKBD_MODULE 0
+#define __enabled_CONFIG_IP_DCCP 0
+#define __enabled_CONFIG_IP_DCCP_MODULE 0
+#define __enabled_CONFIG_USB_ACM 0
+#define __enabled_CONFIG_USB_ACM_MODULE 0
+#define __enabled_CONFIG_USB_RTL8150 0
+#define __enabled_CONFIG_USB_RTL8150_MODULE 0
+#define __enabled_CONFIG_GPIO_MAX7300 0
+#define __enabled_CONFIG_GPIO_MAX7300_MODULE 0
+#define __enabled_CONFIG_CRC16 0
+#define __enabled_CONFIG_CRC16_MODULE 0
+#define __enabled_CONFIG_DEBUG_SHIRQ 0
+#define __enabled_CONFIG_DEBUG_SHIRQ_MODULE 0
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define __enabled_CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define __enabled_CONFIG_GENERIC_CALIBRATE_DELAY_MODULE 0
+#define __enabled_CONFIG_CRYPTO_GF128MUL 0
+#define __enabled_CONFIG_CRYPTO_GF128MUL_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_6 0
+#define __enabled_CONFIG_NLS_ISO8859_6_MODULE 0
+#define CONFIG_BROKEN_ON_SMP 1
+#define __enabled_CONFIG_BROKEN_ON_SMP 1
+#define __enabled_CONFIG_BROKEN_ON_SMP_MODULE 0
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
+#define __enabled_CONFIG_ARCH_REQUIRE_GPIOLIB 1
+#define __enabled_CONFIG_ARCH_REQUIRE_GPIOLIB_MODULE 0
+#define CONFIG_TMPFS 1
+#define __enabled_CONFIG_TMPFS 1
+#define __enabled_CONFIG_TMPFS_MODULE 0
+#define CONFIG_ANON_INODES 1
+#define __enabled_CONFIG_ANON_INODES 1
+#define __enabled_CONFIG_ANON_INODES_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_936 0
+#define __enabled_CONFIG_NLS_CODEPAGE_936_MODULE 0
+#define CONFIG_FUTEX 1
+#define __enabled_CONFIG_FUTEX 1
+#define __enabled_CONFIG_FUTEX_MODULE 0
+#define __enabled_CONFIG_CRYPTO_ANUBIS 0
+#define __enabled_CONFIG_CRYPTO_ANUBIS_MODULE 0
+#define CONFIG_IP_PNP_DHCP 1
+#define __enabled_CONFIG_IP_PNP_DHCP 1
+#define __enabled_CONFIG_IP_PNP_DHCP_MODULE 0
+#define CONFIG_MMC_SPI 1
+#define __enabled_CONFIG_MMC_SPI 1
+#define __enabled_CONFIG_MMC_SPI_MODULE 0
+#define __enabled_CONFIG_USB_G_MULTI 0
+#define __enabled_CONFIG_USB_G_MULTI_MODULE 0
+#define __enabled_CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED 0
+#define __enabled_CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED_MODULE 0
+#define CONFIG_VMSPLIT_3G 1
+#define __enabled_CONFIG_VMSPLIT_3G 1
+#define __enabled_CONFIG_VMSPLIT_3G_MODULE 0
+#define CONFIG_RTC_HCTOSYS 1
+#define __enabled_CONFIG_RTC_HCTOSYS 1
+#define __enabled_CONFIG_RTC_HCTOSYS_MODULE 0
+#define __enabled_CONFIG_I2C_OCORES 0
+#define __enabled_CONFIG_I2C_OCORES_MODULE 0
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define __enabled_CONFIG_SERIAL_CORE_CONSOLE 1
+#define __enabled_CONFIG_SERIAL_CORE_CONSOLE_MODULE 0
+#define __enabled_CONFIG_HUGETLB_PAGE 0
+#define __enabled_CONFIG_HUGETLB_PAGE_MODULE 0
+#define __enabled_CONFIG_MTD_SM_COMMON 0
+#define __enabled_CONFIG_MTD_SM_COMMON_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_GUNZE 0
+#define __enabled_CONFIG_TOUCHSCREEN_GUNZE_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM78 0
+#define __enabled_CONFIG_SENSORS_LM78_MODULE 0
+#define CONFIG_USB_HID 1
+#define __enabled_CONFIG_USB_HID 1
+#define __enabled_CONFIG_USB_HID_MODULE 0
+#define __enabled_CONFIG_SAMSUNG_PM_CHECK 0
+#define __enabled_CONFIG_SAMSUNG_PM_CHECK_MODULE 0
+#define __enabled_CONFIG_CRYPTO_TGR192 0
+#define __enabled_CONFIG_CRYPTO_TGR192_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_RBD 0
+#define __enabled_CONFIG_BLK_DEV_RBD_MODULE 0
+#define __enabled_CONFIG_SERIO_PS2MULT 0
+#define __enabled_CONFIG_SERIO_PS2MULT_MODULE 0
+#define CONFIG_SLUB_DEBUG 1
+#define __enabled_CONFIG_SLUB_DEBUG 1
+#define __enabled_CONFIG_SLUB_DEBUG_MODULE 0
+#define __enabled_CONFIG_MMC_VUB300 0
+#define __enabled_CONFIG_MMC_VUB300_MODULE 0
+#define __enabled_CONFIG_BCMA 0
+#define __enabled_CONFIG_BCMA_MODULE 0
+#define CONFIG_DMADEVICES 1
+#define __enabled_CONFIG_DMADEVICES 1
+#define __enabled_CONFIG_DMADEVICES_MODULE 0
+#define __enabled_CONFIG_MOUSE_PS2_ELANTECH 0
+#define __enabled_CONFIG_MOUSE_PS2_ELANTECH_MODULE 0
+#define __enabled_CONFIG_HFS_FS 0
+#define __enabled_CONFIG_HFS_FS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_MSM6242 0
+#define __enabled_CONFIG_RTC_DRV_MSM6242_MODULE 0
+#define __enabled_CONFIG_CRYPTO_ZLIB 0
+#define __enabled_CONFIG_CRYPTO_ZLIB_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_1251 0
+#define __enabled_CONFIG_NLS_CODEPAGE_1251_MODULE 0
+#define __enabled_CONFIG_FANOTIFY 0
+#define __enabled_CONFIG_FANOTIFY_MODULE 0
+#define __enabled_CONFIG_TEST_LIST_SORT 0
+#define __enabled_CONFIG_TEST_LIST_SORT_MODULE 0
+#define __enabled_CONFIG_SMC911X 0
+#define __enabled_CONFIG_SMC911X_MODULE 0
+#define CONFIG_SYSVIPC 1
+#define __enabled_CONFIG_SYSVIPC 1
+#define __enabled_CONFIG_SYSVIPC_MODULE 0
+#define CONFIG_CRYPTO_PCOMP2 1
+#define __enabled_CONFIG_CRYPTO_PCOMP2 1
+#define __enabled_CONFIG_CRYPTO_PCOMP2_MODULE 0
+#define __enabled_CONFIG_SMSC911X 0
+#define __enabled_CONFIG_SMSC911X_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_863 0
+#define __enabled_CONFIG_NLS_CODEPAGE_863_MODULE 0
+#define __enabled_CONFIG_USB_G_HID 0
+#define __enabled_CONFIG_USB_G_HID_MODULE 0
+#define CONFIG_KEYBOARD_GPIO 1
+#define __enabled_CONFIG_KEYBOARD_GPIO 1
+#define __enabled_CONFIG_KEYBOARD_GPIO_MODULE 0
+#define CONFIG_MODULES 1
+#define __enabled_CONFIG_MODULES 1
+#define __enabled_CONFIG_MODULES_MODULE 0
+#define CONFIG_USB_GADGET 1
+#define __enabled_CONFIG_USB_GADGET 1
+#define __enabled_CONFIG_USB_GADGET_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_NEWTON 0
+#define __enabled_CONFIG_KEYBOARD_NEWTON_MODULE 0
+#define __enabled_CONFIG_HARDLOCKUP_DETECTOR 0
+#define __enabled_CONFIG_HARDLOCKUP_DETECTOR_MODULE 0
+#define CONFIG_USB_HIDDEV 1
+#define __enabled_CONFIG_USB_HIDDEV 1
+#define __enabled_CONFIG_USB_HIDDEV_MODULE 0
+#define CONFIG_CPU_S3C244X 1
+#define __enabled_CONFIG_CPU_S3C244X 1
+#define __enabled_CONFIG_CPU_S3C244X_MODULE 0
+#define __enabled_CONFIG_MFD_TC3589X 0
+#define __enabled_CONFIG_MFD_TC3589X_MODULE 0
+#define CONFIG_USB_ETH_RNDIS 1
+#define __enabled_CONFIG_USB_ETH_RNDIS 1
+#define __enabled_CONFIG_USB_ETH_RNDIS_MODULE 0
+#define CONFIG_MTD_NAND_VERIFY_WRITE 1
+#define __enabled_CONFIG_MTD_NAND_VERIFY_WRITE 1
+#define __enabled_CONFIG_MTD_NAND_VERIFY_WRITE_MODULE 0
+#define __enabled_CONFIG_SOUND 0
+#define __enabled_CONFIG_SOUND_MODULE 0
+#define __enabled_CONFIG_CRYPTO_TEA 0
+#define __enabled_CONFIG_CRYPTO_TEA_MODULE 0
+#define CONFIG_S3C_BOOT_UART_FORCE_FIFO 1
+#define __enabled_CONFIG_S3C_BOOT_UART_FORCE_FIFO 1
+#define __enabled_CONFIG_S3C_BOOT_UART_FORCE_FIFO_MODULE 0
+#define CONFIG_UNIX 1
+#define __enabled_CONFIG_UNIX 1
+#define __enabled_CONFIG_UNIX_MODULE 0
+#define __enabled_CONFIG_USB_CATC 0
+#define __enabled_CONFIG_USB_CATC_MODULE 0
+#define __enabled_CONFIG_ARCH_PXA 0
+#define __enabled_CONFIG_ARCH_PXA_MODULE 0
+#define __enabled_CONFIG_MINIX_FS 0
+#define __enabled_CONFIG_MINIX_FS_MODULE 0
+#define CONFIG_YAFFS_YAFFS1 1
+#define __enabled_CONFIG_YAFFS_YAFFS1 1
+#define __enabled_CONFIG_YAFFS_YAFFS1_MODULE 0
+#define CONFIG_HAVE_CLK 1
+#define __enabled_CONFIG_HAVE_CLK 1
+#define __enabled_CONFIG_HAVE_CLK_MODULE 0
+#define CONFIG_CRYPTO_HASH2 1
+#define __enabled_CONFIG_CRYPTO_HASH2 1
+#define __enabled_CONFIG_CRYPTO_HASH2_MODULE 0
+#define __enabled_CONFIG_MTD_ABSENT 0
+#define __enabled_CONFIG_MTD_ABSENT_MODULE 0
+#define CONFIG_DEFAULT_HOSTNAME "(none)"
+#define __enabled_CONFIG_NLS_KOI8_R 0
+#define __enabled_CONFIG_NLS_KOI8_R_MODULE 0
+#define __enabled_CONFIG_NETDEV_10000 0
+#define __enabled_CONFIG_NETDEV_10000_MODULE 0
+#define CONFIG_NFS_FS 1
+#define __enabled_CONFIG_NFS_FS 1
+#define __enabled_CONFIG_NFS_FS_MODULE 0
+#define __enabled_CONFIG_CRASH_DUMP 0
+#define __enabled_CONFIG_CRASH_DUMP_MODULE 0
+#define __enabled_CONFIG_ARCH_EXYNOS4 0
+#define __enabled_CONFIG_ARCH_EXYNOS4_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_IO_TRACE 0
+#define __enabled_CONFIG_BLK_DEV_IO_TRACE_MODULE 0
+#define __enabled_CONFIG_INET_ESP 0
+#define __enabled_CONFIG_INET_ESP_MODULE 0
+#define __enabled_CONFIG_LCD_TDO24M 0
+#define __enabled_CONFIG_LCD_TDO24M_MODULE 0
+#define __enabled_CONFIG_GPIO_MAX732X 0
+#define __enabled_CONFIG_GPIO_MAX732X_MODULE 0
+#define __enabled_CONFIG_HID_QUANTA 0
+#define __enabled_CONFIG_HID_QUANTA_MODULE 0
+#define __enabled_CONFIG_MD 0
+#define __enabled_CONFIG_MD_MODULE 0
+#define CONFIG_CRYPTO_ALGAPI 1
+#define __enabled_CONFIG_CRYPTO_ALGAPI 1
+#define __enabled_CONFIG_CRYPTO_ALGAPI_MODULE 0
+#define CONFIG_FONTS 1
+#define __enabled_CONFIG_FONTS 1
+#define __enabled_CONFIG_FONTS_MODULE 0
+#define __enabled_CONFIG_USB_G_DBGP 0
+#define __enabled_CONFIG_USB_G_DBGP_MODULE 0
+#define __enabled_CONFIG_BRIDGE 0
+#define __enabled_CONFIG_BRIDGE_MODULE 0
+#define __enabled_CONFIG_MISC_DEVICES 0
+#define __enabled_CONFIG_MISC_DEVICES_MODULE 0
+#define __enabled_CONFIG_USB_CYPRESS_CY7C63 0
+#define __enabled_CONFIG_USB_CYPRESS_CY7C63_MODULE 0
+#define CONFIG_RD_BZIP2 1
+#define __enabled_CONFIG_RD_BZIP2 1
+#define __enabled_CONFIG_RD_BZIP2_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_XIP 0
+#define __enabled_CONFIG_BLK_DEV_XIP_MODULE 0
+#define CONFIG_LEDS_TRIGGER_GPIO 1
+#define __enabled_CONFIG_LEDS_TRIGGER_GPIO 1
+#define __enabled_CONFIG_LEDS_TRIGGER_GPIO_MODULE 0
+#define __enabled_CONFIG_ARCH_SUPPORTS_MSI 0
+#define __enabled_CONFIG_ARCH_SUPPORTS_MSI_MODULE 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_32 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_32_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_ATKBD 0
+#define __enabled_CONFIG_KEYBOARD_ATKBD_MODULE 0
+#define CONFIG_MTD_CFI_I1 1
+#define __enabled_CONFIG_MTD_CFI_I1 1
+#define __enabled_CONFIG_MTD_CFI_I1_MODULE 0
+#define __enabled_CONFIG_LEDS_PWM 0
+#define __enabled_CONFIG_LEDS_PWM_MODULE 0
+#define CONFIG_BLK_DEV_INTEGRITY 1
+#define __enabled_CONFIG_BLK_DEV_INTEGRITY 1
+#define __enabled_CONFIG_BLK_DEV_INTEGRITY_MODULE 0
+#define __enabled_CONFIG_MOUSE_BCM5974 0
+#define __enabled_CONFIG_MOUSE_BCM5974_MODULE 0
+#define CONFIG_CPU_IDLE 1
+#define __enabled_CONFIG_CPU_IDLE 1
+#define __enabled_CONFIG_CPU_IDLE_MODULE 0
+#define CONFIG_NFS_COMMON 1
+#define __enabled_CONFIG_NFS_COMMON 1
+#define __enabled_CONFIG_NFS_COMMON_MODULE 0
+#define __enabled_CONFIG_REGULATOR 0
+#define __enabled_CONFIG_REGULATOR_MODULE 0
+#define CONFIG_CRYPTO_HASH_MODULE 1
+#define __enabled_CONFIG_CRYPTO_HASH 0
+#define __enabled_CONFIG_CRYPTO_HASH_MODULE 1
+#define CONFIG_EFI_PARTITION 1
+#define __enabled_CONFIG_EFI_PARTITION 1
+#define __enabled_CONFIG_EFI_PARTITION_MODULE 0
+#define CONFIG_LOG_BUF_SHIFT 17
+#define __enabled_CONFIG_USB_S3C_HSUDC 0
+#define __enabled_CONFIG_USB_S3C_HSUDC_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_857 0
+#define __enabled_CONFIG_NLS_CODEPAGE_857_MODULE 0
+#define CONFIG_EXTRA_FIRMWARE ""
+#define __enabled_CONFIG_TCG_TPM 0
+#define __enabled_CONFIG_TCG_TPM_MODULE 0
+#define CONFIG_VIRT_TO_BUS 1
+#define __enabled_CONFIG_VIRT_TO_BUS 1
+#define __enabled_CONFIG_VIRT_TO_BUS_MODULE 0
+#define CONFIG_VFAT_FS 1
+#define __enabled_CONFIG_VFAT_FS 1
+#define __enabled_CONFIG_VFAT_FS_MODULE 0
+#define CONFIG_PID_NS 1
+#define __enabled_CONFIG_PID_NS 1
+#define __enabled_CONFIG_PID_NS_MODULE 0
+#define __enabled_CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL 0
+#define __enabled_CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL_MODULE 0
+#define __enabled_CONFIG_CRYPTO_VMAC 0
+#define __enabled_CONFIG_CRYPTO_VMAC_MODULE 0
+#define CONFIG_KEXEC 1
+#define __enabled_CONFIG_KEXEC 1
+#define __enabled_CONFIG_KEXEC_MODULE 0
+#define __enabled_CONFIG_FB_DDC 0
+#define __enabled_CONFIG_FB_DDC_MODULE 0
+#define __enabled_CONFIG_USB_S3C2410 0
+#define __enabled_CONFIG_USB_S3C2410_MODULE 0
+#define __enabled_CONFIG_MINI2440_HELLO_MODULE 0
+#define __enabled_CONFIG_MINI2440_HELLO_MODULE_MODULE 0
+#define CONFIG_ROMFS_ON_BLOCK 1
+#define __enabled_CONFIG_ROMFS_ON_BLOCK 1
+#define __enabled_CONFIG_ROMFS_ON_BLOCK_MODULE 0
+#define CONFIG_BLK_DEV_LOOP_MODULE 1
+#define __enabled_CONFIG_BLK_DEV_LOOP 0
+#define __enabled_CONFIG_BLK_DEV_LOOP_MODULE 1
+#define CONFIG_IPMI_HANDLER_MODULE 1
+#define __enabled_CONFIG_IPMI_HANDLER 0
+#define __enabled_CONFIG_IPMI_HANDLER_MODULE 1
+#define __enabled_CONFIG_B44 0
+#define __enabled_CONFIG_B44_MODULE 0
+#define __enabled_CONFIG_SYSV_FS 0
+#define __enabled_CONFIG_SYSV_FS_MODULE 0
+#define __enabled_CONFIG_SENSORS_THMC50 0
+#define __enabled_CONFIG_SENSORS_THMC50_MODULE 0
+#define CONFIG_PLAT_SAMSUNG 1
+#define __enabled_CONFIG_PLAT_SAMSUNG 1
+#define __enabled_CONFIG_PLAT_SAMSUNG_MODULE 0
+#define __enabled_CONFIG_INPUT_MISC 0
+#define __enabled_CONFIG_INPUT_MISC_MODULE 0
+#define __enabled_CONFIG_AUTO_ZRELADDR 0
+#define __enabled_CONFIG_AUTO_ZRELADDR_MODULE 0
+#define __enabled_CONFIG_SENSORS_SCH5627 0
+#define __enabled_CONFIG_SENSORS_SCH5627_MODULE 0
+#define __enabled_CONFIG_DNET 0
+#define __enabled_CONFIG_DNET_MODULE 0
+#define CONFIG_SUSPEND 1
+#define __enabled_CONFIG_SUSPEND 1
+#define __enabled_CONFIG_SUSPEND_MODULE 0
+#define CONFIG_MTD_NAND_ECC 1
+#define __enabled_CONFIG_MTD_NAND_ECC 1
+#define __enabled_CONFIG_MTD_NAND_ECC_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CBC 0
+#define __enabled_CONFIG_CRYPTO_CBC_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM93 0
+#define __enabled_CONFIG_SENSORS_LM93_MODULE 0
+#define __enabled_CONFIG_KPROBES 0
+#define __enabled_CONFIG_KPROBES_MODULE 0
+#define CONFIG_FS_MBCACHE 1
+#define __enabled_CONFIG_FS_MBCACHE 1
+#define __enabled_CONFIG_FS_MBCACHE_MODULE 0
+#define __enabled_CONFIG_SENSORS_JC42 0
+#define __enabled_CONFIG_SENSORS_JC42_MODULE 0
+#define __enabled_CONFIG_GFS2_FS 0
+#define __enabled_CONFIG_GFS2_FS_MODULE 0
+#define CONFIG_RTC_CLASS 1
+#define __enabled_CONFIG_RTC_CLASS 1
+#define __enabled_CONFIG_RTC_CLASS_MODULE 0
+#define CONFIG_CRC7 1
+#define __enabled_CONFIG_CRC7 1
+#define __enabled_CONFIG_CRC7_MODULE 0
+#define __enabled_CONFIG_SENSORS_LTC4215 0
+#define __enabled_CONFIG_SENSORS_LTC4215_MODULE 0
+#define __enabled_CONFIG_USB_EMI26 0
+#define __enabled_CONFIG_USB_EMI26_MODULE 0
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define __enabled_CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define __enabled_CONFIG_HAVE_LATENCYTOP_SUPPORT_MODULE 0
+#define __enabled_CONFIG_ARCH_SHARK 0
+#define __enabled_CONFIG_ARCH_SHARK_MODULE 0
+#define CONFIG_TMPFS_XATTR 1
+#define __enabled_CONFIG_TMPFS_XATTR 1
+#define __enabled_CONFIG_TMPFS_XATTR_MODULE 0
+#define __enabled_CONFIG_FB_UVESA 0
+#define __enabled_CONFIG_FB_UVESA_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_BH 0
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_BH_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TSC2007 0
+#define __enabled_CONFIG_TOUCHSCREEN_TSC2007_MODULE 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG_FS 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG_FS_MODULE 0
+#define __enabled_CONFIG_W1 0
+#define __enabled_CONFIG_W1_MODULE 0
+#define __enabled_CONFIG_LOGFS 0
+#define __enabled_CONFIG_LOGFS_MODULE 0
+#define CONFIG_ARCH_S3C2410 1
+#define __enabled_CONFIG_ARCH_S3C2410 1
+#define __enabled_CONFIG_ARCH_S3C2410_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_S3C2410_HWECC 0
+#define __enabled_CONFIG_MTD_NAND_S3C2410_HWECC_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1374 0
+#define __enabled_CONFIG_RTC_DRV_DS1374_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_BQ4802 0
+#define __enabled_CONFIG_RTC_DRV_BQ4802_MODULE 0
+#define CONFIG_YAFFS_AUTO_YAFFS2 1
+#define __enabled_CONFIG_YAFFS_AUTO_YAFFS2 1
+#define __enabled_CONFIG_YAFFS_AUTO_YAFFS2_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_5 0
+#define __enabled_CONFIG_NLS_ISO8859_5_MODULE 0
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define __enabled_CONFIG_HAVE_FUNCTION_TRACER 1
+#define __enabled_CONFIG_HAVE_FUNCTION_TRACER_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CAMELLIA 0
+#define __enabled_CONFIG_CRYPTO_CAMELLIA_MODULE 0
+#define CONFIG_NO_IOPORT 1
+#define __enabled_CONFIG_NO_IOPORT 1
+#define __enabled_CONFIG_NO_IOPORT_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1307 0
+#define __enabled_CONFIG_RTC_DRV_DS1307_MODULE 0
+#define __enabled_CONFIG_ARCH_SELECT_MEMORY_MODEL 0
+#define __enabled_CONFIG_ARCH_SELECT_MEMORY_MODEL_MODULE 0
+#define __enabled_CONFIG_PMBUS 0
+#define __enabled_CONFIG_PMBUS_MODULE 0
+#define CONFIG_CRYPTO_MANAGER2 1
+#define __enabled_CONFIG_CRYPTO_MANAGER2 1
+#define __enabled_CONFIG_CRYPTO_MANAGER2_MODULE 0
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+#define __enabled_CONFIG_MTD_NAND_S3C2410_CLKSTOP 0
+#define __enabled_CONFIG_MTD_NAND_S3C2410_CLKSTOP_MODULE 0
+#define CONFIG_SLUB 1
+#define __enabled_CONFIG_SLUB 1
+#define __enabled_CONFIG_SLUB_MODULE 0
+#define __enabled_CONFIG_SENSORS_AD7418 0
+#define __enabled_CONFIG_SENSORS_AD7418_MODULE 0
+#define CONFIG_CONFIGFS_FS_MODULE 1
+#define __enabled_CONFIG_CONFIGFS_FS 0
+#define __enabled_CONFIG_CONFIGFS_FS_MODULE 1
+#define __enabled_CONFIG_CRYPTO_TEST 0
+#define __enabled_CONFIG_CRYPTO_TEST_MODULE 0
+#define __enabled_CONFIG_MTD_UBI 0
+#define __enabled_CONFIG_MTD_UBI_MODULE 0
+#define CONFIG_XZ_DEC_BCJ 1
+#define __enabled_CONFIG_XZ_DEC_BCJ 1
+#define __enabled_CONFIG_XZ_DEC_BCJ_MODULE 0
+#define __enabled_CONFIG_SLIP 0
+#define __enabled_CONFIG_SLIP_MODULE 0
+#define CONFIG_PM_SLEEP 1
+#define __enabled_CONFIG_PM_SLEEP 1
+#define __enabled_CONFIG_PM_SLEEP_MODULE 0
+#define CONFIG_I2C 1
+#define __enabled_CONFIG_I2C 1
+#define __enabled_CONFIG_I2C_MODULE 0
+#define __enabled_CONFIG_SENSORS_VT1211 0
+#define __enabled_CONFIG_SENSORS_VT1211_MODULE 0
+#define __enabled_CONFIG_DEBUG_VM 0
+#define __enabled_CONFIG_DEBUG_VM_MODULE 0
+#define __enabled_CONFIG_ARCH_DOVE 0
+#define __enabled_CONFIG_ARCH_DOVE_MODULE 0
+#define __enabled_CONFIG_FONT_ACORN_8x8 0
+#define __enabled_CONFIG_FONT_ACORN_8x8_MODULE 0
+#define __enabled_CONFIG_KS8851_MLL 0
+#define __enabled_CONFIG_KS8851_MLL_MODULE 0
+#define CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define __enabled_CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define __enabled_CONFIG_MOUSE_PS2_LOGIPS2PP_MODULE 0
+#define __enabled_CONFIG_UFS_FS 0
+#define __enabled_CONFIG_UFS_FS_MODULE 0
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define __enabled_CONFIG_VM_EVENT_COUNTERS 1
+#define __enabled_CONFIG_VM_EVENT_COUNTERS_MODULE 0
+#define CONFIG_RELAY 1
+#define __enabled_CONFIG_RELAY 1
+#define __enabled_CONFIG_RELAY_MODULE 0
+#define CONFIG_CRYPTO_ECB_MODULE 1
+#define __enabled_CONFIG_CRYPTO_ECB 0
+#define __enabled_CONFIG_CRYPTO_ECB_MODULE 1
+#define CONFIG_USB_LIBUSUAL 1
+#define __enabled_CONFIG_USB_LIBUSUAL 1
+#define __enabled_CONFIG_USB_LIBUSUAL_MODULE 0
+#define CONFIG_DEBUG_FS 1
+#define __enabled_CONFIG_DEBUG_FS 1
+#define __enabled_CONFIG_DEBUG_FS_MODULE 0
+#define __enabled_CONFIG_ARCH_TCC_926 0
+#define __enabled_CONFIG_ARCH_TCC_926_MODULE 0
+#define CONFIG_NET_PKTGEN_MODULE 1
+#define __enabled_CONFIG_NET_PKTGEN 0
+#define __enabled_CONFIG_NET_PKTGEN_MODULE 1
+#define CONFIG_BASE_FULL 1
+#define __enabled_CONFIG_BASE_FULL 1
+#define __enabled_CONFIG_BASE_FULL_MODULE 0
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define __enabled_CONFIG_FB_CFB_IMAGEBLIT 1
+#define __enabled_CONFIG_FB_CFB_IMAGEBLIT_MODULE 0
+#define CONFIG_SOLARIS_X86_PARTITION 1
+#define __enabled_CONFIG_SOLARIS_X86_PARTITION 1
+#define __enabled_CONFIG_SOLARIS_X86_PARTITION_MODULE 0
+#define CONFIG_SUNRPC 1
+#define __enabled_CONFIG_SUNRPC 1
+#define __enabled_CONFIG_SUNRPC_MODULE 0
+#define __enabled_CONFIG_PMIC_DA903X 0
+#define __enabled_CONFIG_PMIC_DA903X_MODULE 0
+#define CONFIG_YAFFS_FS 1
+#define __enabled_CONFIG_YAFFS_FS 1
+#define __enabled_CONFIG_YAFFS_FS_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83795 0
+#define __enabled_CONFIG_SENSORS_W83795_MODULE 0
+#define __enabled_CONFIG_USB_DUMMY_HCD 0
+#define __enabled_CONFIG_USB_DUMMY_HCD_MODULE 0
+#define __enabled_CONFIG_OSF_PARTITION 0
+#define __enabled_CONFIG_OSF_PARTITION_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_864 0
+#define __enabled_CONFIG_NLS_CODEPAGE_864_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_CY8CTMG110 0
+#define __enabled_CONFIG_TOUCHSCREEN_CY8CTMG110_MODULE 0
+#define CONFIG_GPIO_SYSFS 1
+#define __enabled_CONFIG_GPIO_SYSFS 1
+#define __enabled_CONFIG_GPIO_SYSFS_MODULE 0
+#define __enabled_CONFIG_USB_YUREX 0
+#define __enabled_CONFIG_USB_YUREX_MODULE 0
+#define CONFIG_FW_LOADER 1
+#define __enabled_CONFIG_FW_LOADER 1
+#define __enabled_CONFIG_FW_LOADER_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADS7828 0
+#define __enabled_CONFIG_SENSORS_ADS7828_MODULE 0
+#define CONFIG_KALLSYMS 1
+#define __enabled_CONFIG_KALLSYMS 1
+#define __enabled_CONFIG_KALLSYMS_MODULE 0
+#define CONFIG_GENERIC_ATOMIC64 1
+#define __enabled_CONFIG_GENERIC_ATOMIC64 1
+#define __enabled_CONFIG_GENERIC_ATOMIC64_MODULE 0
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define __enabled_CONFIG_CRYPTO_XTS 0
+#define __enabled_CONFIG_CRYPTO_XTS_MODULE 0
+#define CONFIG_DECOMPRESS_XZ 1
+#define __enabled_CONFIG_DECOMPRESS_XZ 1
+#define __enabled_CONFIG_DECOMPRESS_XZ_MODULE 0
+#define CONFIG_MII 1
+#define __enabled_CONFIG_MII 1
+#define __enabled_CONFIG_MII_MODULE 0
+#define CONFIG_SIGNALFD 1
+#define __enabled_CONFIG_SIGNALFD 1
+#define __enabled_CONFIG_SIGNALFD_MODULE 0
+#define __enabled_CONFIG_FONT_SUN12x22 0
+#define __enabled_CONFIG_FONT_SUN12x22_MODULE 0
+#define CONFIG_MOUSE_PS2_ALPS 1
+#define __enabled_CONFIG_MOUSE_PS2_ALPS 1
+#define __enabled_CONFIG_MOUSE_PS2_ALPS_MODULE 0
+#define __enabled_CONFIG_EXT4_FS 0
+#define __enabled_CONFIG_EXT4_FS_MODULE 0
+#define __enabled_CONFIG_SENSORS_LTC4151 0
+#define __enabled_CONFIG_SENSORS_LTC4151_MODULE 0
+#define CONFIG_S3C_DEV_NAND 1
+#define __enabled_CONFIG_S3C_DEV_NAND 1
+#define __enabled_CONFIG_S3C_DEV_NAND_MODULE 0
+#define CONFIG_MTD_LPDDR 1
+#define __enabled_CONFIG_MTD_LPDDR 1
+#define __enabled_CONFIG_MTD_LPDDR_MODULE 0
+#define __enabled_CONFIG_RCU_TORTURE_TEST 0
+#define __enabled_CONFIG_RCU_TORTURE_TEST_MODULE 0
+#define CONFIG_CRYPTO_SHA1_MODULE 1
+#define __enabled_CONFIG_CRYPTO_SHA1 0
+#define __enabled_CONFIG_CRYPTO_SHA1_MODULE 1
+#define CONFIG_IPMI_WATCHDOG_MODULE 1
+#define __enabled_CONFIG_IPMI_WATCHDOG 0
+#define __enabled_CONFIG_IPMI_WATCHDOG_MODULE 1
+#define __enabled_CONFIG_ARCH_S5P64X0 0
+#define __enabled_CONFIG_ARCH_S5P64X0_MODULE 0
+#define __enabled_CONFIG_USB_ADUTUX 0
+#define __enabled_CONFIG_USB_ADUTUX_MODULE 0
+#define __enabled_CONFIG_SENSORS_SMSC47M192 0
+#define __enabled_CONFIG_SENSORS_SMSC47M192_MODULE 0
+#define __enabled_CONFIG_ARCH_H720X 0
+#define __enabled_CONFIG_ARCH_H720X_MODULE 0
+#define __enabled_CONFIG_CRC8 0
+#define __enabled_CONFIG_CRC8_MODULE 0
+#define __enabled_CONFIG_NLS_KOI8_U 0
+#define __enabled_CONFIG_NLS_KOI8_U_MODULE 0
+#define __enabled_CONFIG_SENSORS_SCH5636 0
+#define __enabled_CONFIG_SENSORS_SCH5636_MODULE 0
+#define CONFIG_XZ_DEC 1
+#define __enabled_CONFIG_XZ_DEC 1
+#define __enabled_CONFIG_XZ_DEC_MODULE 0
+#define CONFIG_LOCKD_V4 1
+#define __enabled_CONFIG_LOCKD_V4 1
+#define __enabled_CONFIG_LOCKD_V4_MODULE 0
+#define __enabled_CONFIG_DUMMY 0
+#define __enabled_CONFIG_DUMMY_MODULE 0
+#define __enabled_CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING 0
+#define __enabled_CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING_MODULE 0
+#define __enabled_CONFIG_CODA_FS 0
+#define __enabled_CONFIG_CODA_FS_MODULE 0
+#define __enabled_CONFIG_LEDS_LM3530 0
+#define __enabled_CONFIG_LEDS_LM3530_MODULE 0
+#define CONFIG_WATCHDOG 1
+#define __enabled_CONFIG_WATCHDOG 1
+#define __enabled_CONFIG_WATCHDOG_MODULE 0
+#define CONFIG_HAS_IOMEM 1
+#define __enabled_CONFIG_HAS_IOMEM 1
+#define __enabled_CONFIG_HAS_IOMEM_MODULE 0
+#define __enabled_CONFIG_VIRT_DRIVERS 0
+#define __enabled_CONFIG_VIRT_DRIVERS_MODULE 0
+#define __enabled_CONFIG_KERNEL_LZO 0
+#define __enabled_CONFIG_KERNEL_LZO_MODULE 0
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define __enabled_CONFIG_GENERIC_IRQ_PROBE 1
+#define __enabled_CONFIG_GENERIC_IRQ_PROBE_MODULE 0
+#define __enabled_CONFIG_CPU_ICACHE_DISABLE 0
+#define __enabled_CONFIG_CPU_ICACHE_DISABLE_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_MCS 0
+#define __enabled_CONFIG_KEYBOARD_MCS_MODULE 0
+#define CONFIG_NFTL 1
+#define __enabled_CONFIG_NFTL 1
+#define __enabled_CONFIG_NFTL_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL_MODULE 0
+#define CONFIG_USB_GADGETFS_MODULE 1
+#define __enabled_CONFIG_USB_GADGETFS 0
+#define __enabled_CONFIG_USB_GADGETFS_MODULE 1
+#define __enabled_CONFIG_RTC_DRV_X1205 0
+#define __enabled_CONFIG_RTC_DRV_X1205_MODULE 0
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_1_MODULE 0
+#define CONFIG_APM_EMULATION 1
+#define __enabled_CONFIG_APM_EMULATION 1
+#define __enabled_CONFIG_APM_EMULATION_MODULE 0
+#define CONFIG_HAVE_PWM 1
+#define __enabled_CONFIG_HAVE_PWM 1
+#define __enabled_CONFIG_HAVE_PWM_MODULE 0
+#define CONFIG_EPOLL 1
+#define __enabled_CONFIG_EPOLL 1
+#define __enabled_CONFIG_EPOLL_MODULE 0
+#define __enabled_CONFIG_CRYPTO_LZO 0
+#define __enabled_CONFIG_CRYPTO_LZO_MODULE 0
+#define __enabled_CONFIG_PM_RUNTIME 0
+#define __enabled_CONFIG_PM_RUNTIME_MODULE 0
+#define CONFIG_S3C2410_PM 1
+#define __enabled_CONFIG_S3C2410_PM 1
+#define __enabled_CONFIG_S3C2410_PM_MODULE 0
+#define CONFIG_SDIO_UART 1
+#define __enabled_CONFIG_SDIO_UART 1
+#define __enabled_CONFIG_SDIO_UART_MODULE 0
+#define CONFIG_PARTITION_ADVANCED 1
+#define __enabled_CONFIG_PARTITION_ADVANCED 1
+#define __enabled_CONFIG_PARTITION_ADVANCED_MODULE 0
+#define __enabled_CONFIG_EZX_PCAP 0
+#define __enabled_CONFIG_EZX_PCAP_MODULE 0
+#define __enabled_CONFIG_SENSORS_SCH56XX_COMMON 0
+#define __enabled_CONFIG_SENSORS_SCH56XX_COMMON_MODULE 0
+#define __enabled_CONFIG_DEBUG_SECTION_MISMATCH 0
+#define __enabled_CONFIG_DEBUG_SECTION_MISMATCH_MODULE 0
+#define CONFIG_UNIXWARE_DISKLABEL 1
+#define __enabled_CONFIG_UNIXWARE_DISKLABEL 1
+#define __enabled_CONFIG_UNIXWARE_DISKLABEL_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_MAX7359 0
+#define __enabled_CONFIG_KEYBOARD_MAX7359_MODULE 0
+#define CONFIG_YAFFS_XATTR 1
+#define __enabled_CONFIG_YAFFS_XATTR 1
+#define __enabled_CONFIG_YAFFS_XATTR_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_852 0
+#define __enabled_CONFIG_NLS_CODEPAGE_852_MODULE 0
+#define __enabled_CONFIG_SERIAL_XILINX_PS_UART 0
+#define __enabled_CONFIG_SERIAL_XILINX_PS_UART_MODULE 0
+#define __enabled_CONFIG_USB_ISP116X_HCD 0
+#define __enabled_CONFIG_USB_ISP116X_HCD_MODULE 0
+#define CONFIG_NET 1
+#define __enabled_CONFIG_NET 1
+#define __enabled_CONFIG_NET_MODULE 0
+#define __enabled_CONFIG_ATARI_PARTITION 0
+#define __enabled_CONFIG_ATARI_PARTITION_MODULE 0
+#define CONFIG_INPUT_EVDEV 1
+#define __enabled_CONFIG_INPUT_EVDEV 1
+#define __enabled_CONFIG_INPUT_EVDEV_MODULE 0
+#define CONFIG_HAVE_SPARSE_IRQ 1
+#define __enabled_CONFIG_HAVE_SPARSE_IRQ 1
+#define __enabled_CONFIG_HAVE_SPARSE_IRQ_MODULE 0
+#define __enabled_CONFIG_EXT2_FS 0
+#define __enabled_CONFIG_EXT2_FS_MODULE 0
+#define __enabled_CONFIG_CRYPTO_WP512 0
+#define __enabled_CONFIG_CRYPTO_WP512_MODULE 0
+#define __enabled_CONFIG_HID_DRAGONRISE 0
+#define __enabled_CONFIG_HID_DRAGONRISE_MODULE 0
+#define __enabled_CONFIG_HPFS_FS 0
+#define __enabled_CONFIG_HPFS_FS_MODULE 0
+#define __enabled_CONFIG_USB_LD 0
+#define __enabled_CONFIG_USB_LD_MODULE 0
+#define CONFIG_MTD_GEN_PROBE 1
+#define __enabled_CONFIG_MTD_GEN_PROBE 1
+#define __enabled_CONFIG_MTD_GEN_PROBE_MODULE 0
+#define CONFIG_PACKET 1
+#define __enabled_CONFIG_PACKET 1
+#define __enabled_CONFIG_PACKET_MODULE 0
+#define __enabled_CONFIG_MODULE_SRCVERSION_ALL 0
+#define __enabled_CONFIG_MODULE_SRCVERSION_ALL_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M48T86 0
+#define __enabled_CONFIG_RTC_DRV_M48T86_MODULE 0
+#define __enabled_CONFIG_SENSORS_SMM665 0
+#define __enabled_CONFIG_SENSORS_SMM665_MODULE 0
+#define __enabled_CONFIG_I2C_TINY_USB 0
+#define __enabled_CONFIG_I2C_TINY_USB_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_TCA6416 0
+#define __enabled_CONFIG_KEYBOARD_TCA6416_MODULE 0
+#define CONFIG_NFS_V3 1
+#define __enabled_CONFIG_NFS_V3 1
+#define __enabled_CONFIG_NFS_V3_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_MAX6902 0
+#define __enabled_CONFIG_RTC_DRV_MAX6902_MODULE 0
+#define __enabled_CONFIG_MFD_MAX8997 0
+#define __enabled_CONFIG_MFD_MAX8997_MODULE 0
+#define CONFIG_USB_FILE_STORAGE_MODULE 1
+#define __enabled_CONFIG_USB_FILE_STORAGE 0
+#define __enabled_CONFIG_USB_FILE_STORAGE_MODULE 1
+#define __enabled_CONFIG_ARCH_LPC32XX 0
+#define __enabled_CONFIG_ARCH_LPC32XX_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_949 0
+#define __enabled_CONFIG_NLS_CODEPAGE_949_MODULE 0
+#define __enabled_CONFIG_SENSORS_TMP102 0
+#define __enabled_CONFIG_SENSORS_TMP102_MODULE 0
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define __enabled_CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define __enabled_CONFIG_BACKLIGHT_LCD_SUPPORT_MODULE 0
+#define CONFIG_INET 1
+#define __enabled_CONFIG_INET 1
+#define __enabled_CONFIG_INET_MODULE 0
+#define __enabled_CONFIG_I2C_PXA_PCI 0
+#define __enabled_CONFIG_I2C_PXA_PCI_MODULE 0
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define __enabled_CONFIG_IP_ROUTE_VERBOSE 1
+#define __enabled_CONFIG_IP_ROUTE_VERBOSE_MODULE 0
+#define CONFIG_XZ_DEC_POWERPC 1
+#define __enabled_CONFIG_XZ_DEC_POWERPC 1
+#define __enabled_CONFIG_XZ_DEC_POWERPC_MODULE 0
+#define CONFIG_IP_PNP_BOOTP 1
+#define __enabled_CONFIG_IP_PNP_BOOTP 1
+#define __enabled_CONFIG_IP_PNP_BOOTP_MODULE 0
+#define __enabled_CONFIG_MMC_SDHCI_PXAV3 0
+#define __enabled_CONFIG_MMC_SDHCI_PXAV3_MODULE 0
+#define __enabled_CONFIG_USB_MUSB_HDRC 0
+#define __enabled_CONFIG_USB_MUSB_HDRC_MODULE 0
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define __enabled_CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define __enabled_CONFIG_PREVENT_FIRMWARE_BUILD_MODULE 0
+#define __enabled_CONFIG_CRYPTO_TWOFISH 0
+#define __enabled_CONFIG_CRYPTO_TWOFISH_MODULE 0
+#define CONFIG_FREEZER 1
+#define __enabled_CONFIG_FREEZER 1
+#define __enabled_CONFIG_FREEZER_MODULE 0
+#define __enabled_CONFIG_USB_TEST 0
+#define __enabled_CONFIG_USB_TEST_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_MAX11801 0
+#define __enabled_CONFIG_TOUCHSCREEN_MAX11801_MODULE 0
+#define __enabled_CONFIG_BT 0
+#define __enabled_CONFIG_BT_MODULE 0
+#define __enabled_CONFIG_DEPRECATED_PARAM_STRUCT 0
+#define __enabled_CONFIG_DEPRECATED_PARAM_STRUCT_MODULE 0
+#define CONFIG_LCD_PLATFORM 1
+#define __enabled_CONFIG_LCD_PLATFORM 1
+#define __enabled_CONFIG_LCD_PLATFORM_MODULE 0
+#define __enabled_CONFIG_SENSORS_IT87 0
+#define __enabled_CONFIG_SENSORS_IT87_MODULE 0
+#define __enabled_CONFIG_PARPORT 0
+#define __enabled_CONFIG_PARPORT_MODULE 0
+#define __enabled_CONFIG_HEADERS_CHECK 0
+#define __enabled_CONFIG_HEADERS_CHECK_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_TRYLOCK_BH 0
+#define __enabled_CONFIG_INLINE_SPIN_TRYLOCK_BH_MODULE 0
+#define CONFIG_RTC_LIB 1
+#define __enabled_CONFIG_RTC_LIB 1
+#define __enabled_CONFIG_RTC_LIB_MODULE 0
+#define CONFIG_HAVE_KPROBES 1
+#define __enabled_CONFIG_HAVE_KPROBES 1
+#define __enabled_CONFIG_HAVE_KPROBES_MODULE 0
+#define __enabled_CONFIG_TPS65010 0
+#define __enabled_CONFIG_TPS65010_MODULE 0
+#define __enabled_CONFIG_MOUSE_SYNAPTICS_I2C 0
+#define __enabled_CONFIG_MOUSE_SYNAPTICS_I2C_MODULE 0
+#define __enabled_CONFIG_ENC28J60 0
+#define __enabled_CONFIG_ENC28J60_MODULE 0
+#define __enabled_CONFIG_MOUSE_PS2_TOUCHKIT 0
+#define __enabled_CONFIG_MOUSE_PS2_TOUCHKIT_MODULE 0
+#define CONFIG_CRYPTO_AES_MODULE 1
+#define __enabled_CONFIG_CRYPTO_AES 0
+#define __enabled_CONFIG_CRYPTO_AES_MODULE 1
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_IRQSAVE 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_IRQSAVE_MODULE 0
+#define CONFIG_GPIOLIB 1
+#define __enabled_CONFIG_GPIOLIB 1
+#define __enabled_CONFIG_GPIOLIB_MODULE 0
+#define __enabled_CONFIG_SSB 0
+#define __enabled_CONFIG_SSB_MODULE 0
+#define __enabled_CONFIG_MMC_DW 0
+#define __enabled_CONFIG_MMC_DW_MODULE 0
+#define __enabled_CONFIG_I2C_STUB 0
+#define __enabled_CONFIG_I2C_STUB_MODULE 0
+#define __enabled_CONFIG_FB_SVGALIB 0
+#define __enabled_CONFIG_FB_SVGALIB_MODULE 0
+#define CONFIG_HID_PID 1
+#define __enabled_CONFIG_HID_PID 1
+#define __enabled_CONFIG_HID_PID_MODULE 0
+#define __enabled_CONFIG_ARCH_EP93XX 0
+#define __enabled_CONFIG_ARCH_EP93XX_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX6639 0
+#define __enabled_CONFIG_SENSORS_MAX6639_MODULE 0
+#define __enabled_CONFIG_GAMEPORT 0
+#define __enabled_CONFIG_GAMEPORT_MODULE 0
+#define __enabled_CONFIG_ISO9660_FS 0
+#define __enabled_CONFIG_ISO9660_FS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS3232 0
+#define __enabled_CONFIG_RTC_DRV_DS3232_MODULE 0
+#define __enabled_CONFIG_UIO 0
+#define __enabled_CONFIG_UIO_MODULE 0
+#define __enabled_CONFIG_HID_WALTOP 0
+#define __enabled_CONFIG_HID_WALTOP_MODULE 0
+#define CONFIG_NETFILTER 1
+#define __enabled_CONFIG_NETFILTER 1
+#define __enabled_CONFIG_NETFILTER_MODULE 0
+#define __enabled_CONFIG_USB_R8A66597_HCD 0
+#define __enabled_CONFIG_USB_R8A66597_HCD_MODULE 0
+#define __enabled_CONFIG_USB_MDC800 0
+#define __enabled_CONFIG_USB_MDC800_MODULE 0
+#define __enabled_CONFIG_HWMON_VID 0
+#define __enabled_CONFIG_HWMON_VID_MODULE 0
+#define CONFIG_SERIO_SERPORT 1
+#define __enabled_CONFIG_SERIO_SERPORT 1
+#define __enabled_CONFIG_SERIO_SERPORT_MODULE 0
+#define __enabled_CONFIG_FB_BOOT_VESA_SUPPORT 0
+#define __enabled_CONFIG_FB_BOOT_VESA_SUPPORT_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_950 0
+#define __enabled_CONFIG_NLS_CODEPAGE_950_MODULE 0
+#define CONFIG_S3C_DEV_USB_HOST 1
+#define __enabled_CONFIG_S3C_DEV_USB_HOST 1
+#define __enabled_CONFIG_S3C_DEV_USB_HOST_MODULE 0
+#define __enabled_CONFIG_PROFILE_ANNOTATED_BRANCHES 0
+#define __enabled_CONFIG_PROFILE_ANNOTATED_BRANCHES_MODULE 0
+#define CONFIG_DM9000_DEBUGLEVEL 4
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_RD_XZ 1
+#define __enabled_CONFIG_RD_XZ 1
+#define __enabled_CONFIG_RD_XZ_MODULE 0
+#define CONFIG_IP_MROUTE 1
+#define __enabled_CONFIG_IP_MROUTE 1
+#define __enabled_CONFIG_IP_MROUTE_MODULE 0
+#define __enabled_CONFIG_INET_XFRM_MODE_TUNNEL 0
+#define __enabled_CONFIG_INET_XFRM_MODE_TUNNEL_MODULE 0
+#define __enabled_CONFIG_PREEMPT_RCU 0
+#define __enabled_CONFIG_PREEMPT_RCU_MODULE 0
+#define __enabled_CONFIG_FONT_PEARL_8x8 0
+#define __enabled_CONFIG_FONT_PEARL_8x8_MODULE 0
+#define __enabled_CONFIG_XFS_FS 0
+#define __enabled_CONFIG_XFS_FS_MODULE 0
+#define __enabled_CONFIG_SENSORS_DME1737 0
+#define __enabled_CONFIG_SENSORS_DME1737_MODULE 0
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define __enabled_CONFIG_LOCKDEP_SUPPORT 1
+#define __enabled_CONFIG_LOCKDEP_SUPPORT_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_ELO 0
+#define __enabled_CONFIG_TOUCHSCREEN_ELO_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_869 0
+#define __enabled_CONFIG_NLS_CODEPAGE_869_MODULE 0
+#define __enabled_CONFIG_FB_FOREIGN_ENDIAN 0
+#define __enabled_CONFIG_FB_FOREIGN_ENDIAN_MODULE 0
+#define CONFIG_SERIAL_SAMSUNG_UARTS 3
+#define __enabled_CONFIG_DEBUG_ATOMIC_SLEEP 0
+#define __enabled_CONFIG_DEBUG_ATOMIC_SLEEP_MODULE 0
+#define CONFIG_POSIX_MQUEUE 1
+#define __enabled_CONFIG_POSIX_MQUEUE 1
+#define __enabled_CONFIG_POSIX_MQUEUE_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHIT213 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE 0
+#define CONFIG_BINFMT_AOUT_MODULE 1
+#define __enabled_CONFIG_BINFMT_AOUT 0
+#define __enabled_CONFIG_BINFMT_AOUT_MODULE 1
+#define __enabled_CONFIG_USB_ARCH_HAS_EHCI 0
+#define __enabled_CONFIG_USB_ARCH_HAS_EHCI_MODULE 0
+#define __enabled_CONFIG_ARCH_U8500 0
+#define __enabled_CONFIG_ARCH_U8500_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM83 0
+#define __enabled_CONFIG_SENSORS_LM83_MODULE 0
+#define CONFIG_MTD_BLKDEVS 1
+#define __enabled_CONFIG_MTD_BLKDEVS 1
+#define __enabled_CONFIG_MTD_BLKDEVS_MODULE 0
+#define __enabled_CONFIG_ACORN_PARTITION 0
+#define __enabled_CONFIG_ACORN_PARTITION_MODULE 0
+#define __enabled_CONFIG_ARCH_S5PV210 0
+#define __enabled_CONFIG_ARCH_S5PV210_MODULE 0
+#define __enabled_CONFIG_DEBUG_SPINLOCK 0
+#define __enabled_CONFIG_DEBUG_SPINLOCK_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_15 0
+#define __enabled_CONFIG_NLS_ISO8859_15_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_EETI 0
+#define __enabled_CONFIG_TOUCHSCREEN_EETI_MODULE 0
+#define CONFIG_AUTOFS4_FS 1
+#define __enabled_CONFIG_AUTOFS4_FS 1
+#define __enabled_CONFIG_AUTOFS4_FS_MODULE 0
+#define CONFIG_SYSCTL_SYSCALL 1
+#define __enabled_CONFIG_SYSCTL_SYSCALL 1
+#define __enabled_CONFIG_SYSCTL_SYSCALL_MODULE 0
+#define CONFIG_I2C_S3C2410 1
+#define __enabled_CONFIG_I2C_S3C2410 1
+#define __enabled_CONFIG_I2C_S3C2410_MODULE 0
+#define __enabled_CONFIG_DEBUG_WRITECOUNT 0
+#define __enabled_CONFIG_DEBUG_WRITECOUNT_MODULE 0
+#define __enabled_CONFIG_TASKSTATS 0
+#define __enabled_CONFIG_TASKSTATS_MODULE 0
+#define __enabled_CONFIG_ROMFS_BACKED_BY_MTD 0
+#define __enabled_CONFIG_ROMFS_BACKED_BY_MTD_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_932 0
+#define __enabled_CONFIG_NLS_CODEPAGE_932_MODULE 0
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_NEED_DMA_MAP_STATE 1
+#define __enabled_CONFIG_NEED_DMA_MAP_STATE 1
+#define __enabled_CONFIG_NEED_DMA_MAP_STATE_MODULE 0
+#define CONFIG_SERIO_LIBPS2 1
+#define __enabled_CONFIG_SERIO_LIBPS2 1
+#define __enabled_CONFIG_SERIO_LIBPS2_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_DRBD 0
+#define __enabled_CONFIG_BLK_DEV_DRBD_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_MODULE 0
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define __enabled_CONFIG_USB_PRINTER 0
+#define __enabled_CONFIG_USB_PRINTER_MODULE 0
+#define CONFIG_FONT_8x8 1
+#define __enabled_CONFIG_FONT_8x8 1
+#define __enabled_CONFIG_FONT_8x8_MODULE 0
+#define __enabled_CONFIG_SMC91X 0
+#define __enabled_CONFIG_SMC91X_MODULE 0
+#define __enabled_CONFIG_HID_TWINHAN 0
+#define __enabled_CONFIG_HID_TWINHAN_MODULE 0
+#define __enabled_CONFIG_SENSORS_NTC_THERMISTOR 0
+#define __enabled_CONFIG_SENSORS_NTC_THERMISTOR_MODULE 0
+#define __enabled_CONFIG_GPIO_SX150X 0
+#define __enabled_CONFIG_GPIO_SX150X_MODULE 0
+#define __enabled_CONFIG_SPI_OC_TINY 0
+#define __enabled_CONFIG_SPI_OC_TINY_MODULE 0
+#define __enabled_CONFIG_SENSORS_DS1621 0
+#define __enabled_CONFIG_SENSORS_DS1621_MODULE 0
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define __enabled_CONFIG_INPUT_JOYSTICK 0
+#define __enabled_CONFIG_INPUT_JOYSTICK_MODULE 0
+#define __enabled_CONFIG_QNX4FS_FS 0
+#define __enabled_CONFIG_QNX4FS_FS_MODULE 0
+#define __enabled_CONFIG_USB_OXU210HP_HCD 0
+#define __enabled_CONFIG_USB_OXU210HP_HCD_MODULE 0
+#define __enabled_CONFIG_USB_LED 0
+#define __enabled_CONFIG_USB_LED_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_WACOM_W8001 0
+#define __enabled_CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE 0
+#define CONFIG_PREEMPT_NONE 1
+#define __enabled_CONFIG_PREEMPT_NONE 1
+#define __enabled_CONFIG_PREEMPT_NONE_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_MODULE 0
+#define __enabled_CONFIG_IP_VS 0
+#define __enabled_CONFIG_IP_VS_MODULE 0
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define __enabled_CONFIG_HAVE_KERNEL_GZIP 1
+#define __enabled_CONFIG_HAVE_KERNEL_GZIP_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RP5C01 0
+#define __enabled_CONFIG_RTC_DRV_RP5C01_MODULE 0
+#define CONFIG_NEED_PER_CPU_KM 1
+#define __enabled_CONFIG_NEED_PER_CPU_KM 1
+#define __enabled_CONFIG_NEED_PER_CPU_KM_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TPS6507X 0
+#define __enabled_CONFIG_TOUCHSCREEN_TPS6507X_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1390 0
+#define __enabled_CONFIG_RTC_DRV_DS1390_MODULE 0
+#define __enabled_CONFIG_L2TP 0
+#define __enabled_CONFIG_L2TP_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M41T93 0
+#define __enabled_CONFIG_RTC_DRV_M41T93_MODULE 0
+#define __enabled_CONFIG_KALLSYMS_ALL 0
+#define __enabled_CONFIG_KALLSYMS_ALL_MODULE 0
+#define CONFIG_LIBCRC32C_MODULE 1
+#define __enabled_CONFIG_LIBCRC32C 0
+#define __enabled_CONFIG_LIBCRC32C_MODULE 1
+#define __enabled_CONFIG_KEYBOARD_MATRIX 0
+#define __enabled_CONFIG_KEYBOARD_MATRIX_MODULE 0
+#define __enabled_CONFIG_MFD_PCF50633 0
+#define __enabled_CONFIG_MFD_PCF50633_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SHA256 0
+#define __enabled_CONFIG_CRYPTO_SHA256_MODULE 0
+#define __enabled_CONFIG_ARCH_IXP23XX 0
+#define __enabled_CONFIG_ARCH_IXP23XX_MODULE 0
+#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define __enabled_CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define __enabled_CONFIG_HAVE_FTRACE_MCOUNT_RECORD_MODULE 0
+#define CONFIG_INET_TCP_DIAG_MODULE 1
+#define __enabled_CONFIG_INET_TCP_DIAG 0
+#define __enabled_CONFIG_INET_TCP_DIAG_MODULE 1
+#define CONFIG_HID_SONY 1
+#define __enabled_CONFIG_HID_SONY 1
+#define __enabled_CONFIG_HID_SONY_MODULE 0
+#define CONFIG_RTC_INTF_DEV_UIE_EMUL 1
+#define __enabled_CONFIG_RTC_INTF_DEV_UIE_EMUL 1
+#define __enabled_CONFIG_RTC_INTF_DEV_UIE_EMUL_MODULE 0
+#define CONFIG_HW_CONSOLE 1
+#define __enabled_CONFIG_HW_CONSOLE 1
+#define __enabled_CONFIG_HW_CONSOLE_MODULE 0
+#define __enabled_CONFIG_USB_ETH_EEM 0
+#define __enabled_CONFIG_USB_ETH_EEM_MODULE 0
+#define __enabled_CONFIG_IPX 0
+#define __enabled_CONFIG_IPX_MODULE 0
+#define __enabled_CONFIG_FTMAC100 0
+#define __enabled_CONFIG_FTMAC100_MODULE 0
+#define __enabled_CONFIG_MMC_S3C_PIODMA 0
+#define __enabled_CONFIG_MMC_S3C_PIODMA_MODULE 0
+#define __enabled_CONFIG_OMFS_FS 0
+#define __enabled_CONFIG_OMFS_FS_MODULE 0
+#define __enabled_CONFIG_BACKLIGHT_ADP8870 0
+#define __enabled_CONFIG_BACKLIGHT_ADP8870_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_MTOUCH 0
+#define __enabled_CONFIG_TOUCHSCREEN_MTOUCH_MODULE 0
+#define CONFIG_HID_MONTEREY 1
+#define __enabled_CONFIG_HID_MONTEREY 1
+#define __enabled_CONFIG_HID_MONTEREY_MODULE 0
+#define __enabled_CONFIG_FB_UDL 0
+#define __enabled_CONFIG_FB_UDL_MODULE 0
+#define CONFIG_HID_EZKEY 1
+#define __enabled_CONFIG_HID_EZKEY 1
+#define __enabled_CONFIG_HID_EZKEY_MODULE 0
+#define __enabled_CONFIG_CPU_DCACHE_DISABLE 0
+#define __enabled_CONFIG_CPU_DCACHE_DISABLE_MODULE 0
+#define CONFIG_IOSCHED_NOOP 1
+#define __enabled_CONFIG_IOSCHED_NOOP 1
+#define __enabled_CONFIG_IOSCHED_NOOP_MODULE 0
+#define __enabled_CONFIG_SERIAL_NONSTANDARD 0
+#define __enabled_CONFIG_SERIAL_NONSTANDARD_MODULE 0
+#define CONFIG_BACKLIGHT_PWM 1
+#define __enabled_CONFIG_BACKLIGHT_PWM 1
+#define __enabled_CONFIG_BACKLIGHT_PWM_MODULE 0
+#define __enabled_CONFIG_QUOTACTL 0
+#define __enabled_CONFIG_QUOTACTL_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RX8581 0
+#define __enabled_CONFIG_RTC_DRV_RX8581_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CRYPTD 0
+#define __enabled_CONFIG_CRYPTO_CRYPTD_MODULE 0
+#define CONFIG_GENERIC_ACL 1
+#define __enabled_CONFIG_GENERIC_ACL 1
+#define __enabled_CONFIG_GENERIC_ACL_MODULE 0
+#define __enabled_CONFIG_BACKLIGHT_ADP8860 0
+#define __enabled_CONFIG_BACKLIGHT_ADP8860_MODULE 0
+#define CONFIG_DEBUG_KERNEL 1
+#define __enabled_CONFIG_DEBUG_KERNEL 1
+#define __enabled_CONFIG_DEBUG_KERNEL_MODULE 0
+#define CONFIG_MTD_RAM 1
+#define __enabled_CONFIG_MTD_RAM 1
+#define __enabled_CONFIG_MTD_RAM_MODULE 0
+#define __enabled_CONFIG_COMPAT_BRK 0
+#define __enabled_CONFIG_COMPAT_BRK_MODULE 0
+#define CONFIG_LOCALVERSION "-FriendlyARM"
+#define CONFIG_CPU_PABRT_LEGACY 1
+#define __enabled_CONFIG_CPU_PABRT_LEGACY 1
+#define __enabled_CONFIG_CPU_PABRT_LEGACY_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_XTKBD 0
+#define __enabled_CONFIG_KEYBOARD_XTKBD_MODULE 0
+#define CONFIG_CRYPTO 1
+#define __enabled_CONFIG_CRYPTO 1
+#define __enabled_CONFIG_CRYPTO_MODULE 0
+#define __enabled_CONFIG_FUNCTION_TRACER 0
+#define __enabled_CONFIG_FUNCTION_TRACER_MODULE 0
+#define __enabled_CONFIG_SENSORS_EMC6W201 0
+#define __enabled_CONFIG_SENSORS_EMC6W201_MODULE 0
+#define __enabled_CONFIG_USB_TRANCEVIBRATOR 0
+#define __enabled_CONFIG_USB_TRANCEVIBRATOR_MODULE 0
+#define __enabled_CONFIG_SCHED_DEBUG 0
+#define __enabled_CONFIG_SCHED_DEBUG_MODULE 0
+#define __enabled_CONFIG_BTRFS_FS 0
+#define __enabled_CONFIG_BTRFS_FS_MODULE 0
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define __enabled_CONFIG_IP_NF_IPTABLES 0
+#define __enabled_CONFIG_IP_NF_IPTABLES_MODULE 0
+#define CONFIG_CMDLINE ""
+#define __enabled_CONFIG_FB_VIRTUAL 0
+#define __enabled_CONFIG_FB_VIRTUAL_MODULE 0
+#define __enabled_CONFIG_SPI_GPIO 0
+#define __enabled_CONFIG_SPI_GPIO_MODULE 0
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define __enabled_CONFIG_HAVE_DMA_API_DEBUG 1
+#define __enabled_CONFIG_HAVE_DMA_API_DEBUG_MODULE 0
+#define __enabled_CONFIG_MFD_SM501 0
+#define __enabled_CONFIG_MFD_SM501_MODULE 0
+#define CONFIG_HID_SAMSUNG 1
+#define __enabled_CONFIG_HID_SAMSUNG 1
+#define __enabled_CONFIG_HID_SAMSUNG_MODULE 0
+#define CONFIG_IP_PIMSM_V2 1
+#define __enabled_CONFIG_IP_PIMSM_V2 1
+#define __enabled_CONFIG_IP_PIMSM_V2_MODULE 0
+#define __enabled_CONFIG_XFRM_STATISTICS 0
+#define __enabled_CONFIG_XFRM_STATISTICS_MODULE 0
+#define __enabled_CONFIG_GPIO_GENERIC_PLATFORM 0
+#define __enabled_CONFIG_GPIO_GENERIC_PLATFORM_MODULE 0
+#define __enabled_CONFIG_USB_ISIGHTFW 0
+#define __enabled_CONFIG_USB_ISIGHTFW_MODULE 0
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define __enabled_CONFIG_USB_ARCH_HAS_HCD 1
+#define __enabled_CONFIG_USB_ARCH_HAS_HCD_MODULE 0
+#define __enabled_CONFIG_DEBUG_FORCE_WEAK_PER_CPU 0
+#define __enabled_CONFIG_DEBUG_FORCE_WEAK_PER_CPU_MODULE 0
+#define __enabled_CONFIG_STRICT_DEVMEM 0
+#define __enabled_CONFIG_STRICT_DEVMEM_MODULE 0
+#define CONFIG_GENERIC_IRQ_SHOW 1
+#define __enabled_CONFIG_GENERIC_IRQ_SHOW 1
+#define __enabled_CONFIG_GENERIC_IRQ_SHOW_MODULE 0
+#define __enabled_CONFIG_MFD_MAX8925 0
+#define __enabled_CONFIG_MFD_MAX8925_MODULE 0
+#define CONFIG_ALIGNMENT_TRAP 1
+#define __enabled_CONFIG_ALIGNMENT_TRAP 1
+#define __enabled_CONFIG_ALIGNMENT_TRAP_MODULE 0
+#define CONFIG_DM9000 1
+#define __enabled_CONFIG_DM9000 1
+#define __enabled_CONFIG_DM9000_MODULE 0
+#define CONFIG_FB_S3C2410 1
+#define __enabled_CONFIG_FB_S3C2410 1
+#define __enabled_CONFIG_FB_S3C2410_MODULE 0
+#define CONFIG_SCSI_MOD 1
+#define __enabled_CONFIG_SCSI_MOD 1
+#define __enabled_CONFIG_SCSI_MOD_MODULE 0
+#define CONFIG_SERIAL_SAMSUNG_CONSOLE 1
+#define __enabled_CONFIG_SERIAL_SAMSUNG_CONSOLE 1
+#define __enabled_CONFIG_SERIAL_SAMSUNG_CONSOLE_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_MK712 0
+#define __enabled_CONFIG_TOUCHSCREEN_MK712_MODULE 0
+#define CONFIG_CRYPTO_CRC32C_MODULE 1
+#define __enabled_CONFIG_CRYPTO_CRC32C 0
+#define __enabled_CONFIG_CRYPTO_CRC32C_MODULE 1
+#define CONFIG_SERIAL_CORE 1
+#define __enabled_CONFIG_SERIAL_CORE 1
+#define __enabled_CONFIG_SERIAL_CORE_MODULE 0
+#define __enabled_CONFIG_FUSE_FS 0
+#define __enabled_CONFIG_FUSE_FS_MODULE 0
+#define CONFIG_UID16 1
+#define __enabled_CONFIG_UID16 1
+#define __enabled_CONFIG_UID16_MODULE 0
+#define __enabled_CONFIG_DW_DMAC 0
+#define __enabled_CONFIG_DW_DMAC_MODULE 0
+#define __enabled_CONFIG_ETHOC 0
+#define __enabled_CONFIG_ETHOC_MODULE 0
+#define __enabled_CONFIG_TREE_RCU_TRACE 0
+#define __enabled_CONFIG_TREE_RCU_TRACE_MODULE 0
+#define __enabled_CONFIG_EMBEDDED 0
+#define __enabled_CONFIG_EMBEDDED_MODULE 0
+#define CONFIG_HID_MICROSOFT 1
+#define __enabled_CONFIG_HID_MICROSOFT 1
+#define __enabled_CONFIG_HID_MICROSOFT_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_BH 0
+#define __enabled_CONFIG_INLINE_WRITE_LOCK_BH_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_S35390A 0
+#define __enabled_CONFIG_RTC_DRV_S35390A_MODULE 0
+#define CONFIG_HAVE_KRETPROBES 1
+#define __enabled_CONFIG_HAVE_KRETPROBES 1
+#define __enabled_CONFIG_HAVE_KRETPROBES_MODULE 0
+#define CONFIG_NFS_V4 1
+#define __enabled_CONFIG_NFS_V4 1
+#define __enabled_CONFIG_NFS_V4_MODULE 0
+#define __enabled_CONFIG_PMIC_ADP5520 0
+#define __enabled_CONFIG_PMIC_ADP5520_MODULE 0
+#define __enabled_CONFIG_MTD_SLRAM 0
+#define __enabled_CONFIG_MTD_SLRAM_MODULE 0
+#define CONFIG_INLINE_READ_UNLOCK 1
+#define __enabled_CONFIG_INLINE_READ_UNLOCK 1
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_MODULE 0
+#define CONFIG_MTD_ROM 1
+#define __enabled_CONFIG_MTD_ROM 1
+#define __enabled_CONFIG_MTD_ROM_MODULE 0
+#define CONFIG_HAS_DMA 1
+#define __enabled_CONFIG_HAS_DMA 1
+#define __enabled_CONFIG_HAS_DMA_MODULE 0
+#define __enabled_CONFIG_USB_FILE_STORAGE_TEST 0
+#define __enabled_CONFIG_USB_FILE_STORAGE_TEST_MODULE 0
+#define __enabled_CONFIG_SCSI 0
+#define __enabled_CONFIG_SCSI_MODULE 0
+#define CONFIG_FB_CFB_FILLRECT 1
+#define __enabled_CONFIG_FB_CFB_FILLRECT 1
+#define __enabled_CONFIG_FB_CFB_FILLRECT_MODULE 0
+#define CONFIG_SAMSUNG_GPIO_EXTRA 0
+#define __enabled_CONFIG_ARCH_VT8500 0
+#define __enabled_CONFIG_ARCH_VT8500_MODULE 0
+#define CONFIG_HID_CHICONY 1
+#define __enabled_CONFIG_HID_CHICONY 1
+#define __enabled_CONFIG_HID_CHICONY_MODULE 0
+#define CONFIG_HID 1
+#define __enabled_CONFIG_HID 1
+#define __enabled_CONFIG_HID_MODULE 0
+#define __enabled_CONFIG_DMADEVICES_DEBUG 0
+#define __enabled_CONFIG_DMADEVICES_DEBUG_MODULE 0
+#define __enabled_CONFIG_LOGIWII_FF 0
+#define __enabled_CONFIG_LOGIWII_FF_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_9 0
+#define __enabled_CONFIG_NLS_ISO8859_9_MODULE 0
+#define CONFIG_FIRMWARE_EDID 1
+#define __enabled_CONFIG_FIRMWARE_EDID 1
+#define __enabled_CONFIG_FIRMWARE_EDID_MODULE 0
+#define CONFIG_CLKDEV_LOOKUP 1
+#define __enabled_CONFIG_CLKDEV_LOOKUP 1
+#define __enabled_CONFIG_CLKDEV_LOOKUP_MODULE 0
+#define CONFIG_LEDS_TRIGGER_DEFAULT_ON 1
+#define __enabled_CONFIG_LEDS_TRIGGER_DEFAULT_ON 1
+#define __enabled_CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE 0
+#define CONFIG_FONT_8x16 1
+#define __enabled_CONFIG_FONT_8x16 1
+#define __enabled_CONFIG_FONT_8x16_MODULE 0
+#define CONFIG_ARCH_USES_GETTIMEOFFSET 1
+#define __enabled_CONFIG_ARCH_USES_GETTIMEOFFSET 1
+#define __enabled_CONFIG_ARCH_USES_GETTIMEOFFSET_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_CMOS 0
+#define __enabled_CONFIG_RTC_DRV_CMOS_MODULE 0
+#define __enabled_CONFIG_ADFS_FS 0
+#define __enabled_CONFIG_ADFS_FS_MODULE 0
+#define __enabled_CONFIG_SENSORS_AD7414 0
+#define __enabled_CONFIG_SENSORS_AD7414_MODULE 0
+#define __enabled_CONFIG_BONDING 0
+#define __enabled_CONFIG_BONDING_MODULE 0
+#define __enabled_CONFIG_DEBUG_STACK_USAGE 0
+#define __enabled_CONFIG_DEBUG_STACK_USAGE_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_EM3027 0
+#define __enabled_CONFIG_RTC_DRV_EM3027_MODULE 0
+#define __enabled_CONFIG_MMC_USHC 0
+#define __enabled_CONFIG_MMC_USHC_MODULE 0
+#define __enabled_CONFIG_SPI_TLE62X0 0
+#define __enabled_CONFIG_SPI_TLE62X0_MODULE 0
+#define __enabled_CONFIG_TPS6507X 0
+#define __enabled_CONFIG_TPS6507X_MODULE 0
+#define __enabled_CONFIG_PHYLIB 0
+#define __enabled_CONFIG_PHYLIB_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM77 0
+#define __enabled_CONFIG_SENSORS_LM77_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_874 0
+#define __enabled_CONFIG_NLS_CODEPAGE_874_MODULE 0
+#define __enabled_CONFIG_ULTRIX_PARTITION 0
+#define __enabled_CONFIG_ULTRIX_PARTITION_MODULE 0
+#define __enabled_CONFIG_NET_DSA 0
+#define __enabled_CONFIG_NET_DSA_MODULE 0
+#define __enabled_CONFIG_VIRTIO_BALLOON 0
+#define __enabled_CONFIG_VIRTIO_BALLOON_MODULE 0
+#define CONFIG_LOCALVERSION_AUTO 1
+#define __enabled_CONFIG_LOCALVERSION_AUTO 1
+#define __enabled_CONFIG_LOCALVERSION_AUTO_MODULE 0
+#define CONFIG_IPC_NS 1
+#define __enabled_CONFIG_IPC_NS 1
+#define __enabled_CONFIG_IPC_NS_MODULE 0
+#define CONFIG_MISC_FILESYSTEMS 1
+#define __enabled_CONFIG_MISC_FILESYSTEMS 1
+#define __enabled_CONFIG_MISC_FILESYSTEMS_MODULE 0
+#define CONFIG_FTRACE 1
+#define __enabled_CONFIG_FTRACE 1
+#define __enabled_CONFIG_FTRACE_MODULE 0
+#define __enabled_CONFIG_I2C_DEBUG_CORE 0
+#define __enabled_CONFIG_I2C_DEBUG_CORE_MODULE 0
+#define __enabled_CONFIG_MACH_OTOM 0
+#define __enabled_CONFIG_MACH_OTOM_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_ADP5588 0
+#define __enabled_CONFIG_KEYBOARD_ADP5588_MODULE 0
+#define CONFIG_HID_TOPSEED 1
+#define __enabled_CONFIG_HID_TOPSEED 1
+#define __enabled_CONFIG_HID_TOPSEED_MODULE 0
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define __enabled_CONFIG_DECOMPRESS_BZIP2 1
+#define __enabled_CONFIG_DECOMPRESS_BZIP2_MODULE 0
+#define __enabled_CONFIG_CORDIC 0
+#define __enabled_CONFIG_CORDIC_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADM1029 0
+#define __enabled_CONFIG_SENSORS_ADM1029_MODULE 0
+#define __enabled_CONFIG_KSM 0
+#define __enabled_CONFIG_KSM_MODULE 0
+#define __enabled_CONFIG_DECNET 0
+#define __enabled_CONFIG_DECNET_MODULE 0
+#define CONFIG_XZ_DEC_SPARC 1
+#define __enabled_CONFIG_XZ_DEC_SPARC 1
+#define __enabled_CONFIG_XZ_DEC_SPARC_MODULE 0
+#define __enabled_CONFIG_ARCH_SPARSEMEM_DEFAULT 0
+#define __enabled_CONFIG_ARCH_SPARSEMEM_DEFAULT_MODULE 0
+#define CONFIG_INLINE_READ_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_IRQ_MODULE 0
+#define CONFIG_HID_A4TECH 1
+#define __enabled_CONFIG_HID_A4TECH 1
+#define __enabled_CONFIG_HID_A4TECH_MODULE 0
+#define __enabled_CONFIG_I2C_DEBUG_ALGO 0
+#define __enabled_CONFIG_I2C_DEBUG_ALGO_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_860 0
+#define __enabled_CONFIG_NLS_CODEPAGE_860_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_ISL1208 0
+#define __enabled_CONFIG_RTC_DRV_ISL1208_MODULE 0
+#define __enabled_CONFIG_MACH_N30 0
+#define __enabled_CONFIG_MACH_N30_MODULE 0
+#define __enabled_CONFIG_LAPB 0
+#define __enabled_CONFIG_LAPB_MODULE 0
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+#define __enabled_CONFIG_IP_ROUTE_MULTIPATH 1
+#define __enabled_CONFIG_IP_ROUTE_MULTIPATH_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_PCF2123 0
+#define __enabled_CONFIG_RTC_DRV_PCF2123_MODULE 0
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define __enabled_CONFIG_INPUT_FF_MEMLESS 1
+#define __enabled_CONFIG_INPUT_FF_MEMLESS_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83627HF 0
+#define __enabled_CONFIG_SENSORS_W83627HF_MODULE 0
+#define __enabled_CONFIG_SMDK2440_CPU2442 0
+#define __enabled_CONFIG_SMDK2440_CPU2442_MODULE 0
+#define CONFIG_YAFFS_YAFFS2 1
+#define __enabled_CONFIG_YAFFS_YAFFS2 1
+#define __enabled_CONFIG_YAFFS_YAFFS2_MODULE 0
+#define __enabled_CONFIG_CRYPTO_XCBC 0
+#define __enabled_CONFIG_CRYPTO_XCBC_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_QT2160 0
+#define __enabled_CONFIG_KEYBOARD_QT2160_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADT7411 0
+#define __enabled_CONFIG_SENSORS_ADT7411_MODULE 0
+#define __enabled_CONFIG_SPI_DEBUG 0
+#define __enabled_CONFIG_SPI_DEBUG_MODULE 0
+#define __enabled_CONFIG_ARCH_NUC93X 0
+#define __enabled_CONFIG_ARCH_NUC93X_MODULE 0
+#define __enabled_CONFIG_MACVLAN 0
+#define __enabled_CONFIG_MACVLAN_MODULE 0
+#define __enabled_CONFIG_TPS6105X 0
+#define __enabled_CONFIG_TPS6105X_MODULE 0
+#define __enabled_CONFIG_PROFILING 0
+#define __enabled_CONFIG_PROFILING_MODULE 0
+#define __enabled_CONFIG_LEDS_LP5523 0
+#define __enabled_CONFIG_LEDS_LP5523_MODULE 0
+#define CONFIG_CRYPTO_ARC4 1
+#define __enabled_CONFIG_CRYPTO_ARC4 1
+#define __enabled_CONFIG_CRYPTO_ARC4_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_GPIO_POLLED 0
+#define __enabled_CONFIG_KEYBOARD_GPIO_POLLED_MODULE 0
+#define CONFIG_CRYPTO_MANAGER 1
+#define __enabled_CONFIG_CRYPTO_MANAGER 1
+#define __enabled_CONFIG_CRYPTO_MANAGER_MODULE 0
+#define CONFIG_EEPROM_AT24 1
+#define __enabled_CONFIG_EEPROM_AT24 1
+#define __enabled_CONFIG_EEPROM_AT24_MODULE 0
+#define CONFIG_MTD_NAND 1
+#define __enabled_CONFIG_MTD_NAND 1
+#define __enabled_CONFIG_MTD_NAND_MODULE 0
+#define CONFIG_RT_MUTEXES 1
+#define __enabled_CONFIG_RT_MUTEXES 1
+#define __enabled_CONFIG_RT_MUTEXES_MODULE 0
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define __enabled_CONFIG_RTC_DRV_TEST 0
+#define __enabled_CONFIG_RTC_DRV_TEST_MODULE 0
+#define __enabled_CONFIG_HID_ORTEK 0
+#define __enabled_CONFIG_HID_ORTEK_MODULE 0
+#define __enabled_CONFIG_PCI_SYSCALL 0
+#define __enabled_CONFIG_PCI_SYSCALL_MODULE 0
+#define __enabled_CONFIG_VMSPLIT_2G 0
+#define __enabled_CONFIG_VMSPLIT_2G_MODULE 0
+#define CONFIG_I2C_ALGOBIT 1
+#define __enabled_CONFIG_I2C_ALGOBIT 1
+#define __enabled_CONFIG_I2C_ALGOBIT_MODULE 0
+#define CONFIG_MMC_BLOCK 1
+#define __enabled_CONFIG_MMC_BLOCK 1
+#define __enabled_CONFIG_MMC_BLOCK_MODULE 0
+#define __enabled_CONFIG_ARCH_REALVIEW 0
+#define __enabled_CONFIG_ARCH_REALVIEW_MODULE 0
+#define __enabled_CONFIG_ABX500_CORE 0
+#define __enabled_CONFIG_ABX500_CORE_MODULE 0
+#define __enabled_CONFIG_EXPERT 0
+#define __enabled_CONFIG_EXPERT_MODULE 0
+#define CONFIG_CPU_CACHE_V4WT 1
+#define __enabled_CONFIG_CPU_CACHE_V4WT 1
+#define __enabled_CONFIG_CPU_CACHE_V4WT_MODULE 0
+#define __enabled_CONFIG_LCD_LTV350QV 0
+#define __enabled_CONFIG_LCD_LTV350QV_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_W90X900 0
+#define __enabled_CONFIG_TOUCHSCREEN_W90X900_MODULE 0
+#define __enabled_CONFIG_WIRELESS 0
+#define __enabled_CONFIG_WIRELESS_MODULE 0
+#define __enabled_CONFIG_SQUASHFS 0
+#define __enabled_CONFIG_SQUASHFS_MODULE 0
+#define CONFIG_PERF_USE_VMALLOC 1
+#define __enabled_CONFIG_PERF_USE_VMALLOC 1
+#define __enabled_CONFIG_PERF_USE_VMALLOC_MODULE 0
+#define __enabled_CONFIG_KGDB 0
+#define __enabled_CONFIG_KGDB_MODULE 0
+#define CONFIG_SERIO_RAW 1
+#define __enabled_CONFIG_SERIO_RAW 1
+#define __enabled_CONFIG_SERIO_RAW_MODULE 0
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define __enabled_CONFIG_TIPC 0
+#define __enabled_CONFIG_TIPC_MODULE 0
+#define CONFIG_FRAME_WARN 1024
+#define __enabled_CONFIG_DEBUG_INFO_REDUCED 0
+#define __enabled_CONFIG_DEBUG_INFO_REDUCED_MODULE 0
+#define CONFIG_USB_ETH_MODULE 1
+#define __enabled_CONFIG_USB_ETH 0
+#define __enabled_CONFIG_USB_ETH_MODULE 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define __enabled_CONFIG_GENERIC_HWEIGHT 1
+#define __enabled_CONFIG_GENERIC_HWEIGHT_MODULE 0
+#define CONFIG_INITRAMFS_SOURCE ""
+#define __enabled_CONFIG_CGROUPS 0
+#define __enabled_CONFIG_CGROUPS_MODULE 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG_MODULE 0
+#define CONFIG_MMC 1
+#define __enabled_CONFIG_MMC 1
+#define __enabled_CONFIG_MMC_MODULE 0
+#define __enabled_CONFIG_CRYPTO_SEQIV 0
+#define __enabled_CONFIG_CRYPTO_SEQIV_MODULE 0
+#define __enabled_CONFIG_PROVE_LOCKING 0
+#define __enabled_CONFIG_PROVE_LOCKING_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_AD7877 0
+#define __enabled_CONFIG_TOUCHSCREEN_AD7877_MODULE 0
+#define CONFIG_HID_LOGITECH 1
+#define __enabled_CONFIG_HID_LOGITECH 1
+#define __enabled_CONFIG_HID_LOGITECH_MODULE 0
+#define __enabled_CONFIG_ARCH_NETX 0
+#define __enabled_CONFIG_ARCH_NETX_MODULE 0
+#define __enabled_CONFIG_ARCH_IOP32X 0
+#define __enabled_CONFIG_ARCH_IOP32X_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM92 0
+#define __enabled_CONFIG_SENSORS_LM92_MODULE 0
+#define __enabled_CONFIG_USB_M66592 0
+#define __enabled_CONFIG_USB_M66592_MODULE 0
+#define __enabled_CONFIG_NFS_USE_LEGACY_DNS 0
+#define __enabled_CONFIG_NFS_USE_LEGACY_DNS_MODULE 0
+#define CONFIG_INLINE_SPIN_UNLOCK 1
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK 1
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_MODULE 0
+#define __enabled_CONFIG_USB_DEBUG 0
+#define __enabled_CONFIG_USB_DEBUG_MODULE 0
+#define __enabled_CONFIG_LEDS_LP3944 0
+#define __enabled_CONFIG_LEDS_LP3944_MODULE 0
+#define __enabled_CONFIG_MACH_VSTMS 0
+#define __enabled_CONFIG_MACH_VSTMS_MODULE 0
+#define __enabled_CONFIG_USB_SEVSEG 0
+#define __enabled_CONFIG_USB_SEVSEG_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_PCF8563 0
+#define __enabled_CONFIG_RTC_DRV_PCF8563_MODULE 0
+#define __enabled_CONFIG_SENSORS_SMSC47M1 0
+#define __enabled_CONFIG_SENSORS_SMSC47M1_MODULE 0
+#define CONFIG_USB_CDC_COMPOSITE_MODULE 1
+#define __enabled_CONFIG_USB_CDC_COMPOSITE 0
+#define __enabled_CONFIG_USB_CDC_COMPOSITE_MODULE 1
+#define __enabled_CONFIG_DCB 0
+#define __enabled_CONFIG_DCB_MODULE 0
+#define __enabled_CONFIG_MACH_ANUBIS 0
+#define __enabled_CONFIG_MACH_ANUBIS_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_S3C2410_DEBUG 0
+#define __enabled_CONFIG_MTD_NAND_S3C2410_DEBUG_MODULE 0
+#define CONFIG_HZ 200
+#define CONFIG_I2C_HELPER_AUTO 1
+#define __enabled_CONFIG_I2C_HELPER_AUTO 1
+#define __enabled_CONFIG_I2C_HELPER_AUTO_MODULE 0
+#define CONFIG_PLAT_S3C24XX 1
+#define __enabled_CONFIG_PLAT_S3C24XX 1
+#define __enabled_CONFIG_PLAT_S3C24XX_MODULE 0
+#define CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
+#define __enabled_CONFIG_INLINE_SPIN_UNLOCK_IRQ_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_4 0
+#define __enabled_CONFIG_NLS_ISO8859_4_MODULE 0
+#define __enabled_CONFIG_ARCH_IXP4XX 0
+#define __enabled_CONFIG_ARCH_IXP4XX_MODULE 0
+#define __enabled_CONFIG_FB_BACKLIGHT 0
+#define __enabled_CONFIG_FB_BACKLIGHT_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RX8025 0
+#define __enabled_CONFIG_RTC_DRV_RX8025_MODULE 0
+#define __enabled_CONFIG_MACH_OSIRIS 0
+#define __enabled_CONFIG_MACH_OSIRIS_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_LOCK 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_MODULE 0
+#define __enabled_CONFIG_CRYPTO_RMD160 0
+#define __enabled_CONFIG_CRYPTO_RMD160_MODULE 0
+#define __enabled_CONFIG_ARCH_H1940 0
+#define __enabled_CONFIG_ARCH_H1940_MODULE 0
+#define __enabled_CONFIG_ARM_PATCH_PHYS_VIRT 0
+#define __enabled_CONFIG_ARM_PATCH_PHYS_VIRT_MODULE 0
+#define __enabled_CONFIG_INET_AH 0
+#define __enabled_CONFIG_INET_AH_MODULE 0
+#define __enabled_CONFIG_SENSORS_ATXP1 0
+#define __enabled_CONFIG_SENSORS_ATXP1_MODULE 0
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define __enabled_CONFIG_UDF_FS 0
+#define __enabled_CONFIG_UDF_FS_MODULE 0
+#define __enabled_CONFIG_NETFILTER_DEBUG 0
+#define __enabled_CONFIG_NETFILTER_DEBUG_MODULE 0
+#define __enabled_CONFIG_VXFS_FS 0
+#define __enabled_CONFIG_VXFS_FS_MODULE 0
+#define CONFIG_NLATTR 1
+#define __enabled_CONFIG_NLATTR 1
+#define __enabled_CONFIG_NLATTR_MODULE 0
+#define CONFIG_TCP_CONG_CUBIC 1
+#define __enabled_CONFIG_TCP_CONG_CUBIC 1
+#define __enabled_CONFIG_TCP_CONG_CUBIC_MODULE 0
+#define __enabled_CONFIG_CEPH_FS 0
+#define __enabled_CONFIG_CEPH_FS_MODULE 0
+#define __enabled_CONFIG_SCSI_NETLINK 0
+#define __enabled_CONFIG_SCSI_NETLINK_MODULE 0
+#define CONFIG_SUSPEND_FREEZER 1
+#define __enabled_CONFIG_SUSPEND_FREEZER 1
+#define __enabled_CONFIG_SUSPEND_FREEZER_MODULE 0
+#define CONFIG_MMC_SDHCI 1
+#define __enabled_CONFIG_MMC_SDHCI 1
+#define __enabled_CONFIG_MMC_SDHCI_MODULE 0
+#define CONFIG_SAMSUNG_DEV_PWM 1
+#define __enabled_CONFIG_SAMSUNG_DEV_PWM 1
+#define __enabled_CONFIG_SAMSUNG_DEV_PWM_MODULE 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_8 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_8_MODULE 0
+#define __enabled_CONFIG_WATCHDOG_NOWAYOUT 0
+#define __enabled_CONFIG_WATCHDOG_NOWAYOUT_MODULE 0
+#define __enabled_CONFIG_LEDS_LT3593 0
+#define __enabled_CONFIG_LEDS_LT3593_MODULE 0
+#define __enabled_CONFIG_LOGITECH_FF 0
+#define __enabled_CONFIG_LOGITECH_FF_MODULE 0
+#define CONFIG_HID_KYE 1
+#define __enabled_CONFIG_HID_KYE 1
+#define __enabled_CONFIG_HID_KYE_MODULE 0
+#define CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define __enabled_CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define __enabled_CONFIG_MOUSE_PS2_TRACKPOINT_MODULE 0
+#define __enabled_CONFIG_MOUSE_VSXXXAA 0
+#define __enabled_CONFIG_MOUSE_VSXXXAA_MODULE 0
+#define __enabled_CONFIG_FIRMWARE_IN_KERNEL 0
+#define __enabled_CONFIG_FIRMWARE_IN_KERNEL_MODULE 0
+#define __enabled_CONFIG_IP_MROUTE_MULTIPLE_TABLES 0
+#define __enabled_CONFIG_IP_MROUTE_MULTIPLE_TABLES_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_ZMII 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_ZMII_MODULE 0
+#define __enabled_CONFIG_SOFT_WATCHDOG 0
+#define __enabled_CONFIG_SOFT_WATCHDOG_MODULE 0
+#define CONFIG_SYSFS 1
+#define __enabled_CONFIG_SYSFS 1
+#define __enabled_CONFIG_SYSFS_MODULE 0
+#define __enabled_CONFIG_SAMSUNG_PM_DEBUG 0
+#define __enabled_CONFIG_SAMSUNG_PM_DEBUG_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83791D 0
+#define __enabled_CONFIG_SENSORS_W83791D_MODULE 0
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define __enabled_CONFIG_INPUT_TOUCHSCREEN 1
+#define __enabled_CONFIG_INPUT_TOUCHSCREEN_MODULE 0
+#define CONFIG_ARM_THUMB 1
+#define __enabled_CONFIG_ARM_THUMB 1
+#define __enabled_CONFIG_ARM_THUMB_MODULE 0
+#define __enabled_CONFIG_ARPD 0
+#define __enabled_CONFIG_ARPD_MODULE 0
+#define CONFIG_MMC_S3C 1
+#define __enabled_CONFIG_MMC_S3C 1
+#define __enabled_CONFIG_MMC_S3C_MODULE 0
+#define __enabled_CONFIG_AFS_FS 0
+#define __enabled_CONFIG_AFS_FS_MODULE 0
+#define __enabled_CONFIG_FB_WMT_GE_ROPS 0
+#define __enabled_CONFIG_FB_WMT_GE_ROPS_MODULE 0
+#define __enabled_CONFIG_I2C_PARPORT_LIGHT 0
+#define __enabled_CONFIG_I2C_PARPORT_LIGHT_MODULE 0
+#define __enabled_CONFIG_NET_KEY_MIGRATE 0
+#define __enabled_CONFIG_NET_KEY_MIGRATE_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_BU21013 0
+#define __enabled_CONFIG_TOUCHSCREEN_BU21013_MODULE 0
+#define __enabled_CONFIG_CC_STACKPROTECTOR 0
+#define __enabled_CONFIG_CC_STACKPROTECTOR_MODULE 0
+#define CONFIG_I2C_SIMTEC 1
+#define __enabled_CONFIG_I2C_SIMTEC 1
+#define __enabled_CONFIG_I2C_SIMTEC_MODULE 0
+#define CONFIG_XZ_DEC_ARM 1
+#define __enabled_CONFIG_XZ_DEC_ARM 1
+#define __enabled_CONFIG_XZ_DEC_ARM_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_775 0
+#define __enabled_CONFIG_NLS_CODEPAGE_775_MODULE 0
+#define __enabled_CONFIG_MOUSE_SERIAL 0
+#define __enabled_CONFIG_MOUSE_SERIAL_MODULE 0
+#define __enabled_CONFIG_FB_SYS_FOPS 0
+#define __enabled_CONFIG_FB_SYS_FOPS_MODULE 0
+#define __enabled_CONFIG_WIMAX 0
+#define __enabled_CONFIG_WIMAX_MODULE 0
+#define __enabled_CONFIG_MEMSTICK 0
+#define __enabled_CONFIG_MEMSTICK_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_MPR121 0
+#define __enabled_CONFIG_KEYBOARD_MPR121_MODULE 0
+#define __enabled_CONFIG_MTD_COMPLEX_MAPPINGS 0
+#define __enabled_CONFIG_MTD_COMPLEX_MAPPINGS_MODULE 0
+#define CONFIG_FB 1
+#define __enabled_CONFIG_FB 1
+#define __enabled_CONFIG_FB_MODULE 0
+#define __enabled_CONFIG_MTD_DEBUG 0
+#define __enabled_CONFIG_MTD_DEBUG_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_865 0
+#define __enabled_CONFIG_NLS_CODEPAGE_865_MODULE 0
+#define CONFIG_I2C_COMPAT 1
+#define __enabled_CONFIG_I2C_COMPAT 1
+#define __enabled_CONFIG_I2C_COMPAT_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_OPENCORES 0
+#define __enabled_CONFIG_KEYBOARD_OPENCORES_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_IRQ 0
+#define __enabled_CONFIG_INLINE_READ_LOCK_IRQ_MODULE 0
+#define __enabled_CONFIG_ARCH_SA1100 0
+#define __enabled_CONFIG_ARCH_SA1100_MODULE 0
+#define __enabled_CONFIG_USB_OHCI_BIG_ENDIAN_DESC 0
+#define __enabled_CONFIG_USB_OHCI_BIG_ENDIAN_DESC_MODULE 0
+#define CONFIG_MSDOS_PARTITION 1
+#define __enabled_CONFIG_MSDOS_PARTITION 1
+#define __enabled_CONFIG_MSDOS_PARTITION_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_BH 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_BH_MODULE 0
+#define __enabled_CONFIG_PLAT_SPEAR 0
+#define __enabled_CONFIG_PLAT_SPEAR_MODULE 0
+#define __enabled_CONFIG_GPIO_ADP5588 0
+#define __enabled_CONFIG_GPIO_ADP5588_MODULE 0
+#define __enabled_CONFIG_SENSORS_TMP421 0
+#define __enabled_CONFIG_SENSORS_TMP421_MODULE 0
+#define __enabled_CONFIG_MMC_S3C_HW_SDIO_IRQ 0
+#define __enabled_CONFIG_MMC_S3C_HW_SDIO_IRQ_MODULE 0
+#define CONFIG_HAVE_OPROFILE 1
+#define __enabled_CONFIG_HAVE_OPROFILE 1
+#define __enabled_CONFIG_HAVE_OPROFILE_MODULE 0
+#define __enabled_CONFIG_SLUB_STATS 0
+#define __enabled_CONFIG_SLUB_STATS_MODULE 0
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define __enabled_CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define __enabled_CONFIG_HAVE_GENERIC_DMA_COHERENT_MODULE 0
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define __enabled_CONFIG_CPU_IDLE_GOV_LADDER 1
+#define __enabled_CONFIG_CPU_IDLE_GOV_LADDER_MODULE 0
+#define __enabled_CONFIG_THERMAL 0
+#define __enabled_CONFIG_THERMAL_MODULE 0
+#define __enabled_CONFIG_USB_ULPI 0
+#define __enabled_CONFIG_USB_ULPI_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHRIGHT 0
+#define __enabled_CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE 0
+#define CONFIG_IP_PNP_RARP 1
+#define __enabled_CONFIG_IP_PNP_RARP 1
+#define __enabled_CONFIG_IP_PNP_RARP_MODULE 0
+#define __enabled_CONFIG_LOGO_LINUX_VGA16 0
+#define __enabled_CONFIG_LOGO_LINUX_VGA16_MODULE 0
+#define __enabled_CONFIG_VETH 0
+#define __enabled_CONFIG_VETH_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_PCF8583 0
+#define __enabled_CONFIG_RTC_DRV_PCF8583_MODULE 0
+#define __enabled_CONFIG_MFD_TPS65912_I2C 0
+#define __enabled_CONFIG_MFD_TPS65912_I2C_MODULE 0
+#define __enabled_CONFIG_FB_CFB_REV_PIXELS_IN_BYTE 0
+#define __enabled_CONFIG_FB_CFB_REV_PIXELS_IN_BYTE_MODULE 0
+#define CONFIG_HID_PETALYNX 1
+#define __enabled_CONFIG_HID_PETALYNX 1
+#define __enabled_CONFIG_HID_PETALYNX_MODULE 0
+#define __enabled_CONFIG_ARCH_GEMINI 0
+#define __enabled_CONFIG_ARCH_GEMINI_MODULE 0
+#define __enabled_CONFIG_FAULT_INJECTION 0
+#define __enabled_CONFIG_FAULT_INJECTION_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83L786NG 0
+#define __enabled_CONFIG_SENSORS_W83L786NG_MODULE 0
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define __enabled_CONFIG_HAVE_ARCH_KGDB 1
+#define __enabled_CONFIG_HAVE_ARCH_KGDB_MODULE 0
+#define __enabled_CONFIG_ARCH_S3C2440 0
+#define __enabled_CONFIG_ARCH_S3C2440_MODULE 0
+#define __enabled_CONFIG_SERIAL_IFX6X60 0
+#define __enabled_CONFIG_SERIAL_IFX6X60_MODULE 0
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define __enabled_CONFIG_USB_ARCH_HAS_OHCI 1
+#define __enabled_CONFIG_USB_ARCH_HAS_OHCI_MODULE 0
+#define __enabled_CONFIG_USB_FUSB300 0
+#define __enabled_CONFIG_USB_FUSB300_MODULE 0
+#define CONFIG_ZONE_DMA_FLAG 0
+#define __enabled_CONFIG_ARCH_IXP2000 0
+#define __enabled_CONFIG_ARCH_IXP2000_MODULE 0
+#define __enabled_CONFIG_LOCK_STAT 0
+#define __enabled_CONFIG_LOCK_STAT_MODULE 0
+#define __enabled_CONFIG_USB_WUSB_CBAF 0
+#define __enabled_CONFIG_USB_WUSB_CBAF_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM95241 0
+#define __enabled_CONFIG_SENSORS_LM95241_MODULE 0
+#define __enabled_CONFIG_FB_METRONOME 0
+#define __enabled_CONFIG_FB_METRONOME_MODULE 0
+#define __enabled_CONFIG_RT_MUTEX_TESTER 0
+#define __enabled_CONFIG_RT_MUTEX_TESTER_MODULE 0
+#define CONFIG_LEGACY_PTY_COUNT 128
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_2_MODULE 0
+#define __enabled_CONFIG_MMC_SDHCI_S3C 0
+#define __enabled_CONFIG_MMC_SDHCI_S3C_MODULE 0
+#define __enabled_CONFIG_MTD_DOC2001PLUS 0
+#define __enabled_CONFIG_MTD_DOC2001PLUS_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM70 0
+#define __enabled_CONFIG_SENSORS_LM70_MODULE 0
+#define __enabled_CONFIG_FB_BROADSHEET 0
+#define __enabled_CONFIG_FB_BROADSHEET_MODULE 0
+#define __enabled_CONFIG_HTC_PASIC3 0
+#define __enabled_CONFIG_HTC_PASIC3_MODULE 0
+#define CONFIG_USB_ZERO_MODULE 1
+#define __enabled_CONFIG_USB_ZERO 0
+#define __enabled_CONFIG_USB_ZERO_MODULE 1
+#define __enabled_CONFIG_BLK_DEV_CRYPTOLOOP 0
+#define __enabled_CONFIG_BLK_DEV_CRYPTOLOOP_MODULE 0
+#define CONFIG_IP_MULTICAST 1
+#define __enabled_CONFIG_IP_MULTICAST 1
+#define __enabled_CONFIG_IP_MULTICAST_MODULE 0
+#define __enabled_CONFIG_CRYPTO_RMD256 0
+#define __enabled_CONFIG_CRYPTO_RMD256_MODULE 0
+#define __enabled_CONFIG_GCOV_KERNEL 0
+#define __enabled_CONFIG_GCOV_KERNEL_MODULE 0
+#define __enabled_CONFIG_MOUSE_APPLETOUCH 0
+#define __enabled_CONFIG_MOUSE_APPLETOUCH_MODULE 0
+#define CONFIG_DEFAULT_SECURITY ""
+#define __enabled_CONFIG_DEBUG_KMEMLEAK 0
+#define __enabled_CONFIG_DEBUG_KMEMLEAK_MODULE 0
+#define __enabled_CONFIG_CRYPTO_CTR 0
+#define __enabled_CONFIG_CRYPTO_CTR_MODULE 0
+#define __enabled_CONFIG_DEBUG_LOCKING_API_SELFTESTS 0
+#define __enabled_CONFIG_DEBUG_LOCKING_API_SELFTESTS_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RS5C348 0
+#define __enabled_CONFIG_RTC_DRV_RS5C348_MODULE 0
+#define __enabled_CONFIG_MMC_S3C_DMA 0
+#define __enabled_CONFIG_MMC_S3C_DMA_MODULE 0
+#define CONFIG_TINY_RCU 1
+#define __enabled_CONFIG_TINY_RCU 1
+#define __enabled_CONFIG_TINY_RCU_MODULE 0
+#define __enabled_CONFIG_MODVERSIONS 0
+#define __enabled_CONFIG_MODVERSIONS_MODULE 0
+#define CONFIG_HW_RANDOM 1
+#define __enabled_CONFIG_HW_RANDOM 1
+#define __enabled_CONFIG_HW_RANDOM_MODULE 0
+#define __enabled_CONFIG_MUTEX_SPIN_ON_OWNER 0
+#define __enabled_CONFIG_MUTEX_SPIN_ON_OWNER_MODULE 0
+#define __enabled_CONFIG_ARCH_VEXPRESS 0
+#define __enabled_CONFIG_ARCH_VEXPRESS_MODULE 0
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define __enabled_CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define __enabled_CONFIG_RWSEM_GENERIC_SPINLOCK_MODULE 0
+#define __enabled_CONFIG_SYS_HYPERVISOR 0
+#define __enabled_CONFIG_SYS_HYPERVISOR_MODULE 0
+#define __enabled_CONFIG_AMIGA_PARTITION 0
+#define __enabled_CONFIG_AMIGA_PARTITION_MODULE 0
+#define __enabled_CONFIG_DEBUG_DRIVER 0
+#define __enabled_CONFIG_DEBUG_DRIVER_MODULE 0
+#define __enabled_CONFIG_MTD_AR7_PARTS 0
+#define __enabled_CONFIG_MTD_AR7_PARTS_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADS7871 0
+#define __enabled_CONFIG_SENSORS_ADS7871_MODULE 0
+#define __enabled_CONFIG_DEFAULT_NOOP 0
+#define __enabled_CONFIG_DEFAULT_NOOP_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_737 0
+#define __enabled_CONFIG_NLS_CODEPAGE_737_MODULE 0
+#define CONFIG_DEBUG_S3C_UART 0
+#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define __enabled_CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define __enabled_CONFIG_HAVE_FUNCTION_GRAPH_TRACER_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83781D 0
+#define __enabled_CONFIG_SENSORS_W83781D_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_ECC_SMC 0
+#define __enabled_CONFIG_MTD_NAND_ECC_SMC_MODULE 0
+#define __enabled_CONFIG_NTFS_FS 0
+#define __enabled_CONFIG_NTFS_FS_MODULE 0
+#define __enabled_CONFIG_IP_SCTP 0
+#define __enabled_CONFIG_IP_SCTP_MODULE 0
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define __enabled_CONFIG_CRYPTO_BLKCIPHER2 1
+#define __enabled_CONFIG_CRYPTO_BLKCIPHER2_MODULE 0
+#define __enabled_CONFIG_XIP_KERNEL 0
+#define __enabled_CONFIG_XIP_KERNEL_MODULE 0
+#define __enabled_CONFIG_DEVPTS_MULTIPLE_INSTANCES 0
+#define __enabled_CONFIG_DEVPTS_MULTIPLE_INSTANCES_MODULE 0
+#define __enabled_CONFIG_COMPACTION 0
+#define __enabled_CONFIG_COMPACTION_MODULE 0
+#define __enabled_CONFIG_ARCH_NOMADIK 0
+#define __enabled_CONFIG_ARCH_NOMADIK_MODULE 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_16 0
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_16_MODULE 0
+#define __enabled_CONFIG_ARCH_SMDK2410 0
+#define __enabled_CONFIG_ARCH_SMDK2410_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1553 0
+#define __enabled_CONFIG_RTC_DRV_DS1553_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_HAMPSHIRE 0
+#define __enabled_CONFIG_TOUCHSCREEN_HAMPSHIRE_MODULE 0
+#define __enabled_CONFIG_CRYPTO_KHAZAD 0
+#define __enabled_CONFIG_CRYPTO_KHAZAD_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_TSC2005 0
+#define __enabled_CONFIG_TOUCHSCREEN_TSC2005_MODULE 0
+#define CONFIG_PROC_FS 1
+#define __enabled_CONFIG_PROC_FS 1
+#define __enabled_CONFIG_PROC_FS_MODULE 0
+#define CONFIG_MTD_BLOCK 1
+#define __enabled_CONFIG_MTD_BLOCK 1
+#define __enabled_CONFIG_MTD_BLOCK_MODULE 0
+#define __enabled_CONFIG_LCD_S6E63M0 0
+#define __enabled_CONFIG_LCD_S6E63M0_MODULE 0
+#define CONFIG_MTD_QINFO_PROBE 1
+#define __enabled_CONFIG_MTD_QINFO_PROBE 1
+#define __enabled_CONFIG_MTD_QINFO_PROBE_MODULE 0
+#define __enabled_CONFIG_NILFS2_FS 0
+#define __enabled_CONFIG_NILFS2_FS_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_3 0
+#define __enabled_CONFIG_NLS_ISO8859_3_MODULE 0
+#define CONFIG_HID_PANTHERLORD 1
+#define __enabled_CONFIG_HID_PANTHERLORD 1
+#define __enabled_CONFIG_HID_PANTHERLORD_MODULE 0
+#define __enabled_CONFIG_TEST_KSTRTOX 0
+#define __enabled_CONFIG_TEST_KSTRTOX_MODULE 0
+#define CONFIG_FLATMEM 1
+#define __enabled_CONFIG_FLATMEM 1
+#define __enabled_CONFIG_FLATMEM_MODULE 0
+#define __enabled_CONFIG_IDE 0
+#define __enabled_CONFIG_IDE_MODULE 0
+#define __enabled_CONFIG_MTD_OOPS 0
+#define __enabled_CONFIG_MTD_OOPS_MODULE 0
+#define __enabled_CONFIG_USB_PEGASUS 0
+#define __enabled_CONFIG_USB_PEGASUS_MODULE 0
+#define __enabled_CONFIG_USB_TMC 0
+#define __enabled_CONFIG_USB_TMC_MODULE 0
+#define __enabled_CONFIG_MMC_DEBUG 0
+#define __enabled_CONFIG_MMC_DEBUG_MODULE 0
+#define __enabled_CONFIG_SERIAL_MAX3107 0
+#define __enabled_CONFIG_SERIAL_MAX3107_MODULE 0
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define __enabled_CONFIG_PAGEFLAGS_EXTENDED 1
+#define __enabled_CONFIG_PAGEFLAGS_EXTENDED_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_BSGLIB 0
+#define __enabled_CONFIG_BLK_DEV_BSGLIB_MODULE 0
+#define __enabled_CONFIG_IKCONFIG 0
+#define __enabled_CONFIG_IKCONFIG_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_IRQRESTORE 0
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_IRQRESTORE_MODULE 0
+#define __enabled_CONFIG_DEBUG_LIST 0
+#define __enabled_CONFIG_DEBUG_LIST_MODULE 0
+#define CONFIG_NFS_USE_KERNEL_DNS 1
+#define __enabled_CONFIG_NFS_USE_KERNEL_DNS 1
+#define __enabled_CONFIG_NFS_USE_KERNEL_DNS_MODULE 0
+#define __enabled_CONFIG_SENSORS_IBMAEM 0
+#define __enabled_CONFIG_SENSORS_IBMAEM_MODULE 0
+#define CONFIG_SYSCTL 1
+#define __enabled_CONFIG_SYSCTL 1
+#define __enabled_CONFIG_SYSCTL_MODULE 0
+#define __enabled_CONFIG_ARCH_MSM 0
+#define __enabled_CONFIG_ARCH_MSM_MODULE 0
+#define __enabled_CONFIG_MTD_BLOCK2MTD 0
+#define __enabled_CONFIG_MTD_BLOCK2MTD_MODULE 0
+#define __enabled_CONFIG_PHYS_ADDR_T_64BIT 0
+#define __enabled_CONFIG_PHYS_ADDR_T_64BIT_MODULE 0
+#define CONFIG_HAVE_C_RECORDMCOUNT 1
+#define __enabled_CONFIG_HAVE_C_RECORDMCOUNT 1
+#define __enabled_CONFIG_HAVE_C_RECORDMCOUNT_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADCXX 0
+#define __enabled_CONFIG_SENSORS_ADCXX_MODULE 0
+#define __enabled_CONFIG_LCD_LD9040 0
+#define __enabled_CONFIG_LCD_LD9040_MODULE 0
+#define CONFIG_LDM_PARTITION 1
+#define __enabled_CONFIG_LDM_PARTITION 1
+#define __enabled_CONFIG_LDM_PARTITION_MODULE 0
+#define __enabled_CONFIG_CIFS 0
+#define __enabled_CONFIG_CIFS_MODULE 0
+#define CONFIG_XFRM_USER_MODULE 1
+#define __enabled_CONFIG_XFRM_USER 0
+#define __enabled_CONFIG_XFRM_USER_MODULE 1
+#define __enabled_CONFIG_LEDS_PCA9532 0
+#define __enabled_CONFIG_LEDS_PCA9532_MODULE 0
+#define CONFIG_NET_NS 1
+#define __enabled_CONFIG_NET_NS 1
+#define __enabled_CONFIG_NET_NS_MODULE 0
+#define __enabled_CONFIG_SENSORS_TMP401 0
+#define __enabled_CONFIG_SENSORS_TMP401_MODULE 0
+#define __enabled_CONFIG_SENSORS_ADT7475 0
+#define __enabled_CONFIG_SENSORS_ADT7475_MODULE 0
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define __enabled_CONFIG_HAVE_PERF_EVENTS 1
+#define __enabled_CONFIG_HAVE_PERF_EVENTS_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_GPIO 0
+#define __enabled_CONFIG_MTD_NAND_GPIO_MODULE 0
+#define __enabled_CONFIG_MACH_SMDK2443 0
+#define __enabled_CONFIG_MACH_SMDK2443_MODULE 0
+#define __enabled_CONFIG_CRYPTO_LRW 0
+#define __enabled_CONFIG_CRYPTO_LRW_MODULE 0
+#define CONFIG_EXT3_FS_SECURITY 1
+#define __enabled_CONFIG_EXT3_FS_SECURITY 1
+#define __enabled_CONFIG_EXT3_FS_SECURITY_MODULE 0
+#define __enabled_CONFIG_ARCH_S5PC100 0
+#define __enabled_CONFIG_ARCH_S5PC100_MODULE 0
+#define CONFIG_MACH_MINI2440 1
+#define __enabled_CONFIG_MACH_MINI2440 1
+#define __enabled_CONFIG_MACH_MINI2440_MODULE 0
+#define __enabled_CONFIG_NLS_CODEPAGE_866 0
+#define __enabled_CONFIG_NLS_CODEPAGE_866_MODULE 0
+#define CONFIG_CRAMFS 1
+#define __enabled_CONFIG_CRAMFS 1
+#define __enabled_CONFIG_CRAMFS_MODULE 0
+#define __enabled_CONFIG_SLAB 0
+#define __enabled_CONFIG_SLAB_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_LM8323 0
+#define __enabled_CONFIG_KEYBOARD_LM8323_MODULE 0
+#define __enabled_CONFIG_ARCH_IOP13XX 0
+#define __enabled_CONFIG_ARCH_IOP13XX_MODULE 0
+#define __enabled_CONFIG_YAFFS_EMPTY_LOST_AND_FOUND 0
+#define __enabled_CONFIG_YAFFS_EMPTY_LOST_AND_FOUND_MODULE 0
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define __enabled_CONFIG_DEBUG_MEMORY_INIT 1
+#define __enabled_CONFIG_DEBUG_MEMORY_INIT_MODULE 0
+#define __enabled_CONFIG_AUDIT 0
+#define __enabled_CONFIG_AUDIT_MODULE 0
+#define __enabled_CONFIG_CRYPTO_USER_API_SKCIPHER 0
+#define __enabled_CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE 0
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define __enabled_CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define __enabled_CONFIG_SYS_SUPPORTS_APM_EMULATION_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM80 0
+#define __enabled_CONFIG_SENSORS_LM80_MODULE 0
+#define __enabled_CONFIG_HID_MULTITOUCH 0
+#define __enabled_CONFIG_HID_MULTITOUCH_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_IRQ 0
+#define __enabled_CONFIG_INLINE_SPIN_LOCK_IRQ_MODULE 0
+#define CONFIG_S3C_GPIO_SPACE 0
+#define __enabled_CONFIG_SECURITY 0
+#define __enabled_CONFIG_SECURITY_MODULE 0
+#define __enabled_CONFIG_SENSORS_ASC7621 0
+#define __enabled_CONFIG_SENSORS_ASC7621_MODULE 0
+#define __enabled_CONFIG_DEBUG_CREDENTIALS 0
+#define __enabled_CONFIG_DEBUG_CREDENTIALS_MODULE 0
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_BLK_DEV 1
+#define __enabled_CONFIG_BLK_DEV 1
+#define __enabled_CONFIG_BLK_DEV_MODULE 0
+#define CONFIG_NFS_ACL_SUPPORT 1
+#define __enabled_CONFIG_NFS_ACL_SUPPORT 1
+#define __enabled_CONFIG_NFS_ACL_SUPPORT_MODULE 0
+#define __enabled_CONFIG_HVC_DCC 0
+#define __enabled_CONFIG_HVC_DCC_MODULE 0
+#define CONFIG_TRACING_SUPPORT 1
+#define __enabled_CONFIG_TRACING_SUPPORT 1
+#define __enabled_CONFIG_TRACING_SUPPORT_MODULE 0
+#define CONFIG_UNIX98_PTYS 1
+#define __enabled_CONFIG_UNIX98_PTYS 1
+#define __enabled_CONFIG_UNIX98_PTYS_MODULE 0
+#define __enabled_CONFIG_CDROM_PKTCDVD 0
+#define __enabled_CONFIG_CDROM_PKTCDVD_MODULE 0
+#define CONFIG_MINIX_SUBPARTITION 1
+#define __enabled_CONFIG_MINIX_SUBPARTITION 1
+#define __enabled_CONFIG_MINIX_SUBPARTITION_MODULE 0
+#define __enabled_CONFIG_SENSORS_SMSC47B397 0
+#define __enabled_CONFIG_SENSORS_SMSC47B397_MODULE 0
+#define __enabled_CONFIG_CRYPTO_MICHAEL_MIC 0
+#define __enabled_CONFIG_CRYPTO_MICHAEL_MIC_MODULE 0
+#define __enabled_CONFIG_CRYPTO_ANSI_CPRNG 0
+#define __enabled_CONFIG_CRYPTO_ANSI_CPRNG_MODULE 0
+#define __enabled_CONFIG_NET_SCHED 0
+#define __enabled_CONFIG_NET_SCHED_MODULE 0
+#define CONFIG_JBD 1
+#define __enabled_CONFIG_JBD 1
+#define __enabled_CONFIG_JBD_MODULE 0
+#define __enabled_CONFIG_PRINTK_TIME 0
+#define __enabled_CONFIG_PRINTK_TIME_MODULE 0
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define __enabled_CONFIG_PPP 0
+#define __enabled_CONFIG_PPP_MODULE 0
+#define CONFIG_RFD_FTL 1
+#define __enabled_CONFIG_RFD_FTL 1
+#define __enabled_CONFIG_RFD_FTL_MODULE 0
+#define __enabled_CONFIG_FB_MACMODES 0
+#define __enabled_CONFIG_FB_MACMODES_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_ATMEL_MXT 0
+#define __enabled_CONFIG_TOUCHSCREEN_ATMEL_MXT_MODULE 0
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define __enabled_CONFIG_HAVE_KERNEL_LZO 1
+#define __enabled_CONFIG_HAVE_KERNEL_LZO_MODULE 0
+#define CONFIG_INET_DIAG_MODULE 1
+#define __enabled_CONFIG_INET_DIAG 0
+#define __enabled_CONFIG_INET_DIAG_MODULE 1
+#define __enabled_CONFIG_CRYPTO_GHASH 0
+#define __enabled_CONFIG_CRYPTO_GHASH_MODULE 0
+#define __enabled_CONFIG_PSTORE 0
+#define __enabled_CONFIG_PSTORE_MODULE 0
+#define __enabled_CONFIG_CRYPTO_RMD320 0
+#define __enabled_CONFIG_CRYPTO_RMD320_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83627EHF 0
+#define __enabled_CONFIG_SENSORS_W83627EHF_MODULE 0
+#define CONFIG_ELF_CORE 1
+#define __enabled_CONFIG_ELF_CORE 1
+#define __enabled_CONFIG_ELF_CORE_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM73 0
+#define __enabled_CONFIG_SENSORS_LM73_MODULE 0
+#define __enabled_CONFIG_ARCH_W90X900 0
+#define __enabled_CONFIG_ARCH_W90X900_MODULE 0
+#define __enabled_CONFIG_SENSORS_PC87360 0
+#define __enabled_CONFIG_SENSORS_PC87360_MODULE 0
+#define CONFIG_CPU_ARM920T 1
+#define __enabled_CONFIG_CPU_ARM920T 1
+#define __enabled_CONFIG_CPU_ARM920T_MODULE 0
+#define __enabled_CONFIG_KS8851 0
+#define __enabled_CONFIG_KS8851_MODULE 0
+#define CONFIG_MTD_JEDECPROBE 1
+#define __enabled_CONFIG_MTD_JEDECPROBE 1
+#define __enabled_CONFIG_MTD_JEDECPROBE_MODULE 0
+#define __enabled_CONFIG_MACH_TCT_HAMMER 0
+#define __enabled_CONFIG_MACH_TCT_HAMMER_MODULE 0
+#define CONFIG_USB_SUPPORT 1
+#define __enabled_CONFIG_USB_SUPPORT 1
+#define __enabled_CONFIG_USB_SUPPORT_MODULE 0
+#define __enabled_CONFIG_INPUT_POLLDEV 0
+#define __enabled_CONFIG_INPUT_POLLDEV_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_BQ32K 0
+#define __enabled_CONFIG_RTC_DRV_BQ32K_MODULE 0
+#define __enabled_CONFIG_RTC_DEBUG 0
+#define __enabled_CONFIG_RTC_DEBUG_MODULE 0
+#define __enabled_CONFIG_S3C_BOOT_WATCHDOG 0
+#define __enabled_CONFIG_S3C_BOOT_WATCHDOG_MODULE 0
+#define __enabled_CONFIG_TWL4030_CORE 0
+#define __enabled_CONFIG_TWL4030_CORE_MODULE 0
+#define __enabled_CONFIG_USB_HWA_HCD 0
+#define __enabled_CONFIG_USB_HWA_HCD_MODULE 0
+#define __enabled_CONFIG_STAGING 0
+#define __enabled_CONFIG_STAGING_MODULE 0
+#define CONFIG_MTD_CHAR 1
+#define __enabled_CONFIG_MTD_CHAR 1
+#define __enabled_CONFIG_MTD_CHAR_MODULE 0
+#define __enabled_CONFIG_SENSORS_LIS3LV02D 0
+#define __enabled_CONFIG_SENSORS_LIS3LV02D_MODULE 0
+#define __enabled_CONFIG_INET_LRO 0
+#define __enabled_CONFIG_INET_LRO_MODULE 0
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define __enabled_CONFIG_FLAT_NODE_MEM_MAP 1
+#define __enabled_CONFIG_FLAT_NODE_MEM_MAP_MODULE 0
+#define __enabled_CONFIG_ATM 0
+#define __enabled_CONFIG_ATM_MODULE 0
+#define __enabled_CONFIG_MAX63XX_WATCHDOG 0
+#define __enabled_CONFIG_MAX63XX_WATCHDOG_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_ST1232 0
+#define __enabled_CONFIG_TOUCHSCREEN_ST1232_MODULE 0
+#define CONFIG_VT_CONSOLE 1
+#define __enabled_CONFIG_VT_CONSOLE 1
+#define __enabled_CONFIG_VT_CONSOLE_MODULE 0
+#define __enabled_CONFIG_HID_UCLOGIC 0
+#define __enabled_CONFIG_HID_UCLOGIC_MODULE 0
+#define CONFIG_LEDS_GPIO 1
+#define __enabled_CONFIG_LEDS_GPIO 1
+#define __enabled_CONFIG_LEDS_GPIO_MODULE 0
+#define __enabled_CONFIG_NOP_USB_XCEIV 0
+#define __enabled_CONFIG_NOP_USB_XCEIV_MODULE 0
+#define CONFIG_BLK_DEV_RAM 1
+#define __enabled_CONFIG_BLK_DEV_RAM 1
+#define __enabled_CONFIG_BLK_DEV_RAM_MODULE 0
+#define __enabled_CONFIG_ARCH_FOOTBRIDGE 0
+#define __enabled_CONFIG_ARCH_FOOTBRIDGE_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_AD7879 0
+#define __enabled_CONFIG_TOUCHSCREEN_AD7879_MODULE 0
+#define CONFIG_INPUT_EVBUG_MODULE 1
+#define __enabled_CONFIG_INPUT_EVBUG 0
+#define __enabled_CONFIG_INPUT_EVBUG_MODULE 1
+#define __enabled_CONFIG_LOGIRUMBLEPAD2_FF 0
+#define __enabled_CONFIG_LOGIRUMBLEPAD2_FF_MODULE 0
+#define __enabled_CONFIG_MFD_TPS6586X 0
+#define __enabled_CONFIG_MFD_TPS6586X_MODULE 0
+#define CONFIG_BSD_DISKLABEL 1
+#define __enabled_CONFIG_BSD_DISKLABEL 1
+#define __enabled_CONFIG_BSD_DISKLABEL_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M48T35 0
+#define __enabled_CONFIG_RTC_DRV_M48T35_MODULE 0
+#define __enabled_CONFIG_I2C_TAOS_EVM 0
+#define __enabled_CONFIG_I2C_TAOS_EVM_MODULE 0
+#define __enabled_CONFIG_MMC_TEST 0
+#define __enabled_CONFIG_MMC_TEST_MODULE 0
+#define __enabled_CONFIG_LCD_VGG2432A4 0
+#define __enabled_CONFIG_LCD_VGG2432A4_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_ADS7846 0
+#define __enabled_CONFIG_TOUCHSCREEN_ADS7846_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE 0
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE_MODULE 0
+#define __enabled_CONFIG_DRM 0
+#define __enabled_CONFIG_DRM_MODULE 0
+#define CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define __enabled_CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define __enabled_CONFIG_POSIX_MQUEUE_SYSCTL_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_MAX6900 0
+#define __enabled_CONFIG_RTC_DRV_MAX6900_MODULE 0
+#define __enabled_CONFIG_LDM_DEBUG 0
+#define __enabled_CONFIG_LDM_DEBUG_MODULE 0
+#define __enabled_CONFIG_UNUSED_SYMBOLS 0
+#define __enabled_CONFIG_UNUSED_SYMBOLS_MODULE 0
+#define __enabled_CONFIG_PREEMPT 0
+#define __enabled_CONFIG_PREEMPT_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX1111 0
+#define __enabled_CONFIG_SENSORS_MAX1111_MODULE 0
+#define __enabled_CONFIG_LEDS_DAC124S085 0
+#define __enabled_CONFIG_LEDS_DAC124S085_MODULE 0
+#define CONFIG_FB_CFB_COPYAREA 1
+#define __enabled_CONFIG_FB_CFB_COPYAREA 1
+#define __enabled_CONFIG_FB_CFB_COPYAREA_MODULE 0
+#define __enabled_CONFIG_MOUSE_GPIO 0
+#define __enabled_CONFIG_MOUSE_GPIO_MODULE 0
+#define CONFIG_ROMFS_BACKED_BY_BOTH 1
+#define __enabled_CONFIG_ROMFS_BACKED_BY_BOTH 1
+#define __enabled_CONFIG_ROMFS_BACKED_BY_BOTH_MODULE 0
+#define __enabled_CONFIG_USB_CYTHERM 0
+#define __enabled_CONFIG_USB_CYTHERM_MODULE 0
+#define __enabled_CONFIG_BINARY_PRINTF 0
+#define __enabled_CONFIG_BINARY_PRINTF_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX6642 0
+#define __enabled_CONFIG_SENSORS_MAX6642_MODULE 0
+#define __enabled_CONFIG_GPIO_MC33880 0
+#define __enabled_CONFIG_GPIO_MC33880_MODULE 0
+#define __enabled_CONFIG_MMC_CLKGATE 0
+#define __enabled_CONFIG_MMC_CLKGATE_MODULE 0
+#define CONFIG_MTD_CFI_AMDSTD 1
+#define __enabled_CONFIG_MTD_CFI_AMDSTD 1
+#define __enabled_CONFIG_MTD_CFI_AMDSTD_MODULE 0
+#define __enabled_CONFIG_SGI_PARTITION 0
+#define __enabled_CONFIG_SGI_PARTITION_MODULE 0
+#define __enabled_CONFIG_INPUT_SPARSEKMAP 0
+#define __enabled_CONFIG_INPUT_SPARSEKMAP_MODULE 0
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define __enabled_CONFIG_SYSVIPC_SYSCTL 1
+#define __enabled_CONFIG_SYSVIPC_SYSCTL_MODULE 0
+#define CONFIG_HID_NTRIG 1
+#define __enabled_CONFIG_HID_NTRIG 1
+#define __enabled_CONFIG_HID_NTRIG_MODULE 0
+#define CONFIG_S3C_LOWLEVEL_UART_PORT 0
+#define CONFIG_CPU_USE_DOMAINS 1
+#define __enabled_CONFIG_CPU_USE_DOMAINS 1
+#define __enabled_CONFIG_CPU_USE_DOMAINS_MODULE 0
+#define __enabled_CONFIG_SENSORS_W83L785TS 0
+#define __enabled_CONFIG_SENSORS_W83L785TS_MODULE 0
+#define CONFIG_DECOMPRESS_GZIP 1
+#define __enabled_CONFIG_DECOMPRESS_GZIP 1
+#define __enabled_CONFIG_DECOMPRESS_GZIP_MODULE 0
+#define __enabled_CONFIG_SENSORS_EMC2103 0
+#define __enabled_CONFIG_SENSORS_EMC2103_MODULE 0
+#define __enabled_CONFIG_YAFFS_DISABLE_TAGS_ECC 0
+#define __enabled_CONFIG_YAFFS_DISABLE_TAGS_ECC_MODULE 0
+#define __enabled_CONFIG_XFRM_SUB_POLICY 0
+#define __enabled_CONFIG_XFRM_SUB_POLICY_MODULE 0
+#define CONFIG_DECOMPRESS_LZO 1
+#define __enabled_CONFIG_DECOMPRESS_LZO 1
+#define __enabled_CONFIG_DECOMPRESS_LZO_MODULE 0
+#define __enabled_CONFIG_QUOTA 0
+#define __enabled_CONFIG_QUOTA_MODULE 0
+#define __enabled_CONFIG_SENSORS_LINEAGE 0
+#define __enabled_CONFIG_SENSORS_LINEAGE_MODULE 0
+#define __enabled_CONFIG_MMC_SDHCI_PLTFM 0
+#define __enabled_CONFIG_MMC_SDHCI_PLTFM_MODULE 0
+#define CONFIG_I2C_CHARDEV 1
+#define __enabled_CONFIG_I2C_CHARDEV 1
+#define __enabled_CONFIG_I2C_CHARDEV_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_NANDSIM 0
+#define __enabled_CONFIG_MTD_NAND_NANDSIM_MODULE 0
+#define CONFIG_CROSS_COMPILE "arm-linux-"
+#define __enabled_CONFIG_MTD_CFI_I4 0
+#define __enabled_CONFIG_MTD_CFI_I4_MODULE 0
+#define __enabled_CONFIG_NETWORK_SECMARK 0
+#define __enabled_CONFIG_NETWORK_SECMARK_MODULE 0
+#define __enabled_CONFIG_HID_HOLTEK 0
+#define __enabled_CONFIG_HID_HOLTEK_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1672 0
+#define __enabled_CONFIG_RTC_DRV_DS1672_MODULE 0
+#define CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define __enabled_CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define __enabled_CONFIG_MOUSE_PS2_SYNAPTICS_MODULE 0
+#define __enabled_CONFIG_ATALK 0
+#define __enabled_CONFIG_ATALK_MODULE 0
+#define CONFIG_XZ_DEC_ARMTHUMB 1
+#define __enabled_CONFIG_XZ_DEC_ARMTHUMB 1
+#define __enabled_CONFIG_XZ_DEC_ARMTHUMB_MODULE 0
+#define __enabled_CONFIG_MTD_SWAP 0
+#define __enabled_CONFIG_MTD_SWAP_MODULE 0
+#define __enabled_CONFIG_NFS_V4_1 0
+#define __enabled_CONFIG_NFS_V4_1_MODULE 0
+#define __enabled_CONFIG_NLS_UTF8 0
+#define __enabled_CONFIG_NLS_UTF8_MODULE 0
+#define __enabled_CONFIG_SPARSE_RCU_POINTER 0
+#define __enabled_CONFIG_SPARSE_RCU_POINTER_MODULE 0
+#define CONFIG_MINI2440_ADC 1
+#define __enabled_CONFIG_MINI2440_ADC 1
+#define __enabled_CONFIG_MINI2440_ADC_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_M41T80 0
+#define __enabled_CONFIG_RTC_DRV_M41T80_MODULE 0
+#define __enabled_CONFIG_INLINE_SPIN_TRYLOCK 0
+#define __enabled_CONFIG_INLINE_SPIN_TRYLOCK_MODULE 0
+#define __enabled_CONFIG_USB_USBNET 0
+#define __enabled_CONFIG_USB_USBNET_MODULE 0
+#define __enabled_CONFIG_INLINE_WRITE_TRYLOCK 0
+#define __enabled_CONFIG_INLINE_WRITE_TRYLOCK_MODULE 0
+#define __enabled_CONFIG_SENSORS_S3C 0
+#define __enabled_CONFIG_SENSORS_S3C_MODULE 0
+#define __enabled_CONFIG_HAMRADIO 0
+#define __enabled_CONFIG_HAMRADIO_MODULE 0
+#define __enabled_CONFIG_GPIO_PCA953X 0
+#define __enabled_CONFIG_GPIO_PCA953X_MODULE 0
+#define __enabled_CONFIG_FHANDLE 0
+#define __enabled_CONFIG_FHANDLE_MODULE 0
+#define __enabled_CONFIG_SERIAL_ALTERA_UART 0
+#define __enabled_CONFIG_SERIAL_ALTERA_UART_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_TAH 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_TAH_MODULE 0
+#define __enabled_CONFIG_HID_SMARTJOYPLUS 0
+#define __enabled_CONFIG_HID_SMARTJOYPLUS_MODULE 0
+#define CONFIG_NEW_LEDS 1
+#define __enabled_CONFIG_NEW_LEDS 1
+#define __enabled_CONFIG_NEW_LEDS_MODULE 0
+#define CONFIG_SWAP 1
+#define __enabled_CONFIG_SWAP 1
+#define __enabled_CONFIG_SWAP_MODULE 0
+#define __enabled_CONFIG_MTD_ONENAND 0
+#define __enabled_CONFIG_MTD_ONENAND_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_DS1511 0
+#define __enabled_CONFIG_RTC_DRV_DS1511_MODULE 0
+#define __enabled_CONFIG_IP_FIB_TRIE_STATS 0
+#define __enabled_CONFIG_IP_FIB_TRIE_STATS_MODULE 0
+#define __enabled_CONFIG_MACH_RX1950 0
+#define __enabled_CONFIG_MACH_RX1950_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_RV3029C2 0
+#define __enabled_CONFIG_RTC_DRV_RV3029C2_MODULE 0
+#define __enabled_CONFIG_MTD_NAND_DISKONCHIP 0
+#define __enabled_CONFIG_MTD_NAND_DISKONCHIP_MODULE 0
+#define __enabled_CONFIG_SPI_ALTERA 0
+#define __enabled_CONFIG_SPI_ALTERA_MODULE 0
+#define CONFIG_CRC_CCITT_MODULE 1
+#define __enabled_CONFIG_CRC_CCITT 0
+#define __enabled_CONFIG_CRC_CCITT_MODULE 1
+#define CONFIG_EXT3_FS_POSIX_ACL 1
+#define __enabled_CONFIG_EXT3_FS_POSIX_ACL 1
+#define __enabled_CONFIG_EXT3_FS_POSIX_ACL_MODULE 0
+#define CONFIG_MODULE_UNLOAD 1
+#define __enabled_CONFIG_MODULE_UNLOAD 1
+#define __enabled_CONFIG_MODULE_UNLOAD_MODULE 0
+#define CONFIG_AVERAGE 1
+#define __enabled_CONFIG_AVERAGE 1
+#define __enabled_CONFIG_AVERAGE_MODULE 0
+#define __enabled_CONFIG_DEBUG_NOTIFIERS 0
+#define __enabled_CONFIG_DEBUG_NOTIFIERS_MODULE 0
+#define __enabled_CONFIG_SENSORS_MAX6650 0
+#define __enabled_CONFIG_SENSORS_MAX6650_MODULE 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG_FILES 0
+#define __enabled_CONFIG_USB_GADGET_DEBUG_FILES_MODULE 0
+#define CONFIG_CPU_LLSERIAL_S3C2440 1
+#define __enabled_CONFIG_CPU_LLSERIAL_S3C2440 1
+#define __enabled_CONFIG_CPU_LLSERIAL_S3C2440_MODULE 0
+#define __enabled_CONFIG_SENSORS_LM85 0
+#define __enabled_CONFIG_SENSORS_LM85_MODULE 0
+#define __enabled_CONFIG_OC_ETM 0
+#define __enabled_CONFIG_OC_ETM_MODULE 0
+#define __enabled_CONFIG_ARCH_CNS3XXX 0
+#define __enabled_CONFIG_ARCH_CNS3XXX_MODULE 0
+#define CONFIG_BITREVERSE 1
+#define __enabled_CONFIG_BITREVERSE 1
+#define __enabled_CONFIG_BITREVERSE_MODULE 0
+#define CONFIG_BLK_DEV_RAM_SIZE 65536
+#define __enabled_CONFIG_MTD_ARM_INTEGRATOR 0
+#define __enabled_CONFIG_MTD_ARM_INTEGRATOR_MODULE 0
+#define __enabled_CONFIG_MAC_PARTITION 0
+#define __enabled_CONFIG_MAC_PARTITION_MODULE 0
+#define __enabled_CONFIG_SPI_S3C24XX_FIQ 0
+#define __enabled_CONFIG_SPI_S3C24XX_FIQ_MODULE 0
+#define __enabled_CONFIG_TOUCHSCREEN_DYNAPRO 0
+#define __enabled_CONFIG_TOUCHSCREEN_DYNAPRO_MODULE 0
+#define CONFIG_FB_MODE_HELPERS 1
+#define __enabled_CONFIG_FB_MODE_HELPERS 1
+#define __enabled_CONFIG_FB_MODE_HELPERS_MODULE 0
+#define __enabled_CONFIG_NLS_ISO8859_13 0
+#define __enabled_CONFIG_NLS_ISO8859_13_MODULE 0
+#define __enabled_CONFIG_MTD_MTDRAM 0
+#define __enabled_CONFIG_MTD_MTDRAM_MODULE 0
+#define CONFIG_CRYPTO_BLKCIPHER_MODULE 1
+#define __enabled_CONFIG_CRYPTO_BLKCIPHER 0
+#define __enabled_CONFIG_CRYPTO_BLKCIPHER_MODULE 1
+#define __enabled_CONFIG_NLS_ISO8859_8 0
+#define __enabled_CONFIG_NLS_ISO8859_8_MODULE 0
+#define __enabled_CONFIG_NF_CONNTRACK 0
+#define __enabled_CONFIG_NF_CONNTRACK_MODULE 0
+#define CONFIG_LCD_CLASS_DEVICE 1
+#define __enabled_CONFIG_LCD_CLASS_DEVICE 1
+#define __enabled_CONFIG_LCD_CLASS_DEVICE_MODULE 0
+#define CONFIG_FILE_LOCKING 1
+#define __enabled_CONFIG_FILE_LOCKING 1
+#define __enabled_CONFIG_FILE_LOCKING_MODULE 0
+#define CONFIG_S3C_DEV_WDT 1
+#define __enabled_CONFIG_S3C_DEV_WDT 1
+#define __enabled_CONFIG_S3C_DEV_WDT_MODULE 0
+#define __enabled_CONFIG_RTC_DRV_STK17TA8 0
+#define __enabled_CONFIG_RTC_DRV_STK17TA8_MODULE 0
+#define __enabled_CONFIG_KARMA_PARTITION 0
+#define __enabled_CONFIG_KARMA_PARTITION_MODULE 0
+#define __enabled_CONFIG_NETPOLL 0
+#define __enabled_CONFIG_NETPOLL_MODULE 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_EMAC4 0
+#define __enabled_CONFIG_IBM_NEW_EMAC_EMAC4_MODULE 0
+#define __enabled_CONFIG_SENSORS_F71882FG 0
+#define __enabled_CONFIG_SENSORS_F71882FG_MODULE 0
+#define __enabled_CONFIG_BLK_DEV_UB 0
+#define __enabled_CONFIG_BLK_DEV_UB_MODULE 0
+#define CONFIG_AIO 1
+#define __enabled_CONFIG_AIO 1
+#define __enabled_CONFIG_AIO_MODULE 0
+#define __enabled_CONFIG_DEBUG_OBJECTS 0
+#define __enabled_CONFIG_DEBUG_OBJECTS_MODULE 0
+#define __enabled_CONFIG_PERF_EVENTS 0
+#define __enabled_CONFIG_PERF_EVENTS_MODULE 0
+#define CONFIG_LEDS_CLASS 1
+#define __enabled_CONFIG_LEDS_CLASS 1
+#define __enabled_CONFIG_LEDS_CLASS_MODULE 0
+#define CONFIG_GENERIC_HARDIRQS 1
+#define __enabled_CONFIG_GENERIC_HARDIRQS 1
+#define __enabled_CONFIG_GENERIC_HARDIRQS_MODULE 0
+#define CONFIG_SYSCTL_SYSCALL_CHECK 1
+#define __enabled_CONFIG_SYSCTL_SYSCALL_CHECK 1
+#define __enabled_CONFIG_SYSCTL_SYSCALL_CHECK_MODULE 0
+#define CONFIG_RTC_INTF_DEV 1
+#define __enabled_CONFIG_RTC_INTF_DEV 1
+#define __enabled_CONFIG_RTC_INTF_DEV_MODULE 0
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define __enabled_CONFIG_MTD_MAP_BANK_WIDTH_4_MODULE 0
+#define CONFIG_HID_SUPPORT 1
+#define __enabled_CONFIG_HID_SUPPORT 1
+#define __enabled_CONFIG_HID_SUPPORT_MODULE 0
+#define __enabled_CONFIG_DEFAULT_DEADLINE 0
+#define __enabled_CONFIG_DEFAULT_DEADLINE_MODULE 0
+#define __enabled_CONFIG_SERIAL_TIMBERDALE 0
+#define __enabled_CONFIG_SERIAL_TIMBERDALE_MODULE 0
+#define __enabled_CONFIG_DEBUG_PAGEALLOC 0
+#define __enabled_CONFIG_DEBUG_PAGEALLOC_MODULE 0
+#define CONFIG_LEDS_MINI2440 1
+#define __enabled_CONFIG_LEDS_MINI2440 1
+#define __enabled_CONFIG_LEDS_MINI2440_MODULE 0
+#define CONFIG_CPU_ABRT_EV4T 1
+#define __enabled_CONFIG_CPU_ABRT_EV4T 1
+#define __enabled_CONFIG_CPU_ABRT_EV4T_MODULE 0
+#define __enabled_CONFIG_LOCKUP_DETECTOR 0
+#define __enabled_CONFIG_LOCKUP_DETECTOR_MODULE 0
+#define CONFIG_NLS_DEFAULT "cp437"
+#define CONFIG_UTS_NS 1
+#define __enabled_CONFIG_UTS_NS 1
+#define __enabled_CONFIG_UTS_NS_MODULE 0
+#define __enabled_CONFIG_EFS_FS 0
+#define __enabled_CONFIG_EFS_FS_MODULE 0
+#define __enabled_CONFIG_AUXDISPLAY 0
+#define __enabled_CONFIG_AUXDISPLAY_MODULE 0
+#define CONFIG_HAVE_S3C2410_I2C 1
+#define __enabled_CONFIG_HAVE_S3C2410_I2C 1
+#define __enabled_CONFIG_HAVE_S3C2410_I2C_MODULE 0
+#define CONFIG_CRYPTO_AEAD2 1
+#define __enabled_CONFIG_CRYPTO_AEAD2 1
+#define __enabled_CONFIG_CRYPTO_AEAD2_MODULE 0
+#define CONFIG_DEBUG_INFO 1
+#define __enabled_CONFIG_DEBUG_INFO 1
+#define __enabled_CONFIG_DEBUG_INFO_MODULE 0
+#define __enabled_CONFIG_CRYPTO_FCRYPT 0
+#define __enabled_CONFIG_CRYPTO_FCRYPT_MODULE 0
+#define CONFIG_MOUSE_PS2 1
+#define __enabled_CONFIG_MOUSE_PS2 1
+#define __enabled_CONFIG_MOUSE_PS2_MODULE 0
+#define __enabled_CONFIG_NET_IPIP 0
+#define __enabled_CONFIG_NET_IPIP_MODULE 0
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define __enabled_CONFIG_CRYPTO_ALGAPI2 1
+#define __enabled_CONFIG_CRYPTO_ALGAPI2_MODULE 0
+#define __enabled_CONFIG_MFD_TC6393XB 0
+#define __enabled_CONFIG_MFD_TC6393XB_MODULE 0
+#define __enabled_CONFIG_KEYBOARD_ADP5589 0
+#define __enabled_CONFIG_KEYBOARD_ADP5589_MODULE 0
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define __enabled_CONFIG_CPU_DCACHE_WRITETHROUGH 0
+#define __enabled_CONFIG_CPU_DCACHE_WRITETHROUGH_MODULE 0
+#define CONFIG_HAVE_MEMBLOCK 1
+#define __enabled_CONFIG_HAVE_MEMBLOCK 1
+#define __enabled_CONFIG_HAVE_MEMBLOCK_MODULE 0
+#define CONFIG_INPUT 1
+#define __enabled_CONFIG_INPUT 1
+#define __enabled_CONFIG_INPUT_MODULE 0
+#define CONFIG_PROC_SYSCTL 1
+#define __enabled_CONFIG_PROC_SYSCTL 1
+#define __enabled_CONFIG_PROC_SYSCTL_MODULE 0
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_BH 0
+#define __enabled_CONFIG_INLINE_READ_UNLOCK_BH_MODULE 0
+#define CONFIG_MMU 1
+#define __enabled_CONFIG_MMU 1
+#define __enabled_CONFIG_MMU_MODULE 0
+#define __enabled_CONFIG_OCFS2_FS 0
+#define __enabled_CONFIG_OCFS2_FS_MODULE 0
+#define CONFIG_HAVE_IRQ_WORK 1
+#define __enabled_CONFIG_HAVE_IRQ_WORK 1
+#define __enabled_CONFIG_HAVE_IRQ_WORK_MODULE 0
+#define __enabled_CONFIG_MTD_M25P80 0
+#define __enabled_CONFIG_MTD_M25P80_MODULE 0
+#define __enabled_CONFIG_USB_KAWETH 0
+#define __enabled_CONFIG_USB_KAWETH_MODULE 0
+#define __enabled_CONFIG_GPIO_MCP23S08 0
+#define __enabled_CONFIG_GPIO_MCP23S08_MODULE 0
+#define __enabled_CONFIG_ENABLE_DEFAULT_TRACERS 0
+#define __enabled_CONFIG_ENABLE_DEFAULT_TRACERS_MODULE 0
+#define CONFIG_INLINE_WRITE_UNLOCK 1
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK 1
+#define __enabled_CONFIG_INLINE_WRITE_UNLOCK_MODULE 0
+#define __enabled_CONFIG_SENSORS_GL520SM 0
+#define __enabled_CONFIG_SENSORS_GL520SM_MODULE 0
+#define CONFIG_FONT_MINI_4x6 1
+#define __enabled_CONFIG_FONT_MINI_4x6 1
+#define __enabled_CONFIG_FONT_MINI_4x6_MODULE 0
diff -uprN linux-3.1.5-orig/include/generated/bounds.h linux-3.1.5/include/generated/bounds.h
--- linux-3.1.5-orig/include/generated/bounds.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/bounds.h	2012-10-25 20:03:21.196350493 -0600
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define NR_PAGEFLAGS 22 /* __NR_PAGEFLAGS	@ */
+#define MAX_NR_ZONES 2 /* __MAX_NR_ZONES	@ */
+#define NR_PCG_FLAGS 7 /* __NR_PCG_FLAGS	@ */
+
+#endif
diff -uprN linux-3.1.5-orig/include/generated/compile.h linux-3.1.5/include/generated/compile.h
--- linux-3.1.5-orig/include/generated/compile.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/compile.h	2012-10-25 20:14:04.484717582 -0600
@@ -0,0 +1,6 @@
+/* This file is auto generated, version 1 */
+#define UTS_MACHINE "arm"
+#define UTS_VERSION "#1 Thu Oct 25 20:14:00 MDT 2012"
+#define LINUX_COMPILE_BY "doug"
+#define LINUX_COMPILE_HOST "ldougs.laptop"
+#define LINUX_COMPILER "gcc version 4.3.2 (Sourcery G++ Lite 2008q3-72) "
diff -uprN linux-3.1.5-orig/include/generated/mach-types.h linux-3.1.5/include/generated/mach-types.h
--- linux-3.1.5-orig/include/generated/mach-types.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/mach-types.h	2012-10-25 17:03:33.211408028 -0600
@@ -0,0 +1,14220 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_GUMSTIX              373
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_PALMLD               835
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_PALMTE2              844
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_PALMTX               885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_OMAP_3430SDP         1138
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_TREO680              1230
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COLIBRI320           1340
+#define MACH_TYPE_CAM60                1351
+#define MACH_TYPE_AT91EB01             1354
+#define MACH_TYPE_DB88F5281            1358
+#define MACH_TYPE_CSB726               1359
+#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
+#define MACH_TYPE_LITTLETON            1388
+#define MACH_TYPE_REALVIEW_PB11MP      1407
+#define MACH_TYPE_MX27_3DS             1430
+#define MACH_TYPE_HALIBUT              1439
+#define MACH_TYPE_TROUT                1440
+#define MACH_TYPE_TCT_HAMMER           1460
+#define MACH_TYPE_HERALD               1461
+#define MACH_TYPE_SIM_ONE              1476
+#define MACH_TYPE_JIVE                 1490
+#define MACH_TYPE_SAM9_L9260           1501
+#define MACH_TYPE_REALVIEW_PB1176      1504
+#define MACH_TYPE_YL9200               1507
+#define MACH_TYPE_RD88F5182            1508
+#define MACH_TYPE_KUROBOX_PRO          1509
+#define MACH_TYPE_MX31_3DS             1511
+#define MACH_TYPE_QONG                 1524
+#define MACH_TYPE_OMAP2EVM             1534
+#define MACH_TYPE_OMAP3EVM             1535
+#define MACH_TYPE_DNS323               1542
+#define MACH_TYPE_OMAP3_BEAGLE         1546
+#define MACH_TYPE_NOKIA_N810           1548
+#define MACH_TYPE_PCM038               1551
+#define MACH_TYPE_TS209                1565
+#define MACH_TYPE_AT91CAP9ADK          1566
+#define MACH_TYPE_MX31MOBOARD          1574
+#define MACH_TYPE_TERASTATION_PRO2     1584
+#define MACH_TYPE_LINKSTATION_PRO      1585
+#define MACH_TYPE_E350                 1596
+#define MACH_TYPE_TS409                1601
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_NEUROS_OSD2          1647
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_DAVINCI_DA830_EVM    1781
+#define MACH_TYPE_AT572D940HFEB        1783
+#define MACH_TYPE_DOVE_DB              1788
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_EUKREA_CPUIMX27      1975
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_VEXPRESS             2272
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_SMDK6442             2324
+#define MACH_TYPE_OPENRD_BASE          2325
+#define MACH_TYPE_DEVKIT8000           2330
+#define MACH_TYPE_MX51_EFIKAMX         2336
+#define MACH_TYPE_CM_T35               2341
+#define MACH_TYPE_NET2BIG              2342
+#define MACH_TYPE_IGEP0020             2344
+#define MACH_TYPE_NUC932EVB            2356
+#define MACH_TYPE_OPENRD_CLIENT        2361
+#define MACH_TYPE_U8500                2368
+#define MACH_TYPE_MX51_EFIKASB         2370
+#define MACH_TYPE_MARVELL_JASPER       2382
+#define MACH_TYPE_FLINT                2383
+#define MACH_TYPE_TAVOREVB3            2384
+#define MACH_TYPE_TOUCHBOOK            2393
+#define MACH_TYPE_RAUMFELD_RC          2413
+#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
+#define MACH_TYPE_RAUMFELD_SPEAKER     2415
+#define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_RIOT_BEI2            2576
+#define MACH_TYPE_RIOT_X37             2578
+#define MACH_TYPE_CAPC7117             2612
+#define MACH_TYPE_ICONTROL             2624
+#define MACH_TYPE_QSD8X50A_ST1_5       2627
+#define MACH_TYPE_MX23EVK              2629
+#define MACH_TYPE_AP4EVB               2630
+#define MACH_TYPE_MITYOMAPL138         2650
+#define MACH_TYPE_GURUPLUG             2659
+#define MACH_TYPE_SPEAR310             2660
+#define MACH_TYPE_SPEAR320             2661
+#define MACH_TYPE_AQUILA               2676
+#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
+#define MACH_TYPE_MSM7X30_SURF         2679
+#define MACH_TYPE_EA2478DEVKIT         2683
+#define MACH_TYPE_TERASTATION_WXL      2697
+#define MACH_TYPE_MSM7X25_SURF         2703
+#define MACH_TYPE_MSM7X25_FFA          2704
+#define MACH_TYPE_MSM7X27_SURF         2705
+#define MACH_TYPE_MSM7X27_FFA          2706
+#define MACH_TYPE_MSM7X30_FFA          2707
+#define MACH_TYPE_QSD8X50_SURF         2708
+#define MACH_TYPE_MX53_EVK             2716
+#define MACH_TYPE_IGEP0030             2717
+#define MACH_TYPE_SBC3530              2722
+#define MACH_TYPE_SAARB                2727
+#define MACH_TYPE_HARMONY              2731
+#define MACH_TYPE_MSM7X30_FLUID        2741
+#define MACH_TYPE_CM_T3517             2750
+#define MACH_TYPE_WBD222               2753
+#define MACH_TYPE_MSM8X60_SURF         2755
+#define MACH_TYPE_MSM8X60_SIM          2756
+#define MACH_TYPE_TCC8000_SDK          2758
+#define MACH_TYPE_NANOS                2759
+#define MACH_TYPE_STAMP9G45            2761
+#define MACH_TYPE_CNS3420VB            2776
+#define MACH_TYPE_OMAP4_PANDA          2791
+#define MACH_TYPE_TI8168EVM            2800
+#define MACH_TYPE_TETON_BGA            2816
+#define MACH_TYPE_EUKREA_CPUIMX25SD    2820
+#define MACH_TYPE_EUKREA_CPUIMX35SD    2821
+#define MACH_TYPE_EUKREA_CPUIMX51SD    2822
+#define MACH_TYPE_EUKREA_CPUIMX51      2823
+#define MACH_TYPE_SMDKC210             2838
+#define MACH_TYPE_OMAP3_BRAILLO        2839
+#define MACH_TYPE_SPYPLUG              2840
+#define MACH_TYPE_GINGER               2841
+#define MACH_TYPE_TNY_T3530            2842
+#define MACH_TYPE_PCA102               2843
+#define MACH_TYPE_SPADE                2844
+#define MACH_TYPE_MXC25_TOPAZ          2845
+#define MACH_TYPE_T5325                2846
+#define MACH_TYPE_GW2361               2847
+#define MACH_TYPE_ELOG                 2848
+#define MACH_TYPE_INCOME               2849
+#define MACH_TYPE_BCM589X              2850
+#define MACH_TYPE_ETNA                 2851
+#define MACH_TYPE_HAWKS                2852
+#define MACH_TYPE_MESON                2853
+#define MACH_TYPE_XSBASE255            2854
+#define MACH_TYPE_PVM2030              2855
+#define MACH_TYPE_MIOA502              2856
+#define MACH_TYPE_VVBOX_SDORIG2        2857
+#define MACH_TYPE_VVBOX_SDLITE2        2858
+#define MACH_TYPE_VVBOX_SDPRO4         2859
+#define MACH_TYPE_HTC_SPV_M700         2860
+#define MACH_TYPE_MX257SX              2861
+#define MACH_TYPE_GONI                 2862
+#define MACH_TYPE_MSM8X55_SVLTE_FFA    2863
+#define MACH_TYPE_MSM8X55_SVLTE_SURF   2864
+#define MACH_TYPE_QUICKSTEP            2865
+#define MACH_TYPE_DMW96                2866
+#define MACH_TYPE_HAMMERHEAD           2867
+#define MACH_TYPE_TRIDENT              2868
+#define MACH_TYPE_LIGHTNING            2869
+#define MACH_TYPE_ICONNECT             2870
+#define MACH_TYPE_AUTOBOT              2871
+#define MACH_TYPE_COCONUT              2872
+#define MACH_TYPE_DURIAN               2873
+#define MACH_TYPE_CAYENNE              2874
+#define MACH_TYPE_FUJI                 2875
+#define MACH_TYPE_SYNOLOGY_6282        2876
+#define MACH_TYPE_EM1SY                2877
+#define MACH_TYPE_M502                 2878
+#define MACH_TYPE_MATRIX518            2879
+#define MACH_TYPE_TINY_GURNARD         2880
+#define MACH_TYPE_SPEAR1310            2881
+#define MACH_TYPE_BV07                 2882
+#define MACH_TYPE_MXT_TD61             2883
+#define MACH_TYPE_OPENRD_ULTIMATE      2884
+#define MACH_TYPE_DEVIXP               2885
+#define MACH_TYPE_MICCPT               2886
+#define MACH_TYPE_MIC256               2887
+#define MACH_TYPE_AS1167               2888
+#define MACH_TYPE_OMAP3_IBIZA          2889
+#define MACH_TYPE_U5500                2890
+#define MACH_TYPE_DAVINCI_PICTO        2891
+#define MACH_TYPE_MECHA                2892
+#define MACH_TYPE_BUBBA3               2893
+#define MACH_TYPE_PUPITRE              2894
+#define MACH_TYPE_TEGRA_VOGUE          2896
+#define MACH_TYPE_TEGRA_E1165          2897
+#define MACH_TYPE_SIMPLENET            2898
+#define MACH_TYPE_EC4350TBM            2899
+#define MACH_TYPE_PEC_TC               2900
+#define MACH_TYPE_PEC_HC2              2901
+#define MACH_TYPE_ESL_MOBILIS_A        2902
+#define MACH_TYPE_ESL_MOBILIS_B        2903
+#define MACH_TYPE_ESL_WAVE_A           2904
+#define MACH_TYPE_ESL_WAVE_B           2905
+#define MACH_TYPE_UNISENSE_MMM         2906
+#define MACH_TYPE_BLUESHARK            2907
+#define MACH_TYPE_E10                  2908
+#define MACH_TYPE_APP3K_ROBIN          2909
+#define MACH_TYPE_POV15HD              2910
+#define MACH_TYPE_STELLA               2911
+#define MACH_TYPE_LINKSTATION_LSCHL    2913
+#define MACH_TYPE_NETWALKER            2914
+#define MACH_TYPE_ACSX106              2915
+#define MACH_TYPE_ATLAS5_C1            2916
+#define MACH_TYPE_NSB3AST              2917
+#define MACH_TYPE_GNET_SLC             2918
+#define MACH_TYPE_AF4000               2919
+#define MACH_TYPE_ARK9431              2920
+#define MACH_TYPE_FS_S5PC100           2921
+#define MACH_TYPE_OMAP3505NOVA8        2922
+#define MACH_TYPE_OMAP3621_EDP1        2923
+#define MACH_TYPE_ORATISAES            2924
+#define MACH_TYPE_SMDKV310             2925
+#define MACH_TYPE_SIEMENS_L0           2926
+#define MACH_TYPE_VENTANA              2927
+#define MACH_TYPE_WM8505_7IN_NETBOOK   2928
+#define MACH_TYPE_EC4350SDB            2929
+#define MACH_TYPE_MIMAS                2930
+#define MACH_TYPE_TITAN                2931
+#define MACH_TYPE_CRANEBOARD           2932
+#define MACH_TYPE_ES2440               2933
+#define MACH_TYPE_NAJAY_A9263          2934
+#define MACH_TYPE_HTCTORNADO           2935
+#define MACH_TYPE_DIMM_MX257           2936
+#define MACH_TYPE_JIGEN                2937
+#define MACH_TYPE_SMDK6450             2938
+#define MACH_TYPE_MENO_QNG             2939
+#define MACH_TYPE_NS2416               2940
+#define MACH_TYPE_RPC353               2941
+#define MACH_TYPE_TQ6410               2942
+#define MACH_TYPE_SKY6410              2943
+#define MACH_TYPE_DYNASTY              2944
+#define MACH_TYPE_VIVO                 2945
+#define MACH_TYPE_BURY_BL7582          2946
+#define MACH_TYPE_BURY_BPS5270         2947
+#define MACH_TYPE_BASI                 2948
+#define MACH_TYPE_TN200                2949
+#define MACH_TYPE_C2MMI                2950
+#define MACH_TYPE_MESON_6236M          2951
+#define MACH_TYPE_MESON_8626M          2952
+#define MACH_TYPE_TUBE                 2953
+#define MACH_TYPE_MESSINA              2954
+#define MACH_TYPE_MX50_ARM2            2955
+#define MACH_TYPE_CETUS9263            2956
+#define MACH_TYPE_BROWNSTONE           2957
+#define MACH_TYPE_VMX25                2958
+#define MACH_TYPE_VMX51                2959
+#define MACH_TYPE_ABACUS               2960
+#define MACH_TYPE_CM4745               2961
+#define MACH_TYPE_ORATISLINK           2962
+#define MACH_TYPE_DAVINCI_DM365_DVR    2963
+#define MACH_TYPE_NETVIZ               2964
+#define MACH_TYPE_FLEXIBITY            2965
+#define MACH_TYPE_WLAN_COMPUTER        2966
+#define MACH_TYPE_LPC24XX              2967
+#define MACH_TYPE_SPICA                2968
+#define MACH_TYPE_GPSDISPLAY           2969
+#define MACH_TYPE_BIPNET               2970
+#define MACH_TYPE_OVERO_CTU_INERTIAL   2971
+#define MACH_TYPE_DAVINCI_DM355_MMM    2972
+#define MACH_TYPE_PC9260_V2            2973
+#define MACH_TYPE_PTX7545              2974
+#define MACH_TYPE_TM_EFDC              2975
+#define MACH_TYPE_OMAP3_WALDO1         2977
+#define MACH_TYPE_FLYER                2978
+#define MACH_TYPE_TORNADO3240          2979
+#define MACH_TYPE_SOLI_01              2980
+#define MACH_TYPE_OMAPL138_EUROPALC    2981
+#define MACH_TYPE_HELIOS_V1            2982
+#define MACH_TYPE_NETSPACE_LITE_V2     2983
+#define MACH_TYPE_SSC                  2984
+#define MACH_TYPE_PREMIERWAVE_EN       2985
+#define MACH_TYPE_WASABI               2986
+#define MACH_TYPE_MX50_RDP             2988
+#define MACH_TYPE_UNIVERSAL_C210       2989
+#define MACH_TYPE_REAL6410             2990
+#define MACH_TYPE_SPX_SAKURA           2991
+#define MACH_TYPE_IJ3K_2440            2992
+#define MACH_TYPE_OMAP3_BC10           2993
+#define MACH_TYPE_THEBE                2994
+#define MACH_TYPE_RV082                2995
+#define MACH_TYPE_ARMLGUEST            2996
+#define MACH_TYPE_TJINC1000            2997
+#define MACH_TYPE_DOCKSTAR             2998
+#define MACH_TYPE_AX8008               2999
+#define MACH_TYPE_GNET_SGCE            3000
+#define MACH_TYPE_PXWNAS_500_1000      3001
+#define MACH_TYPE_EA20                 3002
+#define MACH_TYPE_AWM2                 3003
+#define MACH_TYPE_TI8148EVM            3004
+#define MACH_TYPE_SEABOARD             3005
+#define MACH_TYPE_LINKSTATION_CHLV2    3006
+#define MACH_TYPE_TERA_PRO2_RACK       3007
+#define MACH_TYPE_RUBYS                3008
+#define MACH_TYPE_AQUARIUS             3009
+#define MACH_TYPE_MX53_ARD             3010
+#define MACH_TYPE_MX53_SMD             3011
+#define MACH_TYPE_LSWXL                3012
+#define MACH_TYPE_DOVE_AVNG_V3         3013
+#define MACH_TYPE_SDI_ESS_9263         3014
+#define MACH_TYPE_JOCPU550             3015
+#define MACH_TYPE_MSM8X60_RUMI3        3016
+#define MACH_TYPE_MSM8X60_FFA          3017
+#define MACH_TYPE_YANOMAMI             3018
+#define MACH_TYPE_GTA04                3019
+#define MACH_TYPE_CM_A510              3020
+#define MACH_TYPE_OMAP3_RFS200         3021
+#define MACH_TYPE_KX33XX               3022
+#define MACH_TYPE_PTX7510              3023
+#define MACH_TYPE_TOP9000              3024
+#define MACH_TYPE_TEENOTE              3025
+#define MACH_TYPE_TS3                  3026
+#define MACH_TYPE_A0                   3027
+#define MACH_TYPE_FSM9XXX_SURF         3028
+#define MACH_TYPE_FSM9XXX_FFA          3029
+#define MACH_TYPE_FRRHWCDMA60W         3030
+#define MACH_TYPE_REMUS                3031
+#define MACH_TYPE_AT91CAP7XDK          3032
+#define MACH_TYPE_AT91CAP7STK          3033
+#define MACH_TYPE_KT_SBC_SAM9_1        3034
+#define MACH_TYPE_ARMADA_XP_DB         3036
+#define MACH_TYPE_SPDM                 3037
+#define MACH_TYPE_GTIB                 3038
+#define MACH_TYPE_DGM3240              3039
+#define MACH_TYPE_HTCMEGA              3041
+#define MACH_TYPE_TRICORDER            3042
+#define MACH_TYPE_TX28                 3043
+#define MACH_TYPE_BSTBRD               3044
+#define MACH_TYPE_PWB3090              3045
+#define MACH_TYPE_IDEA6410             3046
+#define MACH_TYPE_QBC9263              3047
+#define MACH_TYPE_BORABORA             3048
+#define MACH_TYPE_VALDEZ               3049
+#define MACH_TYPE_LS9G20               3050
+#define MACH_TYPE_MIOS_V1              3051
+#define MACH_TYPE_S5PC110_CRESPO       3052
+#define MACH_TYPE_CONTROLTEK9G20       3053
+#define MACH_TYPE_TIN307               3054
+#define MACH_TYPE_TIN510               3055
+#define MACH_TYPE_BLUECHEESE           3057
+#define MACH_TYPE_TEM3X30              3058
+#define MACH_TYPE_HARVEST_DESOTO       3059
+#define MACH_TYPE_MSM8X60_QRDC         3060
+#define MACH_TYPE_SPEAR900             3061
+#define MACH_TYPE_PCONTROL_G20         3062
+#define MACH_TYPE_RDSTOR               3063
+#define MACH_TYPE_USDLOADER            3064
+#define MACH_TYPE_TSOPLOADER           3065
+#define MACH_TYPE_KRONOS               3066
+#define MACH_TYPE_FFCORE               3067
+#define MACH_TYPE_MONE                 3068
+#define MACH_TYPE_UNIT2S               3069
+#define MACH_TYPE_ACER_A5              3070
+#define MACH_TYPE_ETHERPRO_ISP         3071
+#define MACH_TYPE_STRETCHS7000         3072
+#define MACH_TYPE_P87_SMARTSIM         3073
+#define MACH_TYPE_TULIP                3074
+#define MACH_TYPE_SUNFLOWER            3075
+#define MACH_TYPE_RIB                  3076
+#define MACH_TYPE_CLOD                 3077
+#define MACH_TYPE_RUMP                 3078
+#define MACH_TYPE_TENDERLOIN           3079
+#define MACH_TYPE_SHORTLOIN            3080
+#define MACH_TYPE_ANTARES              3082
+#define MACH_TYPE_WB40N                3083
+#define MACH_TYPE_HERRING              3084
+#define MACH_TYPE_NAXY400              3085
+#define MACH_TYPE_NAXY1200             3086
+#define MACH_TYPE_VPR200               3087
+#define MACH_TYPE_BUG20                3088
+#define MACH_TYPE_GOFLEXNET            3089
+#define MACH_TYPE_TORBRECK             3090
+#define MACH_TYPE_SAARB_MG1            3091
+#define MACH_TYPE_CALLISTO             3092
+#define MACH_TYPE_MULTHSU              3093
+#define MACH_TYPE_SALUDA               3094
+#define MACH_TYPE_PEMP_OMAP3_APOLLO    3095
+#define MACH_TYPE_VC0718               3096
+#define MACH_TYPE_MVBLX                3097
+#define MACH_TYPE_INHAND_APEIRON       3098
+#define MACH_TYPE_INHAND_FURY          3099
+#define MACH_TYPE_INHAND_SIREN         3100
+#define MACH_TYPE_HDNVP                3101
+#define MACH_TYPE_SOFTWINNER           3102
+#define MACH_TYPE_PRIMA2_EVB           3103
+#define MACH_TYPE_NAS6210              3104
+#define MACH_TYPE_UNISDEV              3105
+#define MACH_TYPE_SBCA11               3106
+#define MACH_TYPE_SAGA                 3107
+#define MACH_TYPE_NS_K330              3108
+#define MACH_TYPE_TANNA                3109
+#define MACH_TYPE_IMATE8502            3110
+#define MACH_TYPE_ASPEN                3111
+#define MACH_TYPE_DAINTREE_CWAC        3112
+#define MACH_TYPE_ZMX25                3113
+#define MACH_TYPE_MAPLE1               3114
+#define MACH_TYPE_QSD8X72_SURF         3115
+#define MACH_TYPE_QSD8X72_FFA          3116
+#define MACH_TYPE_ABILENE              3117
+#define MACH_TYPE_EIGEN_TTR            3118
+#define MACH_TYPE_IOMEGA_IX2_200       3119
+#define MACH_TYPE_CORETEC_VCX7400      3120
+#define MACH_TYPE_SANTIAGO             3121
+#define MACH_TYPE_MX257SOL             3122
+#define MACH_TYPE_STRASBOURG           3123
+#define MACH_TYPE_MSM8X60_FLUID        3124
+#define MACH_TYPE_SMARTQV5             3125
+#define MACH_TYPE_SMARTQV3             3126
+#define MACH_TYPE_SMARTQV7             3127
+#define MACH_TYPE_PAZ00                3128
+#define MACH_TYPE_ACMENETUSFOXG20      3129
+#define MACH_TYPE_FWBD_0404            3131
+#define MACH_TYPE_HDGU                 3132
+#define MACH_TYPE_PYRAMID              3133
+#define MACH_TYPE_EPIPHAN              3134
+#define MACH_TYPE_OMAP_BENDER          3135
+#define MACH_TYPE_GURNARD              3136
+#define MACH_TYPE_GTL_IT5100           3137
+#define MACH_TYPE_BCM2708              3138
+#define MACH_TYPE_MX51_GGC             3139
+#define MACH_TYPE_SHARESPACE           3140
+#define MACH_TYPE_HABA_KNX_EXPLORER    3141
+#define MACH_TYPE_SIMTEC_KIRKMOD       3142
+#define MACH_TYPE_CRUX                 3143
+#define MACH_TYPE_MX51_BRAVO           3144
+#define MACH_TYPE_CHARON               3145
+#define MACH_TYPE_PICOCOM3             3146
+#define MACH_TYPE_PICOCOM4             3147
+#define MACH_TYPE_SERRANO              3148
+#define MACH_TYPE_DOUBLESHOT           3149
+#define MACH_TYPE_EVSY                 3150
+#define MACH_TYPE_HUASHAN              3151
+#define MACH_TYPE_LAUSANNE             3152
+#define MACH_TYPE_EMERALD              3153
+#define MACH_TYPE_TQMA35               3154
+#define MACH_TYPE_MARVEL               3155
+#define MACH_TYPE_MANUAE               3156
+#define MACH_TYPE_CHACHA               3157
+#define MACH_TYPE_LEMON                3158
+#define MACH_TYPE_CSC                  3159
+#define MACH_TYPE_GIRA_KNXIP_ROUTER    3160
+#define MACH_TYPE_T20                  3161
+#define MACH_TYPE_HDMINI               3162
+#define MACH_TYPE_SCIPHONE_G2          3163
+#define MACH_TYPE_EXPRESS              3164
+#define MACH_TYPE_EXPRESS_KT           3165
+#define MACH_TYPE_MAXIMASP             3166
+#define MACH_TYPE_NITROGEN_IMX51       3167
+#define MACH_TYPE_NITROGEN_IMX53       3168
+#define MACH_TYPE_SUNFIRE              3169
+#define MACH_TYPE_AROWANA              3170
+#define MACH_TYPE_TEGRA_DAYTONA        3171
+#define MACH_TYPE_TEGRA_SWORDFISH      3172
+#define MACH_TYPE_EDISON               3173
+#define MACH_TYPE_SVP8500V1            3174
+#define MACH_TYPE_SVP8500V2            3175
+#define MACH_TYPE_SVP5500              3176
+#define MACH_TYPE_B5500                3177
+#define MACH_TYPE_S5500                3178
+#define MACH_TYPE_ICON                 3179
+#define MACH_TYPE_ELEPHANT             3180
+#define MACH_TYPE_SHOOTER              3182
+#define MACH_TYPE_SPADE_LTE            3183
+#define MACH_TYPE_PHILHWANI            3184
+#define MACH_TYPE_GSNCOMM              3185
+#define MACH_TYPE_STRASBOURG_A2        3186
+#define MACH_TYPE_MMM                  3187
+#define MACH_TYPE_DAVINCI_DM365_BV     3188
+#define MACH_TYPE_AG5EVM               3189
+#define MACH_TYPE_SC575PLC             3190
+#define MACH_TYPE_SC575IPC             3191
+#define MACH_TYPE_OMAP3_TDM3730        3192
+#define MACH_TYPE_TOP9000_EVAL         3194
+#define MACH_TYPE_TOP9000_SU           3195
+#define MACH_TYPE_UTM300               3196
+#define MACH_TYPE_TSUNAGI              3197
+#define MACH_TYPE_TS75XX               3198
+#define MACH_TYPE_TS47XX               3200
+#define MACH_TYPE_DA850_K5             3201
+#define MACH_TYPE_AX502                3202
+#define MACH_TYPE_IGEP0032             3203
+#define MACH_TYPE_ANTERO               3204
+#define MACH_TYPE_SYNERGY              3205
+#define MACH_TYPE_ICS_IF_VOIP          3206
+#define MACH_TYPE_WLF_CRAGG_6410       3207
+#define MACH_TYPE_PUNICA               3208
+#define MACH_TYPE_TRIMSLICE            3209
+#define MACH_TYPE_MX27_WMULTRA         3210
+#define MACH_TYPE_MACKEREL             3211
+#define MACH_TYPE_FA9X27               3213
+#define MACH_TYPE_NS2816TB             3214
+#define MACH_TYPE_NS2816_NTPAD         3215
+#define MACH_TYPE_NS2816_NTNB          3216
+#define MACH_TYPE_KAEN                 3217
+#define MACH_TYPE_NV1000               3218
+#define MACH_TYPE_NUC950TS             3219
+#define MACH_TYPE_NOKIA_RM680          3220
+#define MACH_TYPE_AST2200              3221
+#define MACH_TYPE_LEAD                 3222
+#define MACH_TYPE_UNINO1               3223
+#define MACH_TYPE_GREECO               3224
+#define MACH_TYPE_VERDI                3225
+#define MACH_TYPE_DM6446_ADBOX         3226
+#define MACH_TYPE_QUAD_SALSA           3227
+#define MACH_TYPE_ABB_GMA_1_1          3228
+#define MACH_TYPE_SVCID                3229
+#define MACH_TYPE_MSM8960_SIM          3230
+#define MACH_TYPE_MSM8960_RUMI3        3231
+#define MACH_TYPE_ICON_G               3232
+#define MACH_TYPE_MB3                  3233
+#define MACH_TYPE_GSIA18S              3234
+#define MACH_TYPE_PIVICC               3235
+#define MACH_TYPE_PCM048               3236
+#define MACH_TYPE_DDS                  3237
+#define MACH_TYPE_CHALTEN_XA1          3238
+#define MACH_TYPE_TS48XX               3239
+#define MACH_TYPE_TONGA2_TFTTIMER      3240
+#define MACH_TYPE_WHISTLER             3241
+#define MACH_TYPE_ASL_PHOENIX          3242
+#define MACH_TYPE_AT91SAM9263OTLITE    3243
+#define MACH_TYPE_DDPLUG               3244
+#define MACH_TYPE_D2PLUG               3245
+#define MACH_TYPE_KZM9D                3246
+#define MACH_TYPE_VERDI_LTE            3247
+#define MACH_TYPE_NANOZOOM             3248
+#define MACH_TYPE_DM3730_SOM_LV        3249
+#define MACH_TYPE_DM3730_TORPEDO       3250
+#define MACH_TYPE_ANCHOVY              3251
+#define MACH_TYPE_RE2REV20             3253
+#define MACH_TYPE_RE2REV21             3254
+#define MACH_TYPE_CNS21XX              3255
+#define MACH_TYPE_RIDER                3257
+#define MACH_TYPE_NSK330               3258
+#define MACH_TYPE_CNS2133EVB           3259
+#define MACH_TYPE_Z3_816X_MOD          3260
+#define MACH_TYPE_Z3_814X_MOD          3261
+#define MACH_TYPE_BEECT                3262
+#define MACH_TYPE_DMA_THUNDERBUG       3263
+#define MACH_TYPE_OMN_AT91SAM9G20      3264
+#define MACH_TYPE_MX25_E2S_UC          3265
+#define MACH_TYPE_MIONE                3266
+#define MACH_TYPE_TOP9000_TCU          3267
+#define MACH_TYPE_TOP9000_BSL          3268
+#define MACH_TYPE_KINGDOM              3269
+#define MACH_TYPE_ARMADILLO460         3270
+#define MACH_TYPE_LQ2                  3271
+#define MACH_TYPE_SWEDA_TMS2           3272
+#define MACH_TYPE_MX53_LOCO            3273
+#define MACH_TYPE_ACER_A8              3275
+#define MACH_TYPE_ACER_GAUGUIN         3276
+#define MACH_TYPE_GUPPY                3277
+#define MACH_TYPE_MX61_ARD             3278
+#define MACH_TYPE_TX53                 3279
+#define MACH_TYPE_OMAPL138_CASE_A3     3280
+#define MACH_TYPE_UEMD                 3281
+#define MACH_TYPE_CCWMX51MUT           3282
+#define MACH_TYPE_ROCKHOPPER           3283
+#define MACH_TYPE_ENCORE               3284
+#define MACH_TYPE_HKDKC100             3285
+#define MACH_TYPE_TS42XX               3286
+#define MACH_TYPE_AEBL                 3287
+#define MACH_TYPE_WARIO                3288
+#define MACH_TYPE_GFS_SPM              3289
+#define MACH_TYPE_CM_T3730             3290
+#define MACH_TYPE_ISC3                 3291
+#define MACH_TYPE_RASCAL               3292
+#define MACH_TYPE_HREFV60              3293
+#define MACH_TYPE_TPT_2_0              3294
+#define MACH_TYPE_SPLENDOR             3296
+#define MACH_TYPE_MSM8X60_QT           3298
+#define MACH_TYPE_HTC_HD_MINI          3299
+#define MACH_TYPE_ATHENE               3300
+#define MACH_TYPE_DEEP_R_EK_1          3301
+#define MACH_TYPE_VIVOW_CT             3302
+#define MACH_TYPE_NERY_1000            3303
+#define MACH_TYPE_RFL109145_SSRV       3304
+#define MACH_TYPE_NMH                  3305
+#define MACH_TYPE_WN802T               3306
+#define MACH_TYPE_DRAGONET             3307
+#define MACH_TYPE_AT91SAM9263DESK16L   3309
+#define MACH_TYPE_BCMHANA_SV           3310
+#define MACH_TYPE_BCMHANA_TABLET       3311
+#define MACH_TYPE_KOI                  3312
+#define MACH_TYPE_TS4800               3313
+#define MACH_TYPE_TQMA9263             3314
+#define MACH_TYPE_HOLIDAY              3315
+#define MACH_TYPE_DMA6410              3316
+#define MACH_TYPE_PCATS_OVERLAY        3317
+#define MACH_TYPE_HWGW6410             3318
+#define MACH_TYPE_SHENZHOU             3319
+#define MACH_TYPE_CWME9210             3320
+#define MACH_TYPE_CWME9210JS           3321
+#define MACH_TYPE_PGS_SITARA           3322
+#define MACH_TYPE_COLIBRI_TEGRA2       3323
+#define MACH_TYPE_W21                  3324
+#define MACH_TYPE_POLYSAT1             3325
+#define MACH_TYPE_DATAWAY              3326
+#define MACH_TYPE_COBRAL138            3327
+#define MACH_TYPE_ROVERPCS8            3328
+#define MACH_TYPE_MARVELC              3329
+#define MACH_TYPE_NAVEFIHID            3330
+#define MACH_TYPE_DM365_CV100          3331
+#define MACH_TYPE_ABLE                 3332
+#define MACH_TYPE_LEGACY               3333
+#define MACH_TYPE_ICONG                3334
+#define MACH_TYPE_ROVER_G8             3335
+#define MACH_TYPE_T5388P               3336
+#define MACH_TYPE_DINGO                3337
+#define MACH_TYPE_GOFLEXHOME           3338
+#define MACH_TYPE_LANREADYFN511        3340
+#define MACH_TYPE_OMAP3_BAIA           3341
+#define MACH_TYPE_OMAP3SMARTDISPLAY    3342
+#define MACH_TYPE_XILINX               3343
+#define MACH_TYPE_A2F                  3344
+#define MACH_TYPE_SKY25                3345
+#define MACH_TYPE_CCMX53               3346
+#define MACH_TYPE_CCMX53JS             3347
+#define MACH_TYPE_CCWMX53              3348
+#define MACH_TYPE_CCWMX53JS            3349
+#define MACH_TYPE_FRISMS               3350
+#define MACH_TYPE_MSM7X27A_FFA         3351
+#define MACH_TYPE_MSM7X27A_SURF        3352
+#define MACH_TYPE_MSM7X27A_RUMI3       3353
+#define MACH_TYPE_DIMMSAM9G20          3354
+#define MACH_TYPE_DIMM_IMX28           3355
+#define MACH_TYPE_AMK_A4               3356
+#define MACH_TYPE_GNET_SGME            3357
+#define MACH_TYPE_SHOOTER_U            3358
+#define MACH_TYPE_VMX53                3359
+#define MACH_TYPE_RHINO                3360
+#define MACH_TYPE_ARMLEX4210           3361
+#define MACH_TYPE_SWARCOEXTMODEM       3362
+#define MACH_TYPE_SNOWBALL             3363
+#define MACH_TYPE_PCM049               3364
+#define MACH_TYPE_VIGOR                3365
+#define MACH_TYPE_OSLO_AMUNDSEN        3366
+#define MACH_TYPE_GSL_DIAMOND          3367
+#define MACH_TYPE_CV2201               3368
+#define MACH_TYPE_CV2202               3369
+#define MACH_TYPE_CV2203               3370
+#define MACH_TYPE_VIT_IBOX             3371
+#define MACH_TYPE_DM6441_ESP           3372
+#define MACH_TYPE_AT91SAM9X5EK         3373
+#define MACH_TYPE_LIBRA                3374
+#define MACH_TYPE_EASYCRRH             3375
+#define MACH_TYPE_TRIPEL               3376
+#define MACH_TYPE_ENDIAN_MINI          3377
+#define MACH_TYPE_XILINX_EP107         3378
+#define MACH_TYPE_NURI                 3379
+#define MACH_TYPE_JANUS                3380
+#define MACH_TYPE_DDNAS                3381
+#define MACH_TYPE_TAG                  3382
+#define MACH_TYPE_TAGW                 3383
+#define MACH_TYPE_NITROGEN_VM_IMX51    3384
+#define MACH_TYPE_VIPRINET             3385
+#define MACH_TYPE_BOCKW                3386
+#define MACH_TYPE_EVA2000              3387
+#define MACH_TYPE_STEELYARD            3388
+#define MACH_TYPE_MACH_SDH001          3390
+#define MACH_TYPE_NSSLSBOARD           3392
+#define MACH_TYPE_GENEVA_B5            3393
+#define MACH_TYPE_SPEAR1340            3394
+#define MACH_TYPE_REXMAS               3395
+#define MACH_TYPE_MSM8960_CDP          3396
+#define MACH_TYPE_MSM8960_MDP          3397
+#define MACH_TYPE_MSM8960_FLUID        3398
+#define MACH_TYPE_MSM8960_APQ          3399
+#define MACH_TYPE_HELIOS_V2            3400
+#define MACH_TYPE_MIF10P               3401
+#define MACH_TYPE_IAM28                3402
+#define MACH_TYPE_PICASSO              3403
+#define MACH_TYPE_MR301A               3404
+#define MACH_TYPE_NOTLE                3405
+#define MACH_TYPE_EELX2                3406
+#define MACH_TYPE_MOON                 3407
+#define MACH_TYPE_RUBY                 3408
+#define MACH_TYPE_GOLDENGATE           3409
+#define MACH_TYPE_CTBU_GEN2            3410
+#define MACH_TYPE_KMP_AM17_01          3411
+#define MACH_TYPE_WTPLUG               3412
+#define MACH_TYPE_MX27SU2              3413
+#define MACH_TYPE_NB31                 3414
+#define MACH_TYPE_HJSDU                3415
+#define MACH_TYPE_TD3_REV1             3416
+#define MACH_TYPE_EAG_CI4000           3417
+#define MACH_TYPE_NET5BIG_NAND_V2      3418
+#define MACH_TYPE_CPX2                 3419
+#define MACH_TYPE_NET2BIG_NAND_V2      3420
+#define MACH_TYPE_ECUV5                3421
+#define MACH_TYPE_HSGX6D               3422
+#define MACH_TYPE_DAWAD7               3423
+#define MACH_TYPE_SAM9REPEATER         3424
+#define MACH_TYPE_GT_I5700             3425
+#define MACH_TYPE_CTERA_PLUG_C2        3426
+#define MACH_TYPE_MARVELCT             3427
+#define MACH_TYPE_AG11005              3428
+#define MACH_TYPE_VANGOGH              3430
+#define MACH_TYPE_MATRIX505            3431
+#define MACH_TYPE_OCE_NIGMA            3432
+#define MACH_TYPE_T55                  3433
+#define MACH_TYPE_BIO3K                3434
+#define MACH_TYPE_EXPRESSCT            3435
+#define MACH_TYPE_CARDHU               3436
+#define MACH_TYPE_ARUBA                3437
+#define MACH_TYPE_BONAIRE              3438
+#define MACH_TYPE_NUC700EVB            3439
+#define MACH_TYPE_NUC710EVB            3440
+#define MACH_TYPE_NUC740EVB            3441
+#define MACH_TYPE_NUC745EVB            3442
+#define MACH_TYPE_TRANSCEDE            3443
+#define MACH_TYPE_MORA                 3444
+#define MACH_TYPE_NDA_EVM              3445
+#define MACH_TYPE_TIMU                 3446
+#define MACH_TYPE_EXPRESSH             3447
+#define MACH_TYPE_VERIDIS_A300         3448
+#define MACH_TYPE_DM368_LEOPARD        3449
+#define MACH_TYPE_OMAP_MCOP            3450
+#define MACH_TYPE_TRITIP               3451
+#define MACH_TYPE_SM1K                 3452
+#define MACH_TYPE_MONCH                3453
+#define MACH_TYPE_CURACAO              3454
+#define MACH_TYPE_ORIGEN               3455
+#define MACH_TYPE_EPC10                3456
+#define MACH_TYPE_SGH_I740             3457
+#define MACH_TYPE_TUNA                 3458
+#define MACH_TYPE_MX51_TULIP           3459
+#define MACH_TYPE_MX51_ASTER7          3460
+#define MACH_TYPE_ACRO37XBRD           3461
+#define MACH_TYPE_ELKE                 3462
+#define MACH_TYPE_SBC6000X             3463
+#define MACH_TYPE_R1801E               3464
+#define MACH_TYPE_H1600                3465
+#define MACH_TYPE_MINI210              3466
+#define MACH_TYPE_MINI8168             3467
+#define MACH_TYPE_PC7308               3468
+#define MACH_TYPE_KMM2M01              3470
+#define MACH_TYPE_MX51EREBUS           3471
+#define MACH_TYPE_WM8650REFBOARD       3472
+#define MACH_TYPE_TUXRAIL              3473
+#define MACH_TYPE_ARTHUR               3474
+#define MACH_TYPE_DOORBOY              3475
+#define MACH_TYPE_XARINA               3476
+#define MACH_TYPE_ROVERX7              3477
+#define MACH_TYPE_SDVR                 3478
+#define MACH_TYPE_ACER_MAYA            3479
+#define MACH_TYPE_PICO                 3480
+#define MACH_TYPE_CWMX233              3481
+#define MACH_TYPE_CWAM1808             3482
+#define MACH_TYPE_CWDM365              3483
+#define MACH_TYPE_MX51_MORAY           3484
+#define MACH_TYPE_THALES_CBC           3485
+#define MACH_TYPE_BLUEPOINT            3486
+#define MACH_TYPE_DIR665               3487
+#define MACH_TYPE_ACMEROVER1           3488
+#define MACH_TYPE_SHOOTER_CT           3489
+#define MACH_TYPE_BLISS                3490
+#define MACH_TYPE_BLISSC               3491
+#define MACH_TYPE_THALES_ADC           3492
+#define MACH_TYPE_UBISYS_P9D_EVP       3493
+#define MACH_TYPE_ATDGP318             3494
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMLD
+# endif
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
+#else
+# define machine_is_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTE2
+# endif
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
+#else
+# define machine_is_palmte2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTX
+# endif
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
+#else
+# define machine_is_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT5
+# endif
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
+#else
+# define machine_is_palmt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTC
+# endif
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
+#else
+# define machine_is_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
+# endif
+# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
+#else
+# define machine_is_omap_3430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO680
+# endif
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
+#else
+# define machine_is_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI320
+# endif
+# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
+#else
+# define machine_is_colibri320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAM60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAM60
+# endif
+# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
+#else
+# define machine_is_cam60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91EB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91EB01
+# endif
+# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
+#else
+# define machine_is_at91eb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F5281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F5281
+# endif
+# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
+#else
+# define machine_is_db88f5281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB726
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB726
+# endif
+# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
+#else
+# define machine_is_csb726()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
+# endif
+# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
+#else
+# define machine_is_davinci_dm6467_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
+# endif
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
+#else
+# define machine_is_davinci_dm355_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITTLETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITTLETON
+# endif
+# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
+#else
+# define machine_is_littleton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB11MP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
+# endif
+# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
+#else
+# define machine_is_realview_pb11mp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_3DS
+# endif
+# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
+#else
+# define machine_is_mx27_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALIBUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALIBUT
+# endif
+# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
+#else
+# define machine_is_halibut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROUT
+# endif
+# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
+#else
+# define machine_is_trout()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCT_HAMMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
+# endif
+# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
+#else
+# define machine_is_tct_hammer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERALD
+# endif
+# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
+#else
+# define machine_is_herald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIM_ONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIM_ONE
+# endif
+# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
+#else
+# define machine_is_sim_one()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIVE
+# endif
+# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
+#else
+# define machine_is_jive()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9260
+# endif
+# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
+#else
+# define machine_is_sam9_l9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
+# endif
+# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
+#else
+# define machine_is_realview_pb1176()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL9200
+# endif
+# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
+#else
+# define machine_is_yl9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5182
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5182
+# endif
+# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
+#else
+# define machine_is_rd88f5182()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KUROBOX_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
+# endif
+# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
+#else
+# define machine_is_kurobox_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_3DS
+# endif
+# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
+#else
+# define machine_is_mx31_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QONG
+# endif
+# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
+#else
+# define machine_is_qong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP2EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP2EVM
+# endif
+# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
+#else
+# define machine_is_omap2evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3EVM
+# endif
+# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
+#else
+# define machine_is_omap3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS323
+# endif
+# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
+#else
+# define machine_is_dns323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BEAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
+# endif
+# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
+#else
+# define machine_is_omap3_beagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810
+# endif
+# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
+#else
+# define machine_is_nokia_n810()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM038
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM038
+# endif
+# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
+#else
+# define machine_is_pcm038()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS209
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS209
+# endif
+# define machine_is_ts_x09()	(machine_arch_type == MACH_TYPE_TS209)
+#else
+# define machine_is_ts_x09()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9ADK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
+# endif
+# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
+#else
+# define machine_is_at91cap9adk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31MOBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
+# endif
+# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
+#else
+# define machine_is_mx31moboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_PRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
+# endif
+# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
+#else
+# define machine_is_terastation_pro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
+# endif
+# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
+#else
+# define machine_is_linkstation_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E350
+# endif
+# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
+#else
+# define machine_is_e350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS409
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS409
+# endif
+# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
+#else
+# define machine_is_ts409()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEUROS_OSD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
+# endif
+# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
+#else
+# define machine_is_neuros_osd2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
+# endif
+# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
+#else
+# define machine_is_davinci_da830_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFEB
+# endif
+# define machine_is_at572d940hfek()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
+#else
+# define machine_is_at572d940hfek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB
+# endif
+# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
+#else
+# define machine_is_dove_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX27
+# endif
+# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX27)
+#else
+# define machine_is_eukrea_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEXPRESS
+# endif
+# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
+#else
+# define machine_is_vexpress()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6442
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6442
+# endif
+# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
+#else
+# define machine_is_smdk6442()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
+# endif
+# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
+#else
+# define machine_is_openrd_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT8000
+# endif
+# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
+#else
+# define machine_is_devkit8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
+# endif
+# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
+#else
+# define machine_is_mx51_efikamx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T35
+# endif
+# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
+#else
+# define machine_is_cm_t35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG
+# endif
+# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
+#else
+# define machine_is_net2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0020
+# endif
+# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
+#else
+# define machine_is_igep0020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC932EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC932EVB
+# endif
+# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
+#else
+# define machine_is_nuc932evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_CLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
+# endif
+# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
+#else
+# define machine_is_openrd_client()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U8500
+# endif
+# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
+#else
+# define machine_is_u8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
+# endif
+# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
+#else
+# define machine_is_mx51_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
+# endif
+# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
+#else
+# define machine_is_marvell_jasper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLINT
+# endif
+# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
+#else
+# define machine_is_flint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB3
+# endif
+# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
+#else
+# define machine_is_tavorevb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
+# endif
+# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
+#else
+# define machine_is_touchbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_RC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
+# endif
+# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
+#else
+# define machine_is_raumfeld_rc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
+# endif
+# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
+#else
+# define machine_is_raumfeld_connector()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
+# endif
+# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
+#else
+# define machine_is_raumfeld_speaker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNETV107X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNETV107X
+# endif
+# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
+#else
+# define machine_is_tnetv107x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_BEI2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_BEI2
+# endif
+# define machine_is_riot_bei2()	(machine_arch_type == MACH_TYPE_RIOT_BEI2)
+#else
+# define machine_is_riot_bei2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_X37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_X37
+# endif
+# define machine_is_riot_x37()	(machine_arch_type == MACH_TYPE_RIOT_X37)
+#else
+# define machine_is_riot_x37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAPC7117
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAPC7117
+# endif
+# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
+#else
+# define machine_is_capc7117()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTROL
+# endif
+# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
+#else
+# define machine_is_icontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
+# endif
+# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
+#else
+# define machine_is_qsd8x50a_st1_5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX23EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX23EVK
+# endif
+# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
+#else
+# define machine_is_mx23evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP4EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP4EVB
+# endif
+# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
+#else
+# define machine_is_ap4evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MITYOMAPL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
+# endif
+# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
+#else
+# define machine_is_mityomapl138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURUPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURUPLUG
+# endif
+# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
+#else
+# define machine_is_guruplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR310
+# endif
+# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
+#else
+# define machine_is_spear310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320
+# endif
+# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
+#else
+# define machine_is_spear320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUILA
+# endif
+# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
+#else
+# define machine_is_aquila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
+# endif
+# define machine_is_sheeva_esata()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
+#else
+# define machine_is_sheeva_esata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
+# endif
+# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
+#else
+# define machine_is_msm7x30_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA2478DEVKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA2478DEVKIT
+# endif
+# define machine_is_ea2478devkit()	(machine_arch_type == MACH_TYPE_EA2478DEVKIT)
+#else
+# define machine_is_ea2478devkit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_WXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
+# endif
+# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
+#else
+# define machine_is_terastation_wxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
+# endif
+# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
+#else
+# define machine_is_msm7x25_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
+# endif
+# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
+#else
+# define machine_is_msm7x25_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
+# endif
+# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
+#else
+# define machine_is_msm7x27_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
+# endif
+# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
+#else
+# define machine_is_msm7x27_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
+# endif
+# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
+#else
+# define machine_is_msm7x30_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
+# endif
+# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
+#else
+# define machine_is_qsd8x50_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EVK
+# endif
+# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
+#else
+# define machine_is_mx53_evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0030
+# endif
+# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
+#else
+# define machine_is_igep0030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC3530
+# endif
+# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
+#else
+# define machine_is_sbc3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB
+# endif
+# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
+#else
+# define machine_is_saarb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARMONY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARMONY
+# endif
+# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
+#else
+# define machine_is_harmony()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
+# endif
+# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
+#else
+# define machine_is_msm7x30_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3517
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3517
+# endif
+# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
+#else
+# define machine_is_cm_t3517()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD222
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD222
+# endif
+# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
+#else
+# define machine_is_wbd222()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
+# endif
+# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
+#else
+# define machine_is_msm8x60_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
+# endif
+# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
+#else
+# define machine_is_msm8x60_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC8000_SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
+# endif
+# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
+#else
+# define machine_is_tcc8000_sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOS
+# endif
+# define machine_is_nanos()	(machine_arch_type == MACH_TYPE_NANOS)
+#else
+# define machine_is_nanos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G45
+# endif
+# define machine_is_stamp9g45()	(machine_arch_type == MACH_TYPE_STAMP9G45)
+#else
+# define machine_is_stamp9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS3420VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS3420VB
+# endif
+# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
+#else
+# define machine_is_cns3420vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP4_PANDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
+# endif
+# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
+#else
+# define machine_is_omap4_panda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8168EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8168EVM
+# endif
+# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
+#else
+# define machine_is_ti8168evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON_BGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON_BGA
+# endif
+# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
+#else
+# define machine_is_teton_bga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX25SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25SD
+# endif
+# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25SD)
+#else
+# define machine_is_eukrea_cpuimx25sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX35SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35SD
+# endif
+# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35SD)
+#else
+# define machine_is_eukrea_cpuimx35sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
+# endif
+# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
+#else
+# define machine_is_eukrea_cpuimx51sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
+# endif
+# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
+#else
+# define machine_is_eukrea_cpuimx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC210
+# endif
+# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
+#else
+# define machine_is_smdkc210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BRAILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BRAILLO
+# endif
+# define machine_is_omap3_braillo()	(machine_arch_type == MACH_TYPE_OMAP3_BRAILLO)
+#else
+# define machine_is_omap3_braillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPYPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPYPLUG
+# endif
+# define machine_is_spyplug()	(machine_arch_type == MACH_TYPE_SPYPLUG)
+#else
+# define machine_is_spyplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GINGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GINGER
+# endif
+# define machine_is_ginger()	(machine_arch_type == MACH_TYPE_GINGER)
+#else
+# define machine_is_ginger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_T3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_T3530
+# endif
+# define machine_is_tny_t3530()	(machine_arch_type == MACH_TYPE_TNY_T3530)
+#else
+# define machine_is_tny_t3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA102
+# endif
+# define machine_is_pca102()	(machine_arch_type == MACH_TYPE_PCA102)
+#else
+# define machine_is_pca102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPADE
+# endif
+# define machine_is_spade()	(machine_arch_type == MACH_TYPE_SPADE)
+#else
+# define machine_is_spade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC25_TOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC25_TOPAZ
+# endif
+# define machine_is_mxc25_topaz()	(machine_arch_type == MACH_TYPE_MXC25_TOPAZ)
+#else
+# define machine_is_mxc25_topaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5325
+# endif
+# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
+#else
+# define machine_is_t5325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GW2361
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GW2361
+# endif
+# define machine_is_gw2361()	(machine_arch_type == MACH_TYPE_GW2361)
+#else
+# define machine_is_gw2361()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELOG
+# endif
+# define machine_is_elog()	(machine_arch_type == MACH_TYPE_ELOG)
+#else
+# define machine_is_elog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCOME
+# endif
+# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
+#else
+# define machine_is_income()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM589X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM589X
+# endif
+# define machine_is_bcm589x()	(machine_arch_type == MACH_TYPE_BCM589X)
+#else
+# define machine_is_bcm589x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETNA
+# endif
+# define machine_is_etna()	(machine_arch_type == MACH_TYPE_ETNA)
+#else
+# define machine_is_etna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWKS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWKS
+# endif
+# define machine_is_hawks()	(machine_arch_type == MACH_TYPE_HAWKS)
+#else
+# define machine_is_hawks()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON
+# endif
+# define machine_is_meson()	(machine_arch_type == MACH_TYPE_MESON)
+#else
+# define machine_is_meson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSBASE255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSBASE255
+# endif
+# define machine_is_xsbase255()	(machine_arch_type == MACH_TYPE_XSBASE255)
+#else
+# define machine_is_xsbase255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVM2030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVM2030
+# endif
+# define machine_is_pvm2030()	(machine_arch_type == MACH_TYPE_PVM2030)
+#else
+# define machine_is_pvm2030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA502
+# endif
+# define machine_is_mioa502()	(machine_arch_type == MACH_TYPE_MIOA502)
+#else
+# define machine_is_mioa502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDORIG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDORIG2
+# endif
+# define machine_is_vvbox_sdorig2()	(machine_arch_type == MACH_TYPE_VVBOX_SDORIG2)
+#else
+# define machine_is_vvbox_sdorig2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDLITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDLITE2
+# endif
+# define machine_is_vvbox_sdlite2()	(machine_arch_type == MACH_TYPE_VVBOX_SDLITE2)
+#else
+# define machine_is_vvbox_sdlite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDPRO4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDPRO4
+# endif
+# define machine_is_vvbox_sdpro4()	(machine_arch_type == MACH_TYPE_VVBOX_SDPRO4)
+#else
+# define machine_is_vvbox_sdpro4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_SPV_M700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_SPV_M700
+# endif
+# define machine_is_htc_spv_m700()	(machine_arch_type == MACH_TYPE_HTC_SPV_M700)
+#else
+# define machine_is_htc_spv_m700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SX
+# endif
+# define machine_is_mx257sx()	(machine_arch_type == MACH_TYPE_MX257SX)
+#else
+# define machine_is_mx257sx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GONI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONI
+# endif
+# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
+#else
+# define machine_is_goni()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_FFA
+# endif
+# define machine_is_msm8x55_svlte_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_FFA)
+#else
+# define machine_is_msm8x55_svlte_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_SURF
+# endif
+# define machine_is_msm8x55_svlte_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_SURF)
+#else
+# define machine_is_msm8x55_svlte_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUICKSTEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUICKSTEP
+# endif
+# define machine_is_quickstep()	(machine_arch_type == MACH_TYPE_QUICKSTEP)
+#else
+# define machine_is_quickstep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMW96
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMW96
+# endif
+# define machine_is_dmw96()	(machine_arch_type == MACH_TYPE_DMW96)
+#else
+# define machine_is_dmw96()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAMMERHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAMMERHEAD
+# endif
+# define machine_is_hammerhead()	(machine_arch_type == MACH_TYPE_HAMMERHEAD)
+#else
+# define machine_is_hammerhead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIDENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIDENT
+# endif
+# define machine_is_trident()	(machine_arch_type == MACH_TYPE_TRIDENT)
+#else
+# define machine_is_trident()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIGHTNING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIGHTNING
+# endif
+# define machine_is_lightning()	(machine_arch_type == MACH_TYPE_LIGHTNING)
+#else
+# define machine_is_lightning()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONNECT
+# endif
+# define machine_is_iconnect()	(machine_arch_type == MACH_TYPE_ICONNECT)
+#else
+# define machine_is_iconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUTOBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTOBOT
+# endif
+# define machine_is_autobot()	(machine_arch_type == MACH_TYPE_AUTOBOT)
+#else
+# define machine_is_autobot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COCONUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COCONUT
+# endif
+# define machine_is_coconut()	(machine_arch_type == MACH_TYPE_COCONUT)
+#else
+# define machine_is_coconut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURIAN
+# endif
+# define machine_is_durian()	(machine_arch_type == MACH_TYPE_DURIAN)
+#else
+# define machine_is_durian()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAYENNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAYENNE
+# endif
+# define machine_is_cayenne()	(machine_arch_type == MACH_TYPE_CAYENNE)
+#else
+# define machine_is_cayenne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJI
+# endif
+# define machine_is_fuji()	(machine_arch_type == MACH_TYPE_FUJI)
+#else
+# define machine_is_fuji()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYNOLOGY_6282
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYNOLOGY_6282
+# endif
+# define machine_is_synology_6282()	(machine_arch_type == MACH_TYPE_SYNOLOGY_6282)
+#else
+# define machine_is_synology_6282()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM1SY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM1SY
+# endif
+# define machine_is_em1sy()	(machine_arch_type == MACH_TYPE_EM1SY)
+#else
+# define machine_is_em1sy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M502
+# endif
+# define machine_is_m502()	(machine_arch_type == MACH_TYPE_M502)
+#else
+# define machine_is_m502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX518
+# endif
+# define machine_is_matrix518()	(machine_arch_type == MACH_TYPE_MATRIX518)
+#else
+# define machine_is_matrix518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINY_GURNARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINY_GURNARD
+# endif
+# define machine_is_tiny_gurnard()	(machine_arch_type == MACH_TYPE_TINY_GURNARD)
+#else
+# define machine_is_tiny_gurnard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1310
+# endif
+# define machine_is_spear1310()	(machine_arch_type == MACH_TYPE_SPEAR1310)
+#else
+# define machine_is_spear1310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BV07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BV07
+# endif
+# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
+#else
+# define machine_is_bv07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD61
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD61
+# endif
+# define machine_is_mxt_td61()	(machine_arch_type == MACH_TYPE_MXT_TD61)
+#else
+# define machine_is_mxt_td61()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_ULTIMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
+# endif
+# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
+#else
+# define machine_is_openrd_ultimate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVIXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVIXP
+# endif
+# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
+#else
+# define machine_is_devixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICCPT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICCPT
+# endif
+# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
+#else
+# define machine_is_miccpt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIC256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIC256
+# endif
+# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
+#else
+# define machine_is_mic256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS1167
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS1167
+# endif
+# define machine_is_as1167()	(machine_arch_type == MACH_TYPE_AS1167)
+#else
+# define machine_is_as1167()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_IBIZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_IBIZA
+# endif
+# define machine_is_omap3_ibiza()	(machine_arch_type == MACH_TYPE_OMAP3_IBIZA)
+#else
+# define machine_is_omap3_ibiza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U5500
+# endif
+# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
+#else
+# define machine_is_u5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_PICTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_PICTO
+# endif
+# define machine_is_davinci_picto()	(machine_arch_type == MACH_TYPE_DAVINCI_PICTO)
+#else
+# define machine_is_davinci_picto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MECHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MECHA
+# endif
+# define machine_is_mecha()	(machine_arch_type == MACH_TYPE_MECHA)
+#else
+# define machine_is_mecha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUBBA3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUBBA3
+# endif
+# define machine_is_bubba3()	(machine_arch_type == MACH_TYPE_BUBBA3)
+#else
+# define machine_is_bubba3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPITRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPITRE
+# endif
+# define machine_is_pupitre()	(machine_arch_type == MACH_TYPE_PUPITRE)
+#else
+# define machine_is_pupitre()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_VOGUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_VOGUE
+# endif
+# define machine_is_tegra_vogue()	(machine_arch_type == MACH_TYPE_TEGRA_VOGUE)
+#else
+# define machine_is_tegra_vogue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_E1165
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_E1165
+# endif
+# define machine_is_tegra_e1165()	(machine_arch_type == MACH_TYPE_TEGRA_E1165)
+#else
+# define machine_is_tegra_e1165()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMPLENET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPLENET
+# endif
+# define machine_is_simplenet()	(machine_arch_type == MACH_TYPE_SIMPLENET)
+#else
+# define machine_is_simplenet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EC4350TBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EC4350TBM
+# endif
+# define machine_is_ec4350tbm()	(machine_arch_type == MACH_TYPE_EC4350TBM)
+#else
+# define machine_is_ec4350tbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEC_TC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEC_TC
+# endif
+# define machine_is_pec_tc()	(machine_arch_type == MACH_TYPE_PEC_TC)
+#else
+# define machine_is_pec_tc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEC_HC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEC_HC2
+# endif
+# define machine_is_pec_hc2()	(machine_arch_type == MACH_TYPE_PEC_HC2)
+#else
+# define machine_is_pec_hc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_MOBILIS_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_MOBILIS_A
+# endif
+# define machine_is_esl_mobilis_a()	(machine_arch_type == MACH_TYPE_ESL_MOBILIS_A)
+#else
+# define machine_is_esl_mobilis_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_MOBILIS_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_MOBILIS_B
+# endif
+# define machine_is_esl_mobilis_b()	(machine_arch_type == MACH_TYPE_ESL_MOBILIS_B)
+#else
+# define machine_is_esl_mobilis_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_WAVE_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WAVE_A
+# endif
+# define machine_is_esl_wave_a()	(machine_arch_type == MACH_TYPE_ESL_WAVE_A)
+#else
+# define machine_is_esl_wave_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_WAVE_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WAVE_B
+# endif
+# define machine_is_esl_wave_b()	(machine_arch_type == MACH_TYPE_ESL_WAVE_B)
+#else
+# define machine_is_esl_wave_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNISENSE_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNISENSE_MMM
+# endif
+# define machine_is_unisense_mmm()	(machine_arch_type == MACH_TYPE_UNISENSE_MMM)
+#else
+# define machine_is_unisense_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUESHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESHARK
+# endif
+# define machine_is_blueshark()	(machine_arch_type == MACH_TYPE_BLUESHARK)
+#else
+# define machine_is_blueshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E10
+# endif
+# define machine_is_e10()	(machine_arch_type == MACH_TYPE_E10)
+#else
+# define machine_is_e10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APP3K_ROBIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APP3K_ROBIN
+# endif
+# define machine_is_app3k_robin()	(machine_arch_type == MACH_TYPE_APP3K_ROBIN)
+#else
+# define machine_is_app3k_robin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POV15HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POV15HD
+# endif
+# define machine_is_pov15hd()	(machine_arch_type == MACH_TYPE_POV15HD)
+#else
+# define machine_is_pov15hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STELLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STELLA
+# endif
+# define machine_is_stella()	(machine_arch_type == MACH_TYPE_STELLA)
+#else
+# define machine_is_stella()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LSCHL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
+# endif
+# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
+#else
+# define machine_is_linkstation_lschl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWALKER
+# endif
+# define machine_is_netwalker()	(machine_arch_type == MACH_TYPE_NETWALKER)
+#else
+# define machine_is_netwalker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACSX106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACSX106
+# endif
+# define machine_is_acsx106()	(machine_arch_type == MACH_TYPE_ACSX106)
+#else
+# define machine_is_acsx106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS5_C1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS5_C1
+# endif
+# define machine_is_atlas5_c1()	(machine_arch_type == MACH_TYPE_ATLAS5_C1)
+#else
+# define machine_is_atlas5_c1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB3AST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB3AST
+# endif
+# define machine_is_nsb3ast()	(machine_arch_type == MACH_TYPE_NSB3AST)
+#else
+# define machine_is_nsb3ast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SLC
+# endif
+# define machine_is_gnet_slc()	(machine_arch_type == MACH_TYPE_GNET_SLC)
+#else
+# define machine_is_gnet_slc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AF4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AF4000
+# endif
+# define machine_is_af4000()	(machine_arch_type == MACH_TYPE_AF4000)
+#else
+# define machine_is_af4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARK9431
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARK9431
+# endif
+# define machine_is_ark9431()	(machine_arch_type == MACH_TYPE_ARK9431)
+#else
+# define machine_is_ark9431()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS_S5PC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS_S5PC100
+# endif
+# define machine_is_fs_s5pc100()	(machine_arch_type == MACH_TYPE_FS_S5PC100)
+#else
+# define machine_is_fs_s5pc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3505NOVA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3505NOVA8
+# endif
+# define machine_is_omap3505nova8()	(machine_arch_type == MACH_TYPE_OMAP3505NOVA8)
+#else
+# define machine_is_omap3505nova8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3621_EDP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3621_EDP1
+# endif
+# define machine_is_omap3621_edp1()	(machine_arch_type == MACH_TYPE_OMAP3621_EDP1)
+#else
+# define machine_is_omap3621_edp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISAES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISAES
+# endif
+# define machine_is_oratisaes()	(machine_arch_type == MACH_TYPE_ORATISAES)
+#else
+# define machine_is_oratisaes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV310
+# endif
+# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
+#else
+# define machine_is_smdkv310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIEMENS_L0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIEMENS_L0
+# endif
+# define machine_is_siemens_l0()	(machine_arch_type == MACH_TYPE_SIEMENS_L0)
+#else
+# define machine_is_siemens_l0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTANA
+# endif
+# define machine_is_ventana()	(machine_arch_type == MACH_TYPE_VENTANA)
+#else
+# define machine_is_ventana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
+# endif
+# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
+#else
+# define machine_is_wm8505_7in_netbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EC4350SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EC4350SDB
+# endif
+# define machine_is_ec4350sdb()	(machine_arch_type == MACH_TYPE_EC4350SDB)
+#else
+# define machine_is_ec4350sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIMAS
+# endif
+# define machine_is_mimas()	(machine_arch_type == MACH_TYPE_MIMAS)
+#else
+# define machine_is_mimas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TITAN
+# endif
+# define machine_is_titan()	(machine_arch_type == MACH_TYPE_TITAN)
+#else
+# define machine_is_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRANEBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRANEBOARD
+# endif
+# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
+#else
+# define machine_is_craneboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ES2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ES2440
+# endif
+# define machine_is_es2440()	(machine_arch_type == MACH_TYPE_ES2440)
+#else
+# define machine_is_es2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAJAY_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAJAY_A9263
+# endif
+# define machine_is_najay_a9263()	(machine_arch_type == MACH_TYPE_NAJAY_A9263)
+#else
+# define machine_is_najay_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCTORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCTORNADO
+# endif
+# define machine_is_htctornado()	(machine_arch_type == MACH_TYPE_HTCTORNADO)
+#else
+# define machine_is_htctornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_MX257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_MX257
+# endif
+# define machine_is_dimm_mx257()	(machine_arch_type == MACH_TYPE_DIMM_MX257)
+#else
+# define machine_is_dimm_mx257()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIGEN
+# endif
+# define machine_is_jigen301()	(machine_arch_type == MACH_TYPE_JIGEN)
+#else
+# define machine_is_jigen301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6450
+# endif
+# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
+#else
+# define machine_is_smdk6450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENO_QNG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENO_QNG
+# endif
+# define machine_is_meno_qng()	(machine_arch_type == MACH_TYPE_MENO_QNG)
+#else
+# define machine_is_meno_qng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2416
+# endif
+# define machine_is_ns2416()	(machine_arch_type == MACH_TYPE_NS2416)
+#else
+# define machine_is_ns2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RPC353
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RPC353
+# endif
+# define machine_is_rpc353()	(machine_arch_type == MACH_TYPE_RPC353)
+#else
+# define machine_is_rpc353()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQ6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQ6410
+# endif
+# define machine_is_tq6410()	(machine_arch_type == MACH_TYPE_TQ6410)
+#else
+# define machine_is_tq6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY6410
+# endif
+# define machine_is_sky6410()	(machine_arch_type == MACH_TYPE_SKY6410)
+#else
+# define machine_is_sky6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DYNASTY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DYNASTY
+# endif
+# define machine_is_dynasty()	(machine_arch_type == MACH_TYPE_DYNASTY)
+#else
+# define machine_is_dynasty()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVO
+# endif
+# define machine_is_vivo()	(machine_arch_type == MACH_TYPE_VIVO)
+#else
+# define machine_is_vivo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BURY_BL7582
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BURY_BL7582
+# endif
+# define machine_is_bury_bl7582()	(machine_arch_type == MACH_TYPE_BURY_BL7582)
+#else
+# define machine_is_bury_bl7582()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BURY_BPS5270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BURY_BPS5270
+# endif
+# define machine_is_bury_bps5270()	(machine_arch_type == MACH_TYPE_BURY_BPS5270)
+#else
+# define machine_is_bury_bps5270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BASI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BASI
+# endif
+# define machine_is_basi()	(machine_arch_type == MACH_TYPE_BASI)
+#else
+# define machine_is_basi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TN200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TN200
+# endif
+# define machine_is_tn200()	(machine_arch_type == MACH_TYPE_TN200)
+#else
+# define machine_is_tn200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C2MMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C2MMI
+# endif
+# define machine_is_c2mmi()	(machine_arch_type == MACH_TYPE_C2MMI)
+#else
+# define machine_is_c2mmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON_6236M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON_6236M
+# endif
+# define machine_is_meson_6236m()	(machine_arch_type == MACH_TYPE_MESON_6236M)
+#else
+# define machine_is_meson_6236m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON_8626M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON_8626M
+# endif
+# define machine_is_meson_8626m()	(machine_arch_type == MACH_TYPE_MESON_8626M)
+#else
+# define machine_is_meson_8626m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUBE
+# endif
+# define machine_is_tube()	(machine_arch_type == MACH_TYPE_TUBE)
+#else
+# define machine_is_tube()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESSINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESSINA
+# endif
+# define machine_is_messina()	(machine_arch_type == MACH_TYPE_MESSINA)
+#else
+# define machine_is_messina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_ARM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_ARM2
+# endif
+# define machine_is_mx50_arm2()	(machine_arch_type == MACH_TYPE_MX50_ARM2)
+#else
+# define machine_is_mx50_arm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CETUS9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CETUS9263
+# endif
+# define machine_is_cetus9263()	(machine_arch_type == MACH_TYPE_CETUS9263)
+#else
+# define machine_is_cetus9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BROWNSTONE
+# endif
+# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
+#else
+# define machine_is_brownstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX25
+# endif
+# define machine_is_vmx25()	(machine_arch_type == MACH_TYPE_VMX25)
+#else
+# define machine_is_vmx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX51
+# endif
+# define machine_is_vmx51()	(machine_arch_type == MACH_TYPE_VMX51)
+#else
+# define machine_is_vmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABACUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABACUS
+# endif
+# define machine_is_abacus()	(machine_arch_type == MACH_TYPE_ABACUS)
+#else
+# define machine_is_abacus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4745
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4745
+# endif
+# define machine_is_cm4745()	(machine_arch_type == MACH_TYPE_CM4745)
+#else
+# define machine_is_cm4745()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISLINK
+# endif
+# define machine_is_oratislink()	(machine_arch_type == MACH_TYPE_ORATISLINK)
+#else
+# define machine_is_oratislink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_DVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_DVR
+# endif
+# define machine_is_davinci_dm365_dvr()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_DVR)
+#else
+# define machine_is_davinci_dm365_dvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETVIZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETVIZ
+# endif
+# define machine_is_netviz()	(machine_arch_type == MACH_TYPE_NETVIZ)
+#else
+# define machine_is_netviz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEXIBITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXIBITY
+# endif
+# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
+#else
+# define machine_is_flexibity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLAN_COMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLAN_COMPUTER
+# endif
+# define machine_is_wlan_computer()	(machine_arch_type == MACH_TYPE_WLAN_COMPUTER)
+#else
+# define machine_is_wlan_computer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC24XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC24XX
+# endif
+# define machine_is_lpc24xx()	(machine_arch_type == MACH_TYPE_LPC24XX)
+#else
+# define machine_is_lpc24xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPICA
+# endif
+# define machine_is_spica()	(machine_arch_type == MACH_TYPE_SPICA)
+#else
+# define machine_is_spica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPSDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPSDISPLAY
+# endif
+# define machine_is_gpsdisplay()	(machine_arch_type == MACH_TYPE_GPSDISPLAY)
+#else
+# define machine_is_gpsdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIPNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIPNET
+# endif
+# define machine_is_bipnet()	(machine_arch_type == MACH_TYPE_BIPNET)
+#else
+# define machine_is_bipnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO_CTU_INERTIAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO_CTU_INERTIAL
+# endif
+# define machine_is_overo_ctu_inertial()	(machine_arch_type == MACH_TYPE_OVERO_CTU_INERTIAL)
+#else
+# define machine_is_overo_ctu_inertial()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_MMM
+# endif
+# define machine_is_davinci_dm355_mmm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_MMM)
+#else
+# define machine_is_davinci_dm355_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC9260_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC9260_V2
+# endif
+# define machine_is_pc9260_v2()	(machine_arch_type == MACH_TYPE_PC9260_V2)
+#else
+# define machine_is_pc9260_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX7545
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX7545
+# endif
+# define machine_is_ptx7545()	(machine_arch_type == MACH_TYPE_PTX7545)
+#else
+# define machine_is_ptx7545()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TM_EFDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TM_EFDC
+# endif
+# define machine_is_tm_efdc()	(machine_arch_type == MACH_TYPE_TM_EFDC)
+#else
+# define machine_is_tm_efdc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WALDO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WALDO1
+# endif
+# define machine_is_omap3_waldo1()	(machine_arch_type == MACH_TYPE_OMAP3_WALDO1)
+#else
+# define machine_is_omap3_waldo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLYER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLYER
+# endif
+# define machine_is_flyer()	(machine_arch_type == MACH_TYPE_FLYER)
+#else
+# define machine_is_flyer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORNADO3240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORNADO3240
+# endif
+# define machine_is_tornado3240()	(machine_arch_type == MACH_TYPE_TORNADO3240)
+#else
+# define machine_is_tornado3240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLI_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLI_01
+# endif
+# define machine_is_soli_01()	(machine_arch_type == MACH_TYPE_SOLI_01)
+#else
+# define machine_is_soli_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_EUROPALC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_EUROPALC
+# endif
+# define machine_is_omapl138_europalc()	(machine_arch_type == MACH_TYPE_OMAPL138_EUROPALC)
+#else
+# define machine_is_omapl138_europalc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V1
+# endif
+# define machine_is_helios_v1()	(machine_arch_type == MACH_TYPE_HELIOS_V1)
+#else
+# define machine_is_helios_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_LITE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_LITE_V2
+# endif
+# define machine_is_netspace_lite_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_LITE_V2)
+#else
+# define machine_is_netspace_lite_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SSC
+# endif
+# define machine_is_ssc()	(machine_arch_type == MACH_TYPE_SSC)
+#else
+# define machine_is_ssc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PREMIERWAVE_EN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PREMIERWAVE_EN
+# endif
+# define machine_is_premierwave_en()	(machine_arch_type == MACH_TYPE_PREMIERWAVE_EN)
+#else
+# define machine_is_premierwave_en()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WASABI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WASABI
+# endif
+# define machine_is_wasabi()	(machine_arch_type == MACH_TYPE_WASABI)
+#else
+# define machine_is_wasabi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_RDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_RDP
+# endif
+# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
+#else
+# define machine_is_mx50_rdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSAL_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
+# endif
+# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
+#else
+# define machine_is_universal_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REAL6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REAL6410
+# endif
+# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
+#else
+# define machine_is_real6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPX_SAKURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPX_SAKURA
+# endif
+# define machine_is_spx_sakura()	(machine_arch_type == MACH_TYPE_SPX_SAKURA)
+#else
+# define machine_is_spx_sakura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K_2440
+# endif
+# define machine_is_ij3k_2440()	(machine_arch_type == MACH_TYPE_IJ3K_2440)
+#else
+# define machine_is_ij3k_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BC10
+# endif
+# define machine_is_omap3_bc10()	(machine_arch_type == MACH_TYPE_OMAP3_BC10)
+#else
+# define machine_is_omap3_bc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THEBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THEBE
+# endif
+# define machine_is_thebe()	(machine_arch_type == MACH_TYPE_THEBE)
+#else
+# define machine_is_thebe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RV082
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RV082
+# endif
+# define machine_is_rv082()	(machine_arch_type == MACH_TYPE_RV082)
+#else
+# define machine_is_rv082()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLGUEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLGUEST
+# endif
+# define machine_is_armlguest()	(machine_arch_type == MACH_TYPE_ARMLGUEST)
+#else
+# define machine_is_armlguest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TJINC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TJINC1000
+# endif
+# define machine_is_tjinc1000()	(machine_arch_type == MACH_TYPE_TJINC1000)
+#else
+# define machine_is_tjinc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOCKSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOCKSTAR
+# endif
+# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
+#else
+# define machine_is_dockstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8008
+# endif
+# define machine_is_ax8008()	(machine_arch_type == MACH_TYPE_AX8008)
+#else
+# define machine_is_ax8008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGCE
+# endif
+# define machine_is_gnet_sgce()	(machine_arch_type == MACH_TYPE_GNET_SGCE)
+#else
+# define machine_is_gnet_sgce()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXWNAS_500_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXWNAS_500_1000
+# endif
+# define machine_is_pxwnas_500_1000()	(machine_arch_type == MACH_TYPE_PXWNAS_500_1000)
+#else
+# define machine_is_pxwnas_500_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA20
+# endif
+# define machine_is_ea20()	(machine_arch_type == MACH_TYPE_EA20)
+#else
+# define machine_is_ea20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWM2
+# endif
+# define machine_is_awm2()	(machine_arch_type == MACH_TYPE_AWM2)
+#else
+# define machine_is_awm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8148EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8148EVM
+# endif
+# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
+#else
+# define machine_is_ti8148evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABOARD
+# endif
+# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
+#else
+# define machine_is_seaboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_CHLV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_CHLV2
+# endif
+# define machine_is_linkstation_chlv2()	(machine_arch_type == MACH_TYPE_LINKSTATION_CHLV2)
+#else
+# define machine_is_linkstation_chlv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERA_PRO2_RACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERA_PRO2_RACK
+# endif
+# define machine_is_tera_pro2_rack()	(machine_arch_type == MACH_TYPE_TERA_PRO2_RACK)
+#else
+# define machine_is_tera_pro2_rack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBYS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBYS
+# endif
+# define machine_is_rubys()	(machine_arch_type == MACH_TYPE_RUBYS)
+#else
+# define machine_is_rubys()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUARIUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUARIUS
+# endif
+# define machine_is_aquarius()	(machine_arch_type == MACH_TYPE_AQUARIUS)
+#else
+# define machine_is_aquarius()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_ARD
+# endif
+# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
+#else
+# define machine_is_mx53_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_SMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_SMD
+# endif
+# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
+#else
+# define machine_is_mx53_smd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LSWXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LSWXL
+# endif
+# define machine_is_lswxl()	(machine_arch_type == MACH_TYPE_LSWXL)
+#else
+# define machine_is_lswxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_AVNG_V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_AVNG_V3
+# endif
+# define machine_is_dove_avng_v3()	(machine_arch_type == MACH_TYPE_DOVE_AVNG_V3)
+#else
+# define machine_is_dove_avng_v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDI_ESS_9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDI_ESS_9263
+# endif
+# define machine_is_sdi_ess_9263()	(machine_arch_type == MACH_TYPE_SDI_ESS_9263)
+#else
+# define machine_is_sdi_ess_9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JOCPU550
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JOCPU550
+# endif
+# define machine_is_jocpu550()	(machine_arch_type == MACH_TYPE_JOCPU550)
+#else
+# define machine_is_jocpu550()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
+# endif
+# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
+#else
+# define machine_is_msm8x60_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
+# endif
+# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
+#else
+# define machine_is_msm8x60_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YANOMAMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YANOMAMI
+# endif
+# define machine_is_yanomami()	(machine_arch_type == MACH_TYPE_YANOMAMI)
+#else
+# define machine_is_yanomami()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTA04
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTA04
+# endif
+# define machine_is_gta04()	(machine_arch_type == MACH_TYPE_GTA04)
+#else
+# define machine_is_gta04()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_A510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_A510
+# endif
+# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
+#else
+# define machine_is_cm_a510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_RFS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_RFS200
+# endif
+# define machine_is_omap3_rfs200()	(machine_arch_type == MACH_TYPE_OMAP3_RFS200)
+#else
+# define machine_is_omap3_rfs200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KX33XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KX33XX
+# endif
+# define machine_is_kx33xx()	(machine_arch_type == MACH_TYPE_KX33XX)
+#else
+# define machine_is_kx33xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX7510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX7510
+# endif
+# define machine_is_ptx7510()	(machine_arch_type == MACH_TYPE_PTX7510)
+#else
+# define machine_is_ptx7510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000
+# endif
+# define machine_is_top9000()	(machine_arch_type == MACH_TYPE_TOP9000)
+#else
+# define machine_is_top9000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEENOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEENOTE
+# endif
+# define machine_is_teenote()	(machine_arch_type == MACH_TYPE_TEENOTE)
+#else
+# define machine_is_teenote()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS3
+# endif
+# define machine_is_ts3()	(machine_arch_type == MACH_TYPE_TS3)
+#else
+# define machine_is_ts3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A0
+# endif
+# define machine_is_a0()	(machine_arch_type == MACH_TYPE_A0)
+#else
+# define machine_is_a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_SURF
+# endif
+# define machine_is_fsm9xxx_surf()	(machine_arch_type == MACH_TYPE_FSM9XXX_SURF)
+#else
+# define machine_is_fsm9xxx_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_FFA
+# endif
+# define machine_is_fsm9xxx_ffa()	(machine_arch_type == MACH_TYPE_FSM9XXX_FFA)
+#else
+# define machine_is_fsm9xxx_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRRHWCDMA60W
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRRHWCDMA60W
+# endif
+# define machine_is_frrhwcdma60w()	(machine_arch_type == MACH_TYPE_FRRHWCDMA60W)
+#else
+# define machine_is_frrhwcdma60w()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REMUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REMUS
+# endif
+# define machine_is_remus()	(machine_arch_type == MACH_TYPE_REMUS)
+#else
+# define machine_is_remus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP7XDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP7XDK
+# endif
+# define machine_is_at91cap7xdk()	(machine_arch_type == MACH_TYPE_AT91CAP7XDK)
+#else
+# define machine_is_at91cap7xdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP7STK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP7STK
+# endif
+# define machine_is_at91cap7stk()	(machine_arch_type == MACH_TYPE_AT91CAP7STK)
+#else
+# define machine_is_at91cap7stk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT_SBC_SAM9_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT_SBC_SAM9_1
+# endif
+# define machine_is_kt_sbc_sam9_1()	(machine_arch_type == MACH_TYPE_KT_SBC_SAM9_1)
+#else
+# define machine_is_kt_sbc_sam9_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADA_XP_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADA_XP_DB
+# endif
+# define machine_is_armada_xp_db()	(machine_arch_type == MACH_TYPE_ARMADA_XP_DB)
+#else
+# define machine_is_armada_xp_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPDM
+# endif
+# define machine_is_spdm()	(machine_arch_type == MACH_TYPE_SPDM)
+#else
+# define machine_is_spdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTIB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTIB
+# endif
+# define machine_is_gtib()	(machine_arch_type == MACH_TYPE_GTIB)
+#else
+# define machine_is_gtib()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DGM3240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DGM3240
+# endif
+# define machine_is_dgm3240()	(machine_arch_type == MACH_TYPE_DGM3240)
+#else
+# define machine_is_dgm3240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCMEGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCMEGA
+# endif
+# define machine_is_htcmega()	(machine_arch_type == MACH_TYPE_HTCMEGA)
+#else
+# define machine_is_htcmega()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRICORDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRICORDER
+# endif
+# define machine_is_tricorder()	(machine_arch_type == MACH_TYPE_TRICORDER)
+#else
+# define machine_is_tricorder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX28
+# endif
+# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
+#else
+# define machine_is_tx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSTBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSTBRD
+# endif
+# define machine_is_bstbrd()	(machine_arch_type == MACH_TYPE_BSTBRD)
+#else
+# define machine_is_bstbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PWB3090
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PWB3090
+# endif
+# define machine_is_pwb3090()	(machine_arch_type == MACH_TYPE_PWB3090)
+#else
+# define machine_is_pwb3090()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IDEA6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDEA6410
+# endif
+# define machine_is_idea6410()	(machine_arch_type == MACH_TYPE_IDEA6410)
+#else
+# define machine_is_idea6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QBC9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QBC9263
+# endif
+# define machine_is_qbc9263()	(machine_arch_type == MACH_TYPE_QBC9263)
+#else
+# define machine_is_qbc9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORABORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORABORA
+# endif
+# define machine_is_borabora()	(machine_arch_type == MACH_TYPE_BORABORA)
+#else
+# define machine_is_borabora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALDEZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALDEZ
+# endif
+# define machine_is_valdez()	(machine_arch_type == MACH_TYPE_VALDEZ)
+#else
+# define machine_is_valdez()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LS9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LS9G20
+# endif
+# define machine_is_ls9g20()	(machine_arch_type == MACH_TYPE_LS9G20)
+#else
+# define machine_is_ls9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOS_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOS_V1
+# endif
+# define machine_is_mios_v1()	(machine_arch_type == MACH_TYPE_MIOS_V1)
+#else
+# define machine_is_mios_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5PC110_CRESPO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5PC110_CRESPO
+# endif
+# define machine_is_s5pc110_crespo()	(machine_arch_type == MACH_TYPE_S5PC110_CRESPO)
+#else
+# define machine_is_s5pc110_crespo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONTROLTEK9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONTROLTEK9G20
+# endif
+# define machine_is_controltek9g20()	(machine_arch_type == MACH_TYPE_CONTROLTEK9G20)
+#else
+# define machine_is_controltek9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIN307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIN307
+# endif
+# define machine_is_tin307()	(machine_arch_type == MACH_TYPE_TIN307)
+#else
+# define machine_is_tin307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIN510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIN510
+# endif
+# define machine_is_tin510()	(machine_arch_type == MACH_TYPE_TIN510)
+#else
+# define machine_is_tin510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUECHEESE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUECHEESE
+# endif
+# define machine_is_bluecheese()	(machine_arch_type == MACH_TYPE_BLUECHEESE)
+#else
+# define machine_is_bluecheese()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEM3X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEM3X30
+# endif
+# define machine_is_tem3x30()	(machine_arch_type == MACH_TYPE_TEM3X30)
+#else
+# define machine_is_tem3x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARVEST_DESOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARVEST_DESOTO
+# endif
+# define machine_is_harvest_desoto()	(machine_arch_type == MACH_TYPE_HARVEST_DESOTO)
+#else
+# define machine_is_harvest_desoto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QRDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QRDC
+# endif
+# define machine_is_msm8x60_qrdc()	(machine_arch_type == MACH_TYPE_MSM8X60_QRDC)
+#else
+# define machine_is_msm8x60_qrdc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR900
+# endif
+# define machine_is_spear900()	(machine_arch_type == MACH_TYPE_SPEAR900)
+#else
+# define machine_is_spear900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCONTROL_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
+# endif
+# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
+#else
+# define machine_is_pcontrol_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RDSTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RDSTOR
+# endif
+# define machine_is_rdstor()	(machine_arch_type == MACH_TYPE_RDSTOR)
+#else
+# define machine_is_rdstor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USDLOADER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USDLOADER
+# endif
+# define machine_is_usdloader()	(machine_arch_type == MACH_TYPE_USDLOADER)
+#else
+# define machine_is_usdloader()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSOPLOADER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSOPLOADER
+# endif
+# define machine_is_tsoploader()	(machine_arch_type == MACH_TYPE_TSOPLOADER)
+#else
+# define machine_is_tsoploader()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRONOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRONOS
+# endif
+# define machine_is_kronos()	(machine_arch_type == MACH_TYPE_KRONOS)
+#else
+# define machine_is_kronos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FFCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FFCORE
+# endif
+# define machine_is_ffcore()	(machine_arch_type == MACH_TYPE_FFCORE)
+#else
+# define machine_is_ffcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONE
+# endif
+# define machine_is_mone()	(machine_arch_type == MACH_TYPE_MONE)
+#else
+# define machine_is_mone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIT2S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIT2S
+# endif
+# define machine_is_unit2s()	(machine_arch_type == MACH_TYPE_UNIT2S)
+#else
+# define machine_is_unit2s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A5
+# endif
+# define machine_is_acer_a5()	(machine_arch_type == MACH_TYPE_ACER_A5)
+#else
+# define machine_is_acer_a5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERPRO_ISP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERPRO_ISP
+# endif
+# define machine_is_etherpro_isp()	(machine_arch_type == MACH_TYPE_ETHERPRO_ISP)
+#else
+# define machine_is_etherpro_isp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRETCHS7000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRETCHS7000
+# endif
+# define machine_is_stretchs7000()	(machine_arch_type == MACH_TYPE_STRETCHS7000)
+#else
+# define machine_is_stretchs7000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P87_SMARTSIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P87_SMARTSIM
+# endif
+# define machine_is_p87_smartsim()	(machine_arch_type == MACH_TYPE_P87_SMARTSIM)
+#else
+# define machine_is_p87_smartsim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TULIP
+# endif
+# define machine_is_tulip()	(machine_arch_type == MACH_TYPE_TULIP)
+#else
+# define machine_is_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNFLOWER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNFLOWER
+# endif
+# define machine_is_sunflower()	(machine_arch_type == MACH_TYPE_SUNFLOWER)
+#else
+# define machine_is_sunflower()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIB
+# endif
+# define machine_is_rib()	(machine_arch_type == MACH_TYPE_RIB)
+#else
+# define machine_is_rib()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLOD
+# endif
+# define machine_is_clod()	(machine_arch_type == MACH_TYPE_CLOD)
+#else
+# define machine_is_clod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUMP
+# endif
+# define machine_is_rump()	(machine_arch_type == MACH_TYPE_RUMP)
+#else
+# define machine_is_rump()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENDERLOIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENDERLOIN
+# endif
+# define machine_is_tenderloin()	(machine_arch_type == MACH_TYPE_TENDERLOIN)
+#else
+# define machine_is_tenderloin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHORTLOIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHORTLOIN
+# endif
+# define machine_is_shortloin()	(machine_arch_type == MACH_TYPE_SHORTLOIN)
+#else
+# define machine_is_shortloin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANTARES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANTARES
+# endif
+# define machine_is_antares()	(machine_arch_type == MACH_TYPE_ANTARES)
+#else
+# define machine_is_antares()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WB40N
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WB40N
+# endif
+# define machine_is_wb40n()	(machine_arch_type == MACH_TYPE_WB40N)
+#else
+# define machine_is_wb40n()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERRING
+# endif
+# define machine_is_herring()	(machine_arch_type == MACH_TYPE_HERRING)
+#else
+# define machine_is_herring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY400
+# endif
+# define machine_is_naxy400()	(machine_arch_type == MACH_TYPE_NAXY400)
+#else
+# define machine_is_naxy400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY1200
+# endif
+# define machine_is_naxy1200()	(machine_arch_type == MACH_TYPE_NAXY1200)
+#else
+# define machine_is_naxy1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPR200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPR200
+# endif
+# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
+#else
+# define machine_is_vpr200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG20
+# endif
+# define machine_is_bug20()	(machine_arch_type == MACH_TYPE_BUG20)
+#else
+# define machine_is_bug20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXNET
+# endif
+# define machine_is_goflexnet()	(machine_arch_type == MACH_TYPE_GOFLEXNET)
+#else
+# define machine_is_goflexnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORBRECK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORBRECK
+# endif
+# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
+#else
+# define machine_is_torbreck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB_MG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB_MG1
+# endif
+# define machine_is_saarb_mg1()	(machine_arch_type == MACH_TYPE_SAARB_MG1)
+#else
+# define machine_is_saarb_mg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CALLISTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CALLISTO
+# endif
+# define machine_is_callisto()	(machine_arch_type == MACH_TYPE_CALLISTO)
+#else
+# define machine_is_callisto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTHSU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTHSU
+# endif
+# define machine_is_multhsu()	(machine_arch_type == MACH_TYPE_MULTHSU)
+#else
+# define machine_is_multhsu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALUDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALUDA
+# endif
+# define machine_is_saluda()	(machine_arch_type == MACH_TYPE_SALUDA)
+#else
+# define machine_is_saluda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEMP_OMAP3_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEMP_OMAP3_APOLLO
+# endif
+# define machine_is_pemp_omap3_apollo()	(machine_arch_type == MACH_TYPE_PEMP_OMAP3_APOLLO)
+#else
+# define machine_is_pemp_omap3_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0718
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0718
+# endif
+# define machine_is_vc0718()	(machine_arch_type == MACH_TYPE_VC0718)
+#else
+# define machine_is_vc0718()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MVBLX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVBLX
+# endif
+# define machine_is_mvblx()	(machine_arch_type == MACH_TYPE_MVBLX)
+#else
+# define machine_is_mvblx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_APEIRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_APEIRON
+# endif
+# define machine_is_inhand_apeiron()	(machine_arch_type == MACH_TYPE_INHAND_APEIRON)
+#else
+# define machine_is_inhand_apeiron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_FURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_FURY
+# endif
+# define machine_is_inhand_fury()	(machine_arch_type == MACH_TYPE_INHAND_FURY)
+#else
+# define machine_is_inhand_fury()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_SIREN
+# endif
+# define machine_is_inhand_siren()	(machine_arch_type == MACH_TYPE_INHAND_SIREN)
+#else
+# define machine_is_inhand_siren()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDNVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDNVP
+# endif
+# define machine_is_hdnvp()	(machine_arch_type == MACH_TYPE_HDNVP)
+#else
+# define machine_is_hdnvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOFTWINNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOFTWINNER
+# endif
+# define machine_is_softwinner()	(machine_arch_type == MACH_TYPE_SOFTWINNER)
+#else
+# define machine_is_softwinner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA2_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
+# endif
+# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
+#else
+# define machine_is_prima2_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS6210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS6210
+# endif
+# define machine_is_nas6210()	(machine_arch_type == MACH_TYPE_NAS6210)
+#else
+# define machine_is_nas6210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNISDEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNISDEV
+# endif
+# define machine_is_unisdev()	(machine_arch_type == MACH_TYPE_UNISDEV)
+#else
+# define machine_is_unisdev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBCA11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCA11
+# endif
+# define machine_is_sbca11()	(machine_arch_type == MACH_TYPE_SBCA11)
+#else
+# define machine_is_sbca11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAGA
+# endif
+# define machine_is_saga()	(machine_arch_type == MACH_TYPE_SAGA)
+#else
+# define machine_is_saga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS_K330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS_K330
+# endif
+# define machine_is_ns_k330()	(machine_arch_type == MACH_TYPE_NS_K330)
+#else
+# define machine_is_ns_k330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TANNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TANNA
+# endif
+# define machine_is_tanna()	(machine_arch_type == MACH_TYPE_TANNA)
+#else
+# define machine_is_tanna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMATE8502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMATE8502
+# endif
+# define machine_is_imate8502()	(machine_arch_type == MACH_TYPE_IMATE8502)
+#else
+# define machine_is_imate8502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPEN
+# endif
+# define machine_is_aspen()	(machine_arch_type == MACH_TYPE_ASPEN)
+#else
+# define machine_is_aspen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAINTREE_CWAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAINTREE_CWAC
+# endif
+# define machine_is_daintree_cwac()	(machine_arch_type == MACH_TYPE_DAINTREE_CWAC)
+#else
+# define machine_is_daintree_cwac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZMX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZMX25
+# endif
+# define machine_is_zmx25()	(machine_arch_type == MACH_TYPE_ZMX25)
+#else
+# define machine_is_zmx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAPLE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAPLE1
+# endif
+# define machine_is_maple1()	(machine_arch_type == MACH_TYPE_MAPLE1)
+#else
+# define machine_is_maple1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X72_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X72_SURF
+# endif
+# define machine_is_qsd8x72_surf()	(machine_arch_type == MACH_TYPE_QSD8X72_SURF)
+#else
+# define machine_is_qsd8x72_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X72_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X72_FFA
+# endif
+# define machine_is_qsd8x72_ffa()	(machine_arch_type == MACH_TYPE_QSD8X72_FFA)
+#else
+# define machine_is_qsd8x72_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABILENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABILENE
+# endif
+# define machine_is_abilene()	(machine_arch_type == MACH_TYPE_ABILENE)
+#else
+# define machine_is_abilene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIGEN_TTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIGEN_TTR
+# endif
+# define machine_is_eigen_ttr()	(machine_arch_type == MACH_TYPE_EIGEN_TTR)
+#else
+# define machine_is_eigen_ttr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IOMEGA_IX2_200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IOMEGA_IX2_200
+# endif
+# define machine_is_iomega_ix2_200()	(machine_arch_type == MACH_TYPE_IOMEGA_IX2_200)
+#else
+# define machine_is_iomega_ix2_200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORETEC_VCX7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORETEC_VCX7400
+# endif
+# define machine_is_coretec_vcx7400()	(machine_arch_type == MACH_TYPE_CORETEC_VCX7400)
+#else
+# define machine_is_coretec_vcx7400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANTIAGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANTIAGO
+# endif
+# define machine_is_santiago()	(machine_arch_type == MACH_TYPE_SANTIAGO)
+#else
+# define machine_is_santiago()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SOL
+# endif
+# define machine_is_mx257sol()	(machine_arch_type == MACH_TYPE_MX257SOL)
+#else
+# define machine_is_mx257sol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRASBOURG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRASBOURG
+# endif
+# define machine_is_strasbourg()	(machine_arch_type == MACH_TYPE_STRASBOURG)
+#else
+# define machine_is_strasbourg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FLUID
+# endif
+# define machine_is_msm8x60_fluid()	(machine_arch_type == MACH_TYPE_MSM8X60_FLUID)
+#else
+# define machine_is_msm8x60_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV5
+# endif
+# define machine_is_smartqv5()	(machine_arch_type == MACH_TYPE_SMARTQV5)
+#else
+# define machine_is_smartqv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV3
+# endif
+# define machine_is_smartqv3()	(machine_arch_type == MACH_TYPE_SMARTQV3)
+#else
+# define machine_is_smartqv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV7
+# endif
+# define machine_is_smartqv7()	(machine_arch_type == MACH_TYPE_SMARTQV7)
+#else
+# define machine_is_smartqv7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PAZ00
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PAZ00
+# endif
+# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
+#else
+# define machine_is_paz00()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMENETUSFOXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
+# endif
+# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
+#else
+# define machine_is_acmenetusfoxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_0404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_0404
+# endif
+# define machine_is_fwbd_0404()	(machine_arch_type == MACH_TYPE_FWBD_0404)
+#else
+# define machine_is_fwbd_0404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDGU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDGU
+# endif
+# define machine_is_hdgu()	(machine_arch_type == MACH_TYPE_HDGU)
+#else
+# define machine_is_hdgu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PYRAMID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PYRAMID
+# endif
+# define machine_is_pyramid()	(machine_arch_type == MACH_TYPE_PYRAMID)
+#else
+# define machine_is_pyramid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPIPHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPIPHAN
+# endif
+# define machine_is_epiphan()	(machine_arch_type == MACH_TYPE_EPIPHAN)
+#else
+# define machine_is_epiphan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_BENDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_BENDER
+# endif
+# define machine_is_omap_bender()	(machine_arch_type == MACH_TYPE_OMAP_BENDER)
+#else
+# define machine_is_omap_bender()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNARD
+# endif
+# define machine_is_gurnard()	(machine_arch_type == MACH_TYPE_GURNARD)
+#else
+# define machine_is_gurnard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTL_IT5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTL_IT5100
+# endif
+# define machine_is_gtl_it5100()	(machine_arch_type == MACH_TYPE_GTL_IT5100)
+#else
+# define machine_is_gtl_it5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM2708
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM2708
+# endif
+# define machine_is_bcm2708()	(machine_arch_type == MACH_TYPE_BCM2708)
+#else
+# define machine_is_bcm2708()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_GGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_GGC
+# endif
+# define machine_is_mx51_ggc()	(machine_arch_type == MACH_TYPE_MX51_GGC)
+#else
+# define machine_is_mx51_ggc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHARESPACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARESPACE
+# endif
+# define machine_is_sharespace()	(machine_arch_type == MACH_TYPE_SHARESPACE)
+#else
+# define machine_is_sharespace()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HABA_KNX_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HABA_KNX_EXPLORER
+# endif
+# define machine_is_haba_knx_explorer()	(machine_arch_type == MACH_TYPE_HABA_KNX_EXPLORER)
+#else
+# define machine_is_haba_knx_explorer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMTEC_KIRKMOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMTEC_KIRKMOD
+# endif
+# define machine_is_simtec_kirkmod()	(machine_arch_type == MACH_TYPE_SIMTEC_KIRKMOD)
+#else
+# define machine_is_simtec_kirkmod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRUX
+# endif
+# define machine_is_crux()	(machine_arch_type == MACH_TYPE_CRUX)
+#else
+# define machine_is_crux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BRAVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BRAVO
+# endif
+# define machine_is_mx51_bravo()	(machine_arch_type == MACH_TYPE_MX51_BRAVO)
+#else
+# define machine_is_mx51_bravo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHARON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHARON
+# endif
+# define machine_is_charon()	(machine_arch_type == MACH_TYPE_CHARON)
+#else
+# define machine_is_charon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM3
+# endif
+# define machine_is_picocom3()	(machine_arch_type == MACH_TYPE_PICOCOM3)
+#else
+# define machine_is_picocom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM4
+# endif
+# define machine_is_picocom4()	(machine_arch_type == MACH_TYPE_PICOCOM4)
+#else
+# define machine_is_picocom4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SERRANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SERRANO
+# endif
+# define machine_is_serrano()	(machine_arch_type == MACH_TYPE_SERRANO)
+#else
+# define machine_is_serrano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOUBLESHOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOUBLESHOT
+# endif
+# define machine_is_doubleshot()	(machine_arch_type == MACH_TYPE_DOUBLESHOT)
+#else
+# define machine_is_doubleshot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVSY
+# endif
+# define machine_is_evsy()	(machine_arch_type == MACH_TYPE_EVSY)
+#else
+# define machine_is_evsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUASHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUASHAN
+# endif
+# define machine_is_huashan()	(machine_arch_type == MACH_TYPE_HUASHAN)
+#else
+# define machine_is_huashan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAUSANNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAUSANNE
+# endif
+# define machine_is_lausanne()	(machine_arch_type == MACH_TYPE_LAUSANNE)
+#else
+# define machine_is_lausanne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMERALD
+# endif
+# define machine_is_emerald()	(machine_arch_type == MACH_TYPE_EMERALD)
+#else
+# define machine_is_emerald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA35
+# endif
+# define machine_is_tqma35()	(machine_arch_type == MACH_TYPE_TQMA35)
+#else
+# define machine_is_tqma35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVEL
+# endif
+# define machine_is_marvel()	(machine_arch_type == MACH_TYPE_MARVEL)
+#else
+# define machine_is_marvel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANUAE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANUAE
+# endif
+# define machine_is_manuae()	(machine_arch_type == MACH_TYPE_MANUAE)
+#else
+# define machine_is_manuae()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHACHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHACHA
+# endif
+# define machine_is_chacha()	(machine_arch_type == MACH_TYPE_CHACHA)
+#else
+# define machine_is_chacha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEMON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEMON
+# endif
+# define machine_is_lemon()	(machine_arch_type == MACH_TYPE_LEMON)
+#else
+# define machine_is_lemon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSC
+# endif
+# define machine_is_csc()	(machine_arch_type == MACH_TYPE_CSC)
+#else
+# define machine_is_csc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GIRA_KNXIP_ROUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GIRA_KNXIP_ROUTER
+# endif
+# define machine_is_gira_knxip_router()	(machine_arch_type == MACH_TYPE_GIRA_KNXIP_ROUTER)
+#else
+# define machine_is_gira_knxip_router()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T20
+# endif
+# define machine_is_t20()	(machine_arch_type == MACH_TYPE_T20)
+#else
+# define machine_is_t20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDMINI
+# endif
+# define machine_is_hdmini()	(machine_arch_type == MACH_TYPE_HDMINI)
+#else
+# define machine_is_hdmini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCIPHONE_G2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCIPHONE_G2
+# endif
+# define machine_is_sciphone_g2()	(machine_arch_type == MACH_TYPE_SCIPHONE_G2)
+#else
+# define machine_is_sciphone_g2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESS
+# endif
+# define machine_is_express()	(machine_arch_type == MACH_TYPE_EXPRESS)
+#else
+# define machine_is_express()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESS_KT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESS_KT
+# endif
+# define machine_is_express_kt()	(machine_arch_type == MACH_TYPE_EXPRESS_KT)
+#else
+# define machine_is_express_kt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAXIMASP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAXIMASP
+# endif
+# define machine_is_maximasp()	(machine_arch_type == MACH_TYPE_MAXIMASP)
+#else
+# define machine_is_maximasp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_IMX51
+# endif
+# define machine_is_nitrogen_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_IMX51)
+#else
+# define machine_is_nitrogen_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_IMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_IMX53
+# endif
+# define machine_is_nitrogen_imx53()	(machine_arch_type == MACH_TYPE_NITROGEN_IMX53)
+#else
+# define machine_is_nitrogen_imx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNFIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNFIRE
+# endif
+# define machine_is_sunfire()	(machine_arch_type == MACH_TYPE_SUNFIRE)
+#else
+# define machine_is_sunfire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AROWANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AROWANA
+# endif
+# define machine_is_arowana()	(machine_arch_type == MACH_TYPE_AROWANA)
+#else
+# define machine_is_arowana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_DAYTONA
+# endif
+# define machine_is_tegra_daytona()	(machine_arch_type == MACH_TYPE_TEGRA_DAYTONA)
+#else
+# define machine_is_tegra_daytona()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_SWORDFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_SWORDFISH
+# endif
+# define machine_is_tegra_swordfish()	(machine_arch_type == MACH_TYPE_TEGRA_SWORDFISH)
+#else
+# define machine_is_tegra_swordfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDISON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDISON
+# endif
+# define machine_is_edison()	(machine_arch_type == MACH_TYPE_EDISON)
+#else
+# define machine_is_edison()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP8500V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP8500V1
+# endif
+# define machine_is_svp8500v1()	(machine_arch_type == MACH_TYPE_SVP8500V1)
+#else
+# define machine_is_svp8500v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP8500V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP8500V2
+# endif
+# define machine_is_svp8500v2()	(machine_arch_type == MACH_TYPE_SVP8500V2)
+#else
+# define machine_is_svp8500v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP5500
+# endif
+# define machine_is_svp5500()	(machine_arch_type == MACH_TYPE_SVP5500)
+#else
+# define machine_is_svp5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B5500
+# endif
+# define machine_is_b5500()	(machine_arch_type == MACH_TYPE_B5500)
+#else
+# define machine_is_b5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5500
+# endif
+# define machine_is_s5500()	(machine_arch_type == MACH_TYPE_S5500)
+#else
+# define machine_is_s5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON
+# endif
+# define machine_is_icon()	(machine_arch_type == MACH_TYPE_ICON)
+#else
+# define machine_is_icon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELEPHANT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELEPHANT
+# endif
+# define machine_is_elephant()	(machine_arch_type == MACH_TYPE_ELEPHANT)
+#else
+# define machine_is_elephant()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER
+# endif
+# define machine_is_shooter()	(machine_arch_type == MACH_TYPE_SHOOTER)
+#else
+# define machine_is_shooter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPADE_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPADE_LTE
+# endif
+# define machine_is_spade_lte()	(machine_arch_type == MACH_TYPE_SPADE_LTE)
+#else
+# define machine_is_spade_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHILHWANI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHILHWANI
+# endif
+# define machine_is_philhwani()	(machine_arch_type == MACH_TYPE_PHILHWANI)
+#else
+# define machine_is_philhwani()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSNCOMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSNCOMM
+# endif
+# define machine_is_gsncomm()	(machine_arch_type == MACH_TYPE_GSNCOMM)
+#else
+# define machine_is_gsncomm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRASBOURG_A2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRASBOURG_A2
+# endif
+# define machine_is_strasbourg_a2()	(machine_arch_type == MACH_TYPE_STRASBOURG_A2)
+#else
+# define machine_is_strasbourg_a2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMM
+# endif
+# define machine_is_mmm()	(machine_arch_type == MACH_TYPE_MMM)
+#else
+# define machine_is_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_BV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_BV
+# endif
+# define machine_is_davinci_dm365_bv()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_BV)
+#else
+# define machine_is_davinci_dm365_bv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG5EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG5EVM
+# endif
+# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
+#else
+# define machine_is_ag5evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC575PLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC575PLC
+# endif
+# define machine_is_sc575plc()	(machine_arch_type == MACH_TYPE_SC575PLC)
+#else
+# define machine_is_sc575plc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC575IPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC575IPC
+# endif
+# define machine_is_sc575hmi()	(machine_arch_type == MACH_TYPE_SC575IPC)
+#else
+# define machine_is_sc575hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TDM3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TDM3730
+# endif
+# define machine_is_omap3_tdm3730()	(machine_arch_type == MACH_TYPE_OMAP3_TDM3730)
+#else
+# define machine_is_omap3_tdm3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_EVAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_EVAL
+# endif
+# define machine_is_top9000_eval()	(machine_arch_type == MACH_TYPE_TOP9000_EVAL)
+#else
+# define machine_is_top9000_eval()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_SU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_SU
+# endif
+# define machine_is_top9000_su()	(machine_arch_type == MACH_TYPE_TOP9000_SU)
+#else
+# define machine_is_top9000_su()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UTM300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UTM300
+# endif
+# define machine_is_utm300()	(machine_arch_type == MACH_TYPE_UTM300)
+#else
+# define machine_is_utm300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSUNAGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSUNAGI
+# endif
+# define machine_is_tsunagi()	(machine_arch_type == MACH_TYPE_TSUNAGI)
+#else
+# define machine_is_tsunagi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS75XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS75XX
+# endif
+# define machine_is_ts75xx()	(machine_arch_type == MACH_TYPE_TS75XX)
+#else
+# define machine_is_ts75xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS47XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS47XX
+# endif
+# define machine_is_ts47xx()	(machine_arch_type == MACH_TYPE_TS47XX)
+#else
+# define machine_is_ts47xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DA850_K5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DA850_K5
+# endif
+# define machine_is_da850_k5()	(machine_arch_type == MACH_TYPE_DA850_K5)
+#else
+# define machine_is_da850_k5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX502
+# endif
+# define machine_is_ax502()	(machine_arch_type == MACH_TYPE_AX502)
+#else
+# define machine_is_ax502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0032
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0032
+# endif
+# define machine_is_igep0032()	(machine_arch_type == MACH_TYPE_IGEP0032)
+#else
+# define machine_is_igep0032()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANTERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANTERO
+# endif
+# define machine_is_antero()	(machine_arch_type == MACH_TYPE_ANTERO)
+#else
+# define machine_is_antero()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYNERGY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYNERGY
+# endif
+# define machine_is_synergy()	(machine_arch_type == MACH_TYPE_SYNERGY)
+#else
+# define machine_is_synergy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICS_IF_VOIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
+# endif
+# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
+#else
+# define machine_is_ics_if_voip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLF_CRAGG_6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
+# endif
+# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
+#else
+# define machine_is_wlf_cragg_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUNICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUNICA
+# endif
+# define machine_is_punica()	(machine_arch_type == MACH_TYPE_PUNICA)
+#else
+# define machine_is_punica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIMSLICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIMSLICE
+# endif
+# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
+#else
+# define machine_is_trimslice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_WMULTRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_WMULTRA
+# endif
+# define machine_is_mx27_wmultra()	(machine_arch_type == MACH_TYPE_MX27_WMULTRA)
+#else
+# define machine_is_mx27_wmultra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACKEREL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACKEREL
+# endif
+# define machine_is_mackerel()	(machine_arch_type == MACH_TYPE_MACKEREL)
+#else
+# define machine_is_mackerel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FA9X27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FA9X27
+# endif
+# define machine_is_fa9x27()	(machine_arch_type == MACH_TYPE_FA9X27)
+#else
+# define machine_is_fa9x27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816TB
+# endif
+# define machine_is_ns2816tb()	(machine_arch_type == MACH_TYPE_NS2816TB)
+#else
+# define machine_is_ns2816tb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_NTPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_NTPAD
+# endif
+# define machine_is_ns2816_ntpad()	(machine_arch_type == MACH_TYPE_NS2816_NTPAD)
+#else
+# define machine_is_ns2816_ntpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_NTNB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_NTNB
+# endif
+# define machine_is_ns2816_ntnb()	(machine_arch_type == MACH_TYPE_NS2816_NTNB)
+#else
+# define machine_is_ns2816_ntnb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAEN
+# endif
+# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
+#else
+# define machine_is_kaen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NV1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NV1000
+# endif
+# define machine_is_nv1000()	(machine_arch_type == MACH_TYPE_NV1000)
+#else
+# define machine_is_nv1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC950TS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC950TS
+# endif
+# define machine_is_nuc950ts()	(machine_arch_type == MACH_TYPE_NUC950TS)
+#else
+# define machine_is_nuc950ts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
+# endif
+# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
+#else
+# define machine_is_nokia_rm680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2200
+# endif
+# define machine_is_ast2200()	(machine_arch_type == MACH_TYPE_AST2200)
+#else
+# define machine_is_ast2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAD
+# endif
+# define machine_is_lead()	(machine_arch_type == MACH_TYPE_LEAD)
+#else
+# define machine_is_lead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNINO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNINO1
+# endif
+# define machine_is_unino1()	(machine_arch_type == MACH_TYPE_UNINO1)
+#else
+# define machine_is_unino1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GREECO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREECO
+# endif
+# define machine_is_greeco()	(machine_arch_type == MACH_TYPE_GREECO)
+#else
+# define machine_is_greeco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI
+# endif
+# define machine_is_verdi()	(machine_arch_type == MACH_TYPE_VERDI)
+#else
+# define machine_is_verdi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6446_ADBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6446_ADBOX
+# endif
+# define machine_is_dm6446_adbox()	(machine_arch_type == MACH_TYPE_DM6446_ADBOX)
+#else
+# define machine_is_dm6446_adbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUAD_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUAD_SALSA
+# endif
+# define machine_is_quad_salsa()	(machine_arch_type == MACH_TYPE_QUAD_SALSA)
+#else
+# define machine_is_quad_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABB_GMA_1_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABB_GMA_1_1
+# endif
+# define machine_is_abb_gma_1_1()	(machine_arch_type == MACH_TYPE_ABB_GMA_1_1)
+#else
+# define machine_is_abb_gma_1_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVCID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVCID
+# endif
+# define machine_is_svcid()	(machine_arch_type == MACH_TYPE_SVCID)
+#else
+# define machine_is_svcid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
+# endif
+# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
+#else
+# define machine_is_msm8960_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
+# endif
+# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
+#else
+# define machine_is_msm8960_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON_G
+# endif
+# define machine_is_icon_g()	(machine_arch_type == MACH_TYPE_ICON_G)
+#else
+# define machine_is_icon_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB3
+# endif
+# define machine_is_mb3()	(machine_arch_type == MACH_TYPE_MB3)
+#else
+# define machine_is_mb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSIA18S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSIA18S
+# endif
+# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
+#else
+# define machine_is_gsia18s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIVICC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIVICC
+# endif
+# define machine_is_pivicc()	(machine_arch_type == MACH_TYPE_PIVICC)
+#else
+# define machine_is_pivicc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM048
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM048
+# endif
+# define machine_is_pcm048()	(machine_arch_type == MACH_TYPE_PCM048)
+#else
+# define machine_is_pcm048()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDS
+# endif
+# define machine_is_dds()	(machine_arch_type == MACH_TYPE_DDS)
+#else
+# define machine_is_dds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHALTEN_XA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHALTEN_XA1
+# endif
+# define machine_is_chalten_xa1()	(machine_arch_type == MACH_TYPE_CHALTEN_XA1)
+#else
+# define machine_is_chalten_xa1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS48XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS48XX
+# endif
+# define machine_is_ts48xx()	(machine_arch_type == MACH_TYPE_TS48XX)
+#else
+# define machine_is_ts48xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TONGA2_TFTTIMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TONGA2_TFTTIMER
+# endif
+# define machine_is_tonga2_tfttimer()	(machine_arch_type == MACH_TYPE_TONGA2_TFTTIMER)
+#else
+# define machine_is_tonga2_tfttimer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHISTLER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHISTLER
+# endif
+# define machine_is_whistler()	(machine_arch_type == MACH_TYPE_WHISTLER)
+#else
+# define machine_is_whistler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASL_PHOENIX
+# endif
+# define machine_is_asl_phoenix()	(machine_arch_type == MACH_TYPE_ASL_PHOENIX)
+#else
+# define machine_is_asl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263OTLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263OTLITE
+# endif
+# define machine_is_at91sam9263otlite()	(machine_arch_type == MACH_TYPE_AT91SAM9263OTLITE)
+#else
+# define machine_is_at91sam9263otlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDPLUG
+# endif
+# define machine_is_ddplug()	(machine_arch_type == MACH_TYPE_DDPLUG)
+#else
+# define machine_is_ddplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2PLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2PLUG
+# endif
+# define machine_is_d2plug()	(machine_arch_type == MACH_TYPE_D2PLUG)
+#else
+# define machine_is_d2plug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM9D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM9D
+# endif
+# define machine_is_kzm9d()	(machine_arch_type == MACH_TYPE_KZM9D)
+#else
+# define machine_is_kzm9d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI_LTE
+# endif
+# define machine_is_verdi_lte()	(machine_arch_type == MACH_TYPE_VERDI_LTE)
+#else
+# define machine_is_verdi_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOZOOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOZOOM
+# endif
+# define machine_is_nanozoom()	(machine_arch_type == MACH_TYPE_NANOZOOM)
+#else
+# define machine_is_nanozoom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_SOM_LV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_SOM_LV
+# endif
+# define machine_is_dm3730_som_lv()	(machine_arch_type == MACH_TYPE_DM3730_SOM_LV)
+#else
+# define machine_is_dm3730_som_lv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_TORPEDO
+# endif
+# define machine_is_dm3730_torpedo()	(machine_arch_type == MACH_TYPE_DM3730_TORPEDO)
+#else
+# define machine_is_dm3730_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANCHOVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANCHOVY
+# endif
+# define machine_is_anchovy()	(machine_arch_type == MACH_TYPE_ANCHOVY)
+#else
+# define machine_is_anchovy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV20
+# endif
+# define machine_is_re2rev20()	(machine_arch_type == MACH_TYPE_RE2REV20)
+#else
+# define machine_is_re2rev20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV21
+# endif
+# define machine_is_re2rev21()	(machine_arch_type == MACH_TYPE_RE2REV21)
+#else
+# define machine_is_re2rev21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS21XX
+# endif
+# define machine_is_cns21xx()	(machine_arch_type == MACH_TYPE_CNS21XX)
+#else
+# define machine_is_cns21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIDER
+# endif
+# define machine_is_rider()	(machine_arch_type == MACH_TYPE_RIDER)
+#else
+# define machine_is_rider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSK330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSK330
+# endif
+# define machine_is_nsk330()	(machine_arch_type == MACH_TYPE_NSK330)
+#else
+# define machine_is_nsk330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS2133EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS2133EVB
+# endif
+# define machine_is_cns2133evb()	(machine_arch_type == MACH_TYPE_CNS2133EVB)
+#else
+# define machine_is_cns2133evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_816X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_816X_MOD
+# endif
+# define machine_is_z3_816x_mod()	(machine_arch_type == MACH_TYPE_Z3_816X_MOD)
+#else
+# define machine_is_z3_816x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_814X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_814X_MOD
+# endif
+# define machine_is_z3_814x_mod()	(machine_arch_type == MACH_TYPE_Z3_814X_MOD)
+#else
+# define machine_is_z3_814x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEECT
+# endif
+# define machine_is_beect()	(machine_arch_type == MACH_TYPE_BEECT)
+#else
+# define machine_is_beect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA_THUNDERBUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA_THUNDERBUG
+# endif
+# define machine_is_dma_thunderbug()	(machine_arch_type == MACH_TYPE_DMA_THUNDERBUG)
+#else
+# define machine_is_dma_thunderbug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMN_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMN_AT91SAM9G20
+# endif
+# define machine_is_omn_at91sam9g20()	(machine_arch_type == MACH_TYPE_OMN_AT91SAM9G20)
+#else
+# define machine_is_omn_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_E2S_UC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_E2S_UC
+# endif
+# define machine_is_mx25_e2s_uc()	(machine_arch_type == MACH_TYPE_MX25_E2S_UC)
+#else
+# define machine_is_mx25_e2s_uc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIONE
+# endif
+# define machine_is_mione()	(machine_arch_type == MACH_TYPE_MIONE)
+#else
+# define machine_is_mione()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_TCU
+# endif
+# define machine_is_top9000_tcu()	(machine_arch_type == MACH_TYPE_TOP9000_TCU)
+#else
+# define machine_is_top9000_tcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_BSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_BSL
+# endif
+# define machine_is_top9000_bsl()	(machine_arch_type == MACH_TYPE_TOP9000_BSL)
+#else
+# define machine_is_top9000_bsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KINGDOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGDOM
+# endif
+# define machine_is_kingdom()	(machine_arch_type == MACH_TYPE_KINGDOM)
+#else
+# define machine_is_kingdom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO460
+# endif
+# define machine_is_armadillo460()	(machine_arch_type == MACH_TYPE_ARMADILLO460)
+#else
+# define machine_is_armadillo460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LQ2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LQ2
+# endif
+# define machine_is_lq2()	(machine_arch_type == MACH_TYPE_LQ2)
+#else
+# define machine_is_lq2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDA_TMS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDA_TMS2
+# endif
+# define machine_is_sweda_tms2()	(machine_arch_type == MACH_TYPE_SWEDA_TMS2)
+#else
+# define machine_is_sweda_tms2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_LOCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_LOCO
+# endif
+# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
+#else
+# define machine_is_mx53_loco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A8
+# endif
+# define machine_is_acer_a8()	(machine_arch_type == MACH_TYPE_ACER_A8)
+#else
+# define machine_is_acer_a8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_GAUGUIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_GAUGUIN
+# endif
+# define machine_is_acer_gauguin()	(machine_arch_type == MACH_TYPE_ACER_GAUGUIN)
+#else
+# define machine_is_acer_gauguin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUPPY
+# endif
+# define machine_is_guppy()	(machine_arch_type == MACH_TYPE_GUPPY)
+#else
+# define machine_is_guppy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX61_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX61_ARD
+# endif
+# define machine_is_mx61_ard()	(machine_arch_type == MACH_TYPE_MX61_ARD)
+#else
+# define machine_is_mx61_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX53
+# endif
+# define machine_is_tx53()	(machine_arch_type == MACH_TYPE_TX53)
+#else
+# define machine_is_tx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_CASE_A3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_CASE_A3
+# endif
+# define machine_is_omapl138_case_a3()	(machine_arch_type == MACH_TYPE_OMAPL138_CASE_A3)
+#else
+# define machine_is_omapl138_case_a3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEMD
+# endif
+# define machine_is_uemd()	(machine_arch_type == MACH_TYPE_UEMD)
+#else
+# define machine_is_uemd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51MUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51MUT
+# endif
+# define machine_is_ccwmx51mut()	(machine_arch_type == MACH_TYPE_CCWMX51MUT)
+#else
+# define machine_is_ccwmx51mut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROCKHOPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROCKHOPPER
+# endif
+# define machine_is_rockhopper()	(machine_arch_type == MACH_TYPE_ROCKHOPPER)
+#else
+# define machine_is_rockhopper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENCORE
+# endif
+# define machine_is_encore()	(machine_arch_type == MACH_TYPE_ENCORE)
+#else
+# define machine_is_encore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HKDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HKDKC100
+# endif
+# define machine_is_hkdkc100()	(machine_arch_type == MACH_TYPE_HKDKC100)
+#else
+# define machine_is_hkdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS42XX
+# endif
+# define machine_is_ts42xx()	(machine_arch_type == MACH_TYPE_TS42XX)
+#else
+# define machine_is_ts42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AEBL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AEBL
+# endif
+# define machine_is_aebl()	(machine_arch_type == MACH_TYPE_AEBL)
+#else
+# define machine_is_aebl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WARIO
+# endif
+# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
+#else
+# define machine_is_wario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GFS_SPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GFS_SPM
+# endif
+# define machine_is_gfs_spm()	(machine_arch_type == MACH_TYPE_GFS_SPM)
+#else
+# define machine_is_gfs_spm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3730
+# endif
+# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
+#else
+# define machine_is_cm_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISC3
+# endif
+# define machine_is_isc3()	(machine_arch_type == MACH_TYPE_ISC3)
+#else
+# define machine_is_isc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RASCAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RASCAL
+# endif
+# define machine_is_rascal()	(machine_arch_type == MACH_TYPE_RASCAL)
+#else
+# define machine_is_rascal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HREFV60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HREFV60
+# endif
+# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
+#else
+# define machine_is_hrefv60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPT_2_0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPT_2_0
+# endif
+# define machine_is_tpt_2_0()	(machine_arch_type == MACH_TYPE_TPT_2_0)
+#else
+# define machine_is_tpt_2_0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPLENDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPLENDOR
+# endif
+# define machine_is_splendor()	(machine_arch_type == MACH_TYPE_SPLENDOR)
+#else
+# define machine_is_splendor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QT
+# endif
+# define machine_is_msm8x60_qt()	(machine_arch_type == MACH_TYPE_MSM8X60_QT)
+#else
+# define machine_is_msm8x60_qt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_HD_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_HD_MINI
+# endif
+# define machine_is_htc_hd_mini()	(machine_arch_type == MACH_TYPE_HTC_HD_MINI)
+#else
+# define machine_is_htc_hd_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATHENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATHENE
+# endif
+# define machine_is_athene()	(machine_arch_type == MACH_TYPE_ATHENE)
+#else
+# define machine_is_athene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEEP_R_EK_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEEP_R_EK_1
+# endif
+# define machine_is_deep_r_ek_1()	(machine_arch_type == MACH_TYPE_DEEP_R_EK_1)
+#else
+# define machine_is_deep_r_ek_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_CT
+# endif
+# define machine_is_vivow_ct()	(machine_arch_type == MACH_TYPE_VIVOW_CT)
+#else
+# define machine_is_vivow_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NERY_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NERY_1000
+# endif
+# define machine_is_nery_1000()	(machine_arch_type == MACH_TYPE_NERY_1000)
+#else
+# define machine_is_nery_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL109145_SSRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL109145_SSRV
+# endif
+# define machine_is_rfl109145_ssrv()	(machine_arch_type == MACH_TYPE_RFL109145_SSRV)
+#else
+# define machine_is_rfl109145_ssrv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NMH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMH
+# endif
+# define machine_is_nmh()	(machine_arch_type == MACH_TYPE_NMH)
+#else
+# define machine_is_nmh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WN802T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WN802T
+# endif
+# define machine_is_wn802t()	(machine_arch_type == MACH_TYPE_WN802T)
+#else
+# define machine_is_wn802t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGONET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGONET
+# endif
+# define machine_is_dragonet()	(machine_arch_type == MACH_TYPE_DRAGONET)
+#else
+# define machine_is_dragonet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263DESK16L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESK16L
+# endif
+# define machine_is_at91sam9263desk16l()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESK16L)
+#else
+# define machine_is_at91sam9263desk16l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_SV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_SV
+# endif
+# define machine_is_bcmhana_sv()	(machine_arch_type == MACH_TYPE_BCMHANA_SV)
+#else
+# define machine_is_bcmhana_sv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_TABLET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_TABLET
+# endif
+# define machine_is_bcmhana_tablet()	(machine_arch_type == MACH_TYPE_BCMHANA_TABLET)
+#else
+# define machine_is_bcmhana_tablet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOI
+# endif
+# define machine_is_koi()	(machine_arch_type == MACH_TYPE_KOI)
+#else
+# define machine_is_koi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS4800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS4800
+# endif
+# define machine_is_ts4800()	(machine_arch_type == MACH_TYPE_TS4800)
+#else
+# define machine_is_ts4800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA9263
+# endif
+# define machine_is_tqma9263()	(machine_arch_type == MACH_TYPE_TQMA9263)
+#else
+# define machine_is_tqma9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOLIDAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOLIDAY
+# endif
+# define machine_is_holiday()	(machine_arch_type == MACH_TYPE_HOLIDAY)
+#else
+# define machine_is_holiday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA6410
+# endif
+# define machine_is_dma_6410()	(machine_arch_type == MACH_TYPE_DMA6410)
+#else
+# define machine_is_dma_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCATS_OVERLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCATS_OVERLAY
+# endif
+# define machine_is_pcats_overlay()	(machine_arch_type == MACH_TYPE_PCATS_OVERLAY)
+#else
+# define machine_is_pcats_overlay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HWGW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HWGW6410
+# endif
+# define machine_is_hwgw6410()	(machine_arch_type == MACH_TYPE_HWGW6410)
+#else
+# define machine_is_hwgw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHENZHOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHENZHOU
+# endif
+# define machine_is_shenzhou()	(machine_arch_type == MACH_TYPE_SHENZHOU)
+#else
+# define machine_is_shenzhou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210
+# endif
+# define machine_is_cwme9210()	(machine_arch_type == MACH_TYPE_CWME9210)
+#else
+# define machine_is_cwme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210JS
+# endif
+# define machine_is_cwme9210js()	(machine_arch_type == MACH_TYPE_CWME9210JS)
+#else
+# define machine_is_cwme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGS_SITARA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGS_SITARA
+# endif
+# define machine_is_pgs_v1()	(machine_arch_type == MACH_TYPE_PGS_SITARA)
+#else
+# define machine_is_pgs_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI_TEGRA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI_TEGRA2
+# endif
+# define machine_is_colibri_tegra2()	(machine_arch_type == MACH_TYPE_COLIBRI_TEGRA2)
+#else
+# define machine_is_colibri_tegra2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W21
+# endif
+# define machine_is_w21()	(machine_arch_type == MACH_TYPE_W21)
+#else
+# define machine_is_w21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLYSAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLYSAT1
+# endif
+# define machine_is_polysat1()	(machine_arch_type == MACH_TYPE_POLYSAT1)
+#else
+# define machine_is_polysat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATAWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATAWAY
+# endif
+# define machine_is_dataway()	(machine_arch_type == MACH_TYPE_DATAWAY)
+#else
+# define machine_is_dataway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBRAL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBRAL138
+# endif
+# define machine_is_cobral138()	(machine_arch_type == MACH_TYPE_COBRAL138)
+#else
+# define machine_is_cobral138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERPCS8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERPCS8
+# endif
+# define machine_is_roverpcs8()	(machine_arch_type == MACH_TYPE_ROVERPCS8)
+#else
+# define machine_is_roverpcs8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELC
+# endif
+# define machine_is_marvelc()	(machine_arch_type == MACH_TYPE_MARVELC)
+#else
+# define machine_is_marvelc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVEFIHID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVEFIHID
+# endif
+# define machine_is_navefihid()	(machine_arch_type == MACH_TYPE_NAVEFIHID)
+#else
+# define machine_is_navefihid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM365_CV100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM365_CV100
+# endif
+# define machine_is_dm365_cv100()	(machine_arch_type == MACH_TYPE_DM365_CV100)
+#else
+# define machine_is_dm365_cv100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABLE
+# endif
+# define machine_is_able()	(machine_arch_type == MACH_TYPE_ABLE)
+#else
+# define machine_is_able()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGACY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGACY
+# endif
+# define machine_is_legacy()	(machine_arch_type == MACH_TYPE_LEGACY)
+#else
+# define machine_is_legacy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONG
+# endif
+# define machine_is_icong()	(machine_arch_type == MACH_TYPE_ICONG)
+#else
+# define machine_is_icong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_G8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_G8
+# endif
+# define machine_is_rover_g8()	(machine_arch_type == MACH_TYPE_ROVER_G8)
+#else
+# define machine_is_rover_g8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5388P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5388P
+# endif
+# define machine_is_t5388p()	(machine_arch_type == MACH_TYPE_T5388P)
+#else
+# define machine_is_t5388p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINGO
+# endif
+# define machine_is_dingo()	(machine_arch_type == MACH_TYPE_DINGO)
+#else
+# define machine_is_dingo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXHOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXHOME
+# endif
+# define machine_is_goflexhome()	(machine_arch_type == MACH_TYPE_GOFLEXHOME)
+#else
+# define machine_is_goflexhome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN511
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN511
+# endif
+# define machine_is_lanreadyfn511()	(machine_arch_type == MACH_TYPE_LANREADYFN511)
+#else
+# define machine_is_lanreadyfn511()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BAIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BAIA
+# endif
+# define machine_is_omap3_baia()	(machine_arch_type == MACH_TYPE_OMAP3_BAIA)
+#else
+# define machine_is_omap3_baia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SMARTDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SMARTDISPLAY
+# endif
+# define machine_is_omap3smartdisplay()	(machine_arch_type == MACH_TYPE_OMAP3SMARTDISPLAY)
+#else
+# define machine_is_omap3smartdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX
+# endif
+# define machine_is_xilinx()	(machine_arch_type == MACH_TYPE_XILINX)
+#else
+# define machine_is_xilinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A2F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A2F
+# endif
+# define machine_is_a2f()	(machine_arch_type == MACH_TYPE_A2F)
+#else
+# define machine_is_a2f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY25
+# endif
+# define machine_is_sky25()	(machine_arch_type == MACH_TYPE_SKY25)
+#else
+# define machine_is_sky25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53
+# endif
+# define machine_is_ccmx53()	(machine_arch_type == MACH_TYPE_CCMX53)
+#else
+# define machine_is_ccmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53JS
+# endif
+# define machine_is_ccmx53js()	(machine_arch_type == MACH_TYPE_CCMX53JS)
+#else
+# define machine_is_ccmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53
+# endif
+# define machine_is_ccwmx53()	(machine_arch_type == MACH_TYPE_CCWMX53)
+#else
+# define machine_is_ccwmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53JS
+# endif
+# define machine_is_ccwmx53js()	(machine_arch_type == MACH_TYPE_CCWMX53JS)
+#else
+# define machine_is_ccwmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRISMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRISMS
+# endif
+# define machine_is_frisms()	(machine_arch_type == MACH_TYPE_FRISMS)
+#else
+# define machine_is_frisms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_FFA
+# endif
+# define machine_is_msm7x27a_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27A_FFA)
+#else
+# define machine_is_msm7x27a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_SURF
+# endif
+# define machine_is_msm7x27a_surf()	(machine_arch_type == MACH_TYPE_MSM7X27A_SURF)
+#else
+# define machine_is_msm7x27a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_RUMI3
+# endif
+# define machine_is_msm7x27a_rumi3()	(machine_arch_type == MACH_TYPE_MSM7X27A_RUMI3)
+#else
+# define machine_is_msm7x27a_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMSAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMSAM9G20
+# endif
+# define machine_is_dimmsam9g20()	(machine_arch_type == MACH_TYPE_DIMMSAM9G20)
+#else
+# define machine_is_dimmsam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_IMX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_IMX28
+# endif
+# define machine_is_dimm_imx28()	(machine_arch_type == MACH_TYPE_DIMM_IMX28)
+#else
+# define machine_is_dimm_imx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMK_A4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMK_A4
+# endif
+# define machine_is_amk_a4()	(machine_arch_type == MACH_TYPE_AMK_A4)
+#else
+# define machine_is_amk_a4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGME
+# endif
+# define machine_is_gnet_sgme()	(machine_arch_type == MACH_TYPE_GNET_SGME)
+#else
+# define machine_is_gnet_sgme()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_U
+# endif
+# define machine_is_shooter_u()	(machine_arch_type == MACH_TYPE_SHOOTER_U)
+#else
+# define machine_is_shooter_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX53
+# endif
+# define machine_is_vmx53()	(machine_arch_type == MACH_TYPE_VMX53)
+#else
+# define machine_is_vmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHINO
+# endif
+# define machine_is_rhino()	(machine_arch_type == MACH_TYPE_RHINO)
+#else
+# define machine_is_rhino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLEX4210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLEX4210
+# endif
+# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
+#else
+# define machine_is_armlex4210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOEXTMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOEXTMODEM
+# endif
+# define machine_is_swarcoextmodem()	(machine_arch_type == MACH_TYPE_SWARCOEXTMODEM)
+#else
+# define machine_is_swarcoextmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNOWBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNOWBALL
+# endif
+# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
+#else
+# define machine_is_snowball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM049
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM049
+# endif
+# define machine_is_pcm049()	(machine_arch_type == MACH_TYPE_PCM049)
+#else
+# define machine_is_pcm049()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIGOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIGOR
+# endif
+# define machine_is_vigor()	(machine_arch_type == MACH_TYPE_VIGOR)
+#else
+# define machine_is_vigor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_AMUNDSEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_AMUNDSEN
+# endif
+# define machine_is_oslo_amundsen()	(machine_arch_type == MACH_TYPE_OSLO_AMUNDSEN)
+#else
+# define machine_is_oslo_amundsen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSL_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSL_DIAMOND
+# endif
+# define machine_is_gsl_diamond()	(machine_arch_type == MACH_TYPE_GSL_DIAMOND)
+#else
+# define machine_is_gsl_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2201
+# endif
+# define machine_is_cv2201()	(machine_arch_type == MACH_TYPE_CV2201)
+#else
+# define machine_is_cv2201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2202
+# endif
+# define machine_is_cv2202()	(machine_arch_type == MACH_TYPE_CV2202)
+#else
+# define machine_is_cv2202()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2203
+# endif
+# define machine_is_cv2203()	(machine_arch_type == MACH_TYPE_CV2203)
+#else
+# define machine_is_cv2203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIT_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIT_IBOX
+# endif
+# define machine_is_vit_ibox()	(machine_arch_type == MACH_TYPE_VIT_IBOX)
+#else
+# define machine_is_vit_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6441_ESP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6441_ESP
+# endif
+# define machine_is_dm6441_esp()	(machine_arch_type == MACH_TYPE_DM6441_ESP)
+#else
+# define machine_is_dm6441_esp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9X5EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9X5EK
+# endif
+# define machine_is_at91sam9x5ek()	(machine_arch_type == MACH_TYPE_AT91SAM9X5EK)
+#else
+# define machine_is_at91sam9x5ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBRA
+# endif
+# define machine_is_libra()	(machine_arch_type == MACH_TYPE_LIBRA)
+#else
+# define machine_is_libra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EASYCRRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EASYCRRH
+# endif
+# define machine_is_easycrrh()	(machine_arch_type == MACH_TYPE_EASYCRRH)
+#else
+# define machine_is_easycrrh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIPEL
+# endif
+# define machine_is_tripel()	(machine_arch_type == MACH_TYPE_TRIPEL)
+#else
+# define machine_is_tripel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDIAN_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDIAN_MINI
+# endif
+# define machine_is_endian_mini()	(machine_arch_type == MACH_TYPE_ENDIAN_MINI)
+#else
+# define machine_is_endian_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX_EP107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX_EP107
+# endif
+# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
+#else
+# define machine_is_xilinx_ep107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NURI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NURI
+# endif
+# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
+#else
+# define machine_is_nuri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JANUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS
+# endif
+# define machine_is_janus()	(machine_arch_type == MACH_TYPE_JANUS)
+#else
+# define machine_is_janus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDNAS
+# endif
+# define machine_is_ddnas()	(machine_arch_type == MACH_TYPE_DDNAS)
+#else
+# define machine_is_ddnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAG
+# endif
+# define machine_is_tag()	(machine_arch_type == MACH_TYPE_TAG)
+#else
+# define machine_is_tag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGW
+# endif
+# define machine_is_tagw()	(machine_arch_type == MACH_TYPE_TAGW)
+#else
+# define machine_is_tagw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_VM_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_VM_IMX51
+# endif
+# define machine_is_nitrogen_vm_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_VM_IMX51)
+#else
+# define machine_is_nitrogen_vm_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIPRINET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPRINET
+# endif
+# define machine_is_viprinet()	(machine_arch_type == MACH_TYPE_VIPRINET)
+#else
+# define machine_is_viprinet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOCKW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOCKW
+# endif
+# define machine_is_bockw()	(machine_arch_type == MACH_TYPE_BOCKW)
+#else
+# define machine_is_bockw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA2000
+# endif
+# define machine_is_eva2000()	(machine_arch_type == MACH_TYPE_EVA2000)
+#else
+# define machine_is_eva2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELYARD
+# endif
+# define machine_is_steelyard()	(machine_arch_type == MACH_TYPE_STEELYARD)
+#else
+# define machine_is_steelyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_SDH001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_SDH001
+# endif
+# define machine_is_sdh001()	(machine_arch_type == MACH_TYPE_MACH_SDH001)
+#else
+# define machine_is_sdh001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSSLSBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSSLSBOARD
+# endif
+# define machine_is_nsslsboard()	(machine_arch_type == MACH_TYPE_NSSLSBOARD)
+#else
+# define machine_is_nsslsboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA_B5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA_B5
+# endif
+# define machine_is_geneva_b5()	(machine_arch_type == MACH_TYPE_GENEVA_B5)
+#else
+# define machine_is_geneva_b5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1340
+# endif
+# define machine_is_spear1340()	(machine_arch_type == MACH_TYPE_SPEAR1340)
+#else
+# define machine_is_spear1340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REXMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REXMAS
+# endif
+# define machine_is_rexmas()	(machine_arch_type == MACH_TYPE_REXMAS)
+#else
+# define machine_is_rexmas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_CDP
+# endif
+# define machine_is_msm8960_cdp()	(machine_arch_type == MACH_TYPE_MSM8960_CDP)
+#else
+# define machine_is_msm8960_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_MDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_MDP
+# endif
+# define machine_is_msm8960_mdp()	(machine_arch_type == MACH_TYPE_MSM8960_MDP)
+#else
+# define machine_is_msm8960_mdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_FLUID
+# endif
+# define machine_is_msm8960_fluid()	(machine_arch_type == MACH_TYPE_MSM8960_FLUID)
+#else
+# define machine_is_msm8960_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_APQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_APQ
+# endif
+# define machine_is_msm8960_apq()	(machine_arch_type == MACH_TYPE_MSM8960_APQ)
+#else
+# define machine_is_msm8960_apq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V2
+# endif
+# define machine_is_helios_v2()	(machine_arch_type == MACH_TYPE_HELIOS_V2)
+#else
+# define machine_is_helios_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIF10P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIF10P
+# endif
+# define machine_is_mif10p()	(machine_arch_type == MACH_TYPE_MIF10P)
+#else
+# define machine_is_mif10p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IAM28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM28
+# endif
+# define machine_is_iam28()	(machine_arch_type == MACH_TYPE_IAM28)
+#else
+# define machine_is_iam28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO
+# endif
+# define machine_is_picasso()	(machine_arch_type == MACH_TYPE_PICASSO)
+#else
+# define machine_is_picasso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MR301A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MR301A
+# endif
+# define machine_is_mr301a()	(machine_arch_type == MACH_TYPE_MR301A)
+#else
+# define machine_is_mr301a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTLE
+# endif
+# define machine_is_notle()	(machine_arch_type == MACH_TYPE_NOTLE)
+#else
+# define machine_is_notle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EELX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EELX2
+# endif
+# define machine_is_eelx2()	(machine_arch_type == MACH_TYPE_EELX2)
+#else
+# define machine_is_eelx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOON
+# endif
+# define machine_is_moon()	(machine_arch_type == MACH_TYPE_MOON)
+#else
+# define machine_is_moon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBY
+# endif
+# define machine_is_ruby()	(machine_arch_type == MACH_TYPE_RUBY)
+#else
+# define machine_is_ruby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOLDENGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOLDENGATE
+# endif
+# define machine_is_goldengate()	(machine_arch_type == MACH_TYPE_GOLDENGATE)
+#else
+# define machine_is_goldengate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTBU_GEN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTBU_GEN2
+# endif
+# define machine_is_ctbu_gen2()	(machine_arch_type == MACH_TYPE_CTBU_GEN2)
+#else
+# define machine_is_ctbu_gen2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMP_AM17_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMP_AM17_01
+# endif
+# define machine_is_kmp_am17_01()	(machine_arch_type == MACH_TYPE_KMP_AM17_01)
+#else
+# define machine_is_kmp_am17_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WTPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WTPLUG
+# endif
+# define machine_is_wtplug()	(machine_arch_type == MACH_TYPE_WTPLUG)
+#else
+# define machine_is_wtplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27SU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27SU2
+# endif
+# define machine_is_mx27su2()	(machine_arch_type == MACH_TYPE_MX27SU2)
+#else
+# define machine_is_mx27su2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB31
+# endif
+# define machine_is_nb31()	(machine_arch_type == MACH_TYPE_NB31)
+#else
+# define machine_is_nb31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HJSDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HJSDU
+# endif
+# define machine_is_hjsdu()	(machine_arch_type == MACH_TYPE_HJSDU)
+#else
+# define machine_is_hjsdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TD3_REV1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TD3_REV1
+# endif
+# define machine_is_td3_rev1()	(machine_arch_type == MACH_TYPE_TD3_REV1)
+#else
+# define machine_is_td3_rev1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAG_CI4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAG_CI4000
+# endif
+# define machine_is_eag_ci4000()	(machine_arch_type == MACH_TYPE_EAG_CI4000)
+#else
+# define machine_is_eag_ci4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_NAND_V2
+# endif
+# define machine_is_net5big_nand_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_NAND_V2)
+#else
+# define machine_is_net5big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPX2
+# endif
+# define machine_is_cpx2()	(machine_arch_type == MACH_TYPE_CPX2)
+#else
+# define machine_is_cpx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_NAND_V2
+# endif
+# define machine_is_net2big_nand_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_NAND_V2)
+#else
+# define machine_is_net2big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECUV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECUV5
+# endif
+# define machine_is_ecuv5()	(machine_arch_type == MACH_TYPE_ECUV5)
+#else
+# define machine_is_ecuv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSGX6D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSGX6D
+# endif
+# define machine_is_hsgx6d()	(machine_arch_type == MACH_TYPE_HSGX6D)
+#else
+# define machine_is_hsgx6d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAWAD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAWAD7
+# endif
+# define machine_is_dawad7()	(machine_arch_type == MACH_TYPE_DAWAD7)
+#else
+# define machine_is_dawad7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9REPEATER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9REPEATER
+# endif
+# define machine_is_sam9repeater()	(machine_arch_type == MACH_TYPE_SAM9REPEATER)
+#else
+# define machine_is_sam9repeater()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GT_I5700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GT_I5700
+# endif
+# define machine_is_gt_i5700()	(machine_arch_type == MACH_TYPE_GT_I5700)
+#else
+# define machine_is_gt_i5700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C2
+# endif
+# define machine_is_ctera_plug_c2()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C2)
+#else
+# define machine_is_ctera_plug_c2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELCT
+# endif
+# define machine_is_marvelct()	(machine_arch_type == MACH_TYPE_MARVELCT)
+#else
+# define machine_is_marvelct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG11005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG11005
+# endif
+# define machine_is_ag11005()	(machine_arch_type == MACH_TYPE_AG11005)
+#else
+# define machine_is_ag11005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH
+# endif
+# define machine_is_vangogh()	(machine_arch_type == MACH_TYPE_VANGOGH)
+#else
+# define machine_is_vangogh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX505
+# endif
+# define machine_is_matrix505()	(machine_arch_type == MACH_TYPE_MATRIX505)
+#else
+# define machine_is_matrix505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_NIGMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_NIGMA
+# endif
+# define machine_is_oce_nigma()	(machine_arch_type == MACH_TYPE_OCE_NIGMA)
+#else
+# define machine_is_oce_nigma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T55
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T55
+# endif
+# define machine_is_t55()	(machine_arch_type == MACH_TYPE_T55)
+#else
+# define machine_is_t55()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIO3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIO3K
+# endif
+# define machine_is_bio3k()	(machine_arch_type == MACH_TYPE_BIO3K)
+#else
+# define machine_is_bio3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSCT
+# endif
+# define machine_is_expressct()	(machine_arch_type == MACH_TYPE_EXPRESSCT)
+#else
+# define machine_is_expressct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARDHU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARDHU
+# endif
+# define machine_is_cardhu()	(machine_arch_type == MACH_TYPE_CARDHU)
+#else
+# define machine_is_cardhu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARUBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARUBA
+# endif
+# define machine_is_aruba()	(machine_arch_type == MACH_TYPE_ARUBA)
+#else
+# define machine_is_aruba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONAIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONAIRE
+# endif
+# define machine_is_bonaire()	(machine_arch_type == MACH_TYPE_BONAIRE)
+#else
+# define machine_is_bonaire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC700EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC700EVB
+# endif
+# define machine_is_nuc700evb()	(machine_arch_type == MACH_TYPE_NUC700EVB)
+#else
+# define machine_is_nuc700evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC710EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC710EVB
+# endif
+# define machine_is_nuc710evb()	(machine_arch_type == MACH_TYPE_NUC710EVB)
+#else
+# define machine_is_nuc710evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC740EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC740EVB
+# endif
+# define machine_is_nuc740evb()	(machine_arch_type == MACH_TYPE_NUC740EVB)
+#else
+# define machine_is_nuc740evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC745EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC745EVB
+# endif
+# define machine_is_nuc745evb()	(machine_arch_type == MACH_TYPE_NUC745EVB)
+#else
+# define machine_is_nuc745evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRANSCEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRANSCEDE
+# endif
+# define machine_is_transcede()	(machine_arch_type == MACH_TYPE_TRANSCEDE)
+#else
+# define machine_is_transcede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORA
+# endif
+# define machine_is_mora()	(machine_arch_type == MACH_TYPE_MORA)
+#else
+# define machine_is_mora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NDA_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NDA_EVM
+# endif
+# define machine_is_nda_evm()	(machine_arch_type == MACH_TYPE_NDA_EVM)
+#else
+# define machine_is_nda_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIMU
+# endif
+# define machine_is_timu()	(machine_arch_type == MACH_TYPE_TIMU)
+#else
+# define machine_is_timu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSH
+# endif
+# define machine_is_expressh()	(machine_arch_type == MACH_TYPE_EXPRESSH)
+#else
+# define machine_is_expressh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERIDIS_A300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERIDIS_A300
+# endif
+# define machine_is_veridis_a300()	(machine_arch_type == MACH_TYPE_VERIDIS_A300)
+#else
+# define machine_is_veridis_a300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM368_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM368_LEOPARD
+# endif
+# define machine_is_dm368_leopard()	(machine_arch_type == MACH_TYPE_DM368_LEOPARD)
+#else
+# define machine_is_dm368_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_MCOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_MCOP
+# endif
+# define machine_is_omap_mcop()	(machine_arch_type == MACH_TYPE_OMAP_MCOP)
+#else
+# define machine_is_omap_mcop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRITIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRITIP
+# endif
+# define machine_is_tritip()	(machine_arch_type == MACH_TYPE_TRITIP)
+#else
+# define machine_is_tritip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM1K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM1K
+# endif
+# define machine_is_sm1k()	(machine_arch_type == MACH_TYPE_SM1K)
+#else
+# define machine_is_sm1k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONCH
+# endif
+# define machine_is_monch()	(machine_arch_type == MACH_TYPE_MONCH)
+#else
+# define machine_is_monch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CURACAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CURACAO
+# endif
+# define machine_is_curacao()	(machine_arch_type == MACH_TYPE_CURACAO)
+#else
+# define machine_is_curacao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORIGEN
+# endif
+# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
+#else
+# define machine_is_origen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPC10
+# endif
+# define machine_is_epc10()	(machine_arch_type == MACH_TYPE_EPC10)
+#else
+# define machine_is_epc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I740
+# endif
+# define machine_is_sgh_i740()	(machine_arch_type == MACH_TYPE_SGH_I740)
+#else
+# define machine_is_sgh_i740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNA
+# endif
+# define machine_is_tuna()	(machine_arch_type == MACH_TYPE_TUNA)
+#else
+# define machine_is_tuna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_TULIP
+# endif
+# define machine_is_mx51_tulip()	(machine_arch_type == MACH_TYPE_MX51_TULIP)
+#else
+# define machine_is_mx51_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_ASTER7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_ASTER7
+# endif
+# define machine_is_mx51_aster7()	(machine_arch_type == MACH_TYPE_MX51_ASTER7)
+#else
+# define machine_is_mx51_aster7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACRO37XBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACRO37XBRD
+# endif
+# define machine_is_acro37xbrd()	(machine_arch_type == MACH_TYPE_ACRO37XBRD)
+#else
+# define machine_is_acro37xbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELKE
+# endif
+# define machine_is_elke()	(machine_arch_type == MACH_TYPE_ELKE)
+#else
+# define machine_is_elke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC6000X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC6000X
+# endif
+# define machine_is_sbc6000x()	(machine_arch_type == MACH_TYPE_SBC6000X)
+#else
+# define machine_is_sbc6000x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1801E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1801E
+# endif
+# define machine_is_r1801e()	(machine_arch_type == MACH_TYPE_R1801E)
+#else
+# define machine_is_r1801e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1600
+# endif
+# define machine_is_h1600()	(machine_arch_type == MACH_TYPE_H1600)
+#else
+# define machine_is_h1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI210
+# endif
+# define machine_is_mini210()	(machine_arch_type == MACH_TYPE_MINI210)
+#else
+# define machine_is_mini210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI8168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI8168
+# endif
+# define machine_is_mini8168()	(machine_arch_type == MACH_TYPE_MINI8168)
+#else
+# define machine_is_mini8168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7308
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7308
+# endif
+# define machine_is_pc7308()	(machine_arch_type == MACH_TYPE_PC7308)
+#else
+# define machine_is_pc7308()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMM2M01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMM2M01
+# endif
+# define machine_is_kmm2m01()	(machine_arch_type == MACH_TYPE_KMM2M01)
+#else
+# define machine_is_kmm2m01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51EREBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51EREBUS
+# endif
+# define machine_is_mx51erebus()	(machine_arch_type == MACH_TYPE_MX51EREBUS)
+#else
+# define machine_is_mx51erebus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8650REFBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8650REFBOARD
+# endif
+# define machine_is_wm8650refboard()	(machine_arch_type == MACH_TYPE_WM8650REFBOARD)
+#else
+# define machine_is_wm8650refboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUXRAIL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUXRAIL
+# endif
+# define machine_is_tuxrail()	(machine_arch_type == MACH_TYPE_TUXRAIL)
+#else
+# define machine_is_tuxrail()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARTHUR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARTHUR
+# endif
+# define machine_is_arthur()	(machine_arch_type == MACH_TYPE_ARTHUR)
+#else
+# define machine_is_arthur()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOORBOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOORBOY
+# endif
+# define machine_is_doorboy()	(machine_arch_type == MACH_TYPE_DOORBOY)
+#else
+# define machine_is_doorboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARINA
+# endif
+# define machine_is_xarina()	(machine_arch_type == MACH_TYPE_XARINA)
+#else
+# define machine_is_xarina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERX7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERX7
+# endif
+# define machine_is_roverx7()	(machine_arch_type == MACH_TYPE_ROVERX7)
+#else
+# define machine_is_roverx7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR
+# endif
+# define machine_is_sdvr()	(machine_arch_type == MACH_TYPE_SDVR)
+#else
+# define machine_is_sdvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_MAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_MAYA
+# endif
+# define machine_is_acer_maya()	(machine_arch_type == MACH_TYPE_ACER_MAYA)
+#else
+# define machine_is_acer_maya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICO
+# endif
+# define machine_is_pico()	(machine_arch_type == MACH_TYPE_PICO)
+#else
+# define machine_is_pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX233
+# endif
+# define machine_is_cwmx233()	(machine_arch_type == MACH_TYPE_CWMX233)
+#else
+# define machine_is_cwmx233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWAM1808
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWAM1808
+# endif
+# define machine_is_cwam1808()	(machine_arch_type == MACH_TYPE_CWAM1808)
+#else
+# define machine_is_cwam1808()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWDM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWDM365
+# endif
+# define machine_is_cwdm365()	(machine_arch_type == MACH_TYPE_CWDM365)
+#else
+# define machine_is_cwdm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_MORAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_MORAY
+# endif
+# define machine_is_mx51_moray()	(machine_arch_type == MACH_TYPE_MX51_MORAY)
+#else
+# define machine_is_mx51_moray()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_CBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_CBC
+# endif
+# define machine_is_thales_cbc()	(machine_arch_type == MACH_TYPE_THALES_CBC)
+#else
+# define machine_is_thales_cbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEPOINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEPOINT
+# endif
+# define machine_is_bluepoint()	(machine_arch_type == MACH_TYPE_BLUEPOINT)
+#else
+# define machine_is_bluepoint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIR665
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIR665
+# endif
+# define machine_is_dir665()	(machine_arch_type == MACH_TYPE_DIR665)
+#else
+# define machine_is_dir665()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMEROVER1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMEROVER1
+# endif
+# define machine_is_acmerover1()	(machine_arch_type == MACH_TYPE_ACMEROVER1)
+#else
+# define machine_is_acmerover1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_CT
+# endif
+# define machine_is_shooter_ct()	(machine_arch_type == MACH_TYPE_SHOOTER_CT)
+#else
+# define machine_is_shooter_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISS
+# endif
+# define machine_is_bliss()	(machine_arch_type == MACH_TYPE_BLISS)
+#else
+# define machine_is_bliss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISSC
+# endif
+# define machine_is_blissc()	(machine_arch_type == MACH_TYPE_BLISSC)
+#else
+# define machine_is_blissc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_ADC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_ADC
+# endif
+# define machine_is_thales_adc()	(machine_arch_type == MACH_TYPE_THALES_ADC)
+#else
+# define machine_is_thales_adc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9D_EVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9D_EVP
+# endif
+# define machine_is_ubisys_p9d_evp()	(machine_arch_type == MACH_TYPE_UBISYS_P9D_EVP)
+#else
+# define machine_is_ubisys_p9d_evp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATDGP318
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATDGP318
+# endif
+# define machine_is_atdgp318()	(machine_arch_type == MACH_TYPE_ATDGP318)
+#else
+# define machine_is_atdgp318()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -uprN linux-3.1.5-orig/include/generated/utsrelease.h linux-3.1.5/include/generated/utsrelease.h
--- linux-3.1.5-orig/include/generated/utsrelease.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/generated/utsrelease.h	2012-10-25 20:03:21.040350396 -0600
@@ -0,0 +1 @@
+#define UTS_RELEASE "3.1.5-FriendlyARM"
diff -uprN linux-3.1.5-orig/include/linux/version.h linux-3.1.5/include/linux/version.h
--- linux-3.1.5-orig/include/linux/version.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/include/linux/version.h	2012-10-25 17:03:33.029407706 -0600
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 196869
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -uprN linux-3.1.5-orig/scripts/basic/.fixdep.cmd linux-3.1.5/scripts/basic/.fixdep.cmd
--- linux-3.1.5-orig/scripts/basic/.fixdep.cmd	2012-10-25 16:26:52.314579808 -0600
+++ linux-3.1.5/scripts/basic/.fixdep.cmd	1969-12-31 17:00:00.000000000 -0700
@@ -1,83 +0,0 @@
-cmd_scripts/basic/fixdep := gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c  
-
-source_scripts/basic/fixdep := scripts/basic/fixdep.c
-
-deps_scripts/basic/fixdep := \
-    $(wildcard include/config/his/driver.h) \
-    $(wildcard include/config/my/option.h) \
-    $(wildcard include/config/.h) \
-    $(wildcard include/config/foo.h) \
-    $(wildcard include/config/boom.h) \
-  /usr/include/sys/types.h \
-  /usr/include/features.h \
-  /usr/include/sys/cdefs.h \
-  /usr/include/bits/wordsize.h \
-  /usr/include/gnu/stubs.h \
-  /usr/include/gnu/stubs-32.h \
-  /usr/include/bits/types.h \
-  /usr/include/bits/typesizes.h \
-  /usr/include/time.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stddef.h \
-  /usr/include/endian.h \
-  /usr/include/bits/endian.h \
-  /usr/include/bits/byteswap.h \
-  /usr/include/sys/select.h \
-  /usr/include/bits/select.h \
-  /usr/include/bits/sigset.h \
-  /usr/include/bits/time.h \
-  /usr/include/sys/sysmacros.h \
-  /usr/include/bits/pthreadtypes.h \
-  /usr/include/sys/stat.h \
-  /usr/include/bits/stat.h \
-  /usr/include/sys/mman.h \
-  /usr/include/bits/mman.h \
-  /usr/include/unistd.h \
-  /usr/include/bits/posix_opt.h \
-  /usr/include/bits/environments.h \
-  /usr/include/bits/confname.h \
-  /usr/include/getopt.h \
-  /usr/include/fcntl.h \
-  /usr/include/bits/fcntl.h \
-  /usr/include/string.h \
-  /usr/include/xlocale.h \
-  /usr/include/bits/string.h \
-  /usr/include/bits/string2.h \
-  /usr/include/stdlib.h \
-  /usr/include/bits/waitflags.h \
-  /usr/include/bits/waitstatus.h \
-  /usr/include/alloca.h \
-  /usr/include/stdio.h \
-  /usr/include/libio.h \
-  /usr/include/_G_config.h \
-  /usr/include/wchar.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdarg.h \
-  /usr/include/bits/stdio_lim.h \
-  /usr/include/bits/sys_errlist.h \
-  /usr/include/bits/stdio.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/limits.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/syslimits.h \
-  /usr/include/limits.h \
-  /usr/include/bits/posix1_lim.h \
-  /usr/include/bits/local_lim.h \
-  /usr/include/linux/limits.h \
-  /usr/include/bits/posix2_lim.h \
-  /usr/include/ctype.h \
-  /usr/include/arpa/inet.h \
-  /usr/include/netinet/in.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdint.h \
-  /usr/include/stdint.h \
-  /usr/include/bits/wchar.h \
-  /usr/include/sys/socket.h \
-  /usr/include/sys/uio.h \
-  /usr/include/bits/uio.h \
-  /usr/include/bits/socket.h \
-  /usr/include/bits/sockaddr.h \
-  /usr/include/asm/socket.h \
-  /usr/include/asm-generic/socket.h \
-  /usr/include/asm/sockios.h \
-  /usr/include/asm-generic/sockios.h \
-  /usr/include/bits/in.h \
-
-scripts/basic/fixdep: $(deps_scripts/basic/fixdep)
-
-$(deps_scripts/basic/fixdep):
Binary files linux-3.1.5-orig/scripts/conmakehash and linux-3.1.5/scripts/conmakehash differ
Binary files linux-3.1.5-orig/scripts/kallsyms and linux-3.1.5/scripts/kallsyms differ
diff -uprN linux-3.1.5-orig/scripts/kconfig/.conf.cmd linux-3.1.5/scripts/kconfig/.conf.cmd
--- linux-3.1.5-orig/scripts/kconfig/.conf.cmd	2012-10-25 16:26:53.565583446 -0600
+++ linux-3.1.5/scripts/kconfig/.conf.cmd	1969-12-31 17:00:00.000000000 -0700
@@ -1 +0,0 @@
-cmd_scripts/kconfig/conf := gcc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o  
Binary files linux-3.1.5-orig/scripts/kconfig/conf.o and linux-3.1.5/scripts/kconfig/conf.o differ
diff -uprN linux-3.1.5-orig/scripts/kconfig/.conf.o.cmd linux-3.1.5/scripts/kconfig/.conf.o.cmd
--- linux-3.1.5-orig/scripts/kconfig/.conf.o.cmd	2012-10-25 16:26:52.798581220 -0600
+++ linux-3.1.5/scripts/kconfig/.conf.o.cmd	1969-12-31 17:00:00.000000000 -0700
@@ -1,64 +0,0 @@
-cmd_scripts/kconfig/conf.o := gcc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
-
-source_scripts/kconfig/conf.o := scripts/kconfig/conf.c
-
-deps_scripts/kconfig/conf.o := \
-    $(wildcard include/config/.h) \
-    $(wildcard include/config/allconfig.h) \
-    $(wildcard include/config/nosilentupdate.h) \
-  /usr/include/locale.h \
-  /usr/include/features.h \
-  /usr/include/sys/cdefs.h \
-  /usr/include/bits/wordsize.h \
-  /usr/include/gnu/stubs.h \
-  /usr/include/gnu/stubs-32.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stddef.h \
-  /usr/include/bits/locale.h \
-  /usr/include/xlocale.h \
-  /usr/include/ctype.h \
-  /usr/include/bits/types.h \
-  /usr/include/bits/typesizes.h \
-  /usr/include/endian.h \
-  /usr/include/bits/endian.h \
-  /usr/include/bits/byteswap.h \
-  /usr/include/stdio.h \
-  /usr/include/libio.h \
-  /usr/include/_G_config.h \
-  /usr/include/wchar.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdarg.h \
-  /usr/include/bits/stdio_lim.h \
-  /usr/include/bits/sys_errlist.h \
-  /usr/include/bits/stdio.h \
-  /usr/include/stdlib.h \
-  /usr/include/bits/waitflags.h \
-  /usr/include/bits/waitstatus.h \
-  /usr/include/sys/types.h \
-  /usr/include/time.h \
-  /usr/include/sys/select.h \
-  /usr/include/bits/select.h \
-  /usr/include/bits/sigset.h \
-  /usr/include/bits/time.h \
-  /usr/include/sys/sysmacros.h \
-  /usr/include/bits/pthreadtypes.h \
-  /usr/include/alloca.h \
-  /usr/include/string.h \
-  /usr/include/bits/string.h \
-  /usr/include/bits/string2.h \
-  /usr/include/unistd.h \
-  /usr/include/bits/posix_opt.h \
-  /usr/include/bits/environments.h \
-  /usr/include/bits/confname.h \
-  /usr/include/getopt.h \
-  /usr/include/sys/stat.h \
-  /usr/include/bits/stat.h \
-  /usr/include/sys/time.h \
-  scripts/kconfig/lkc.h \
-    $(wildcard include/config/list.h) \
-  scripts/kconfig/expr.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdbool.h \
-  /usr/include/libintl.h \
-  scripts/kconfig/lkc_proto.h \
-
-scripts/kconfig/conf.o: $(deps_scripts/kconfig/conf.o)
-
-$(deps_scripts/kconfig/conf.o):
Binary files linux-3.1.5-orig/scripts/kconfig/qconf and linux-3.1.5/scripts/kconfig/qconf differ
diff -uprN linux-3.1.5-orig/scripts/kconfig/qconf.moc linux-3.1.5/scripts/kconfig/qconf.moc
--- linux-3.1.5-orig/scripts/kconfig/qconf.moc	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/scripts/kconfig/qconf.moc	2012-10-25 16:54:02.893239383 -0600
@@ -0,0 +1,766 @@
+/****************************************************************************
+** ConfigList meta object code from reading C++ file 'qconf.h'
+**
+** Created: Thu Oct 25 16:54:02 2012
+**      by: The Qt MOC ($Id: qt/moc_yacc.cpp   3.3.8   edited Feb 2 14:59 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include <qmetaobject.h>
+#include <qapplication.h>
+
+#include <private/qucomextra_p.h>
+#if !defined(Q_MOC_OUTPUT_REVISION) || (Q_MOC_OUTPUT_REVISION != 26)
+#error "This file was generated using the moc from 3.3.8b. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+const char *ConfigList::className() const
+{
+    return "ConfigList";
+}
+
+QMetaObject *ConfigList::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigList( "ConfigList", &ConfigList::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigList::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigList", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigList::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigList", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigList::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = Q3ListView::staticMetaObject();
+    static const QUParameter param_slot_0[] = {
+	{ "menu", &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod slot_0 = {"setRootMenu", 1, param_slot_0 };
+    static const QUParameter param_slot_1[] = {
+	{ "item", &static_QUType_ptr, "ConfigItem", QUParameter::In }
+    };
+    static const QUMethod slot_1 = {"updateList", 1, param_slot_1 };
+    static const QUParameter param_slot_2[] = {
+	{ "item", &static_QUType_ptr, "ConfigItem", QUParameter::In },
+	{ "val", &static_QUType_ptr, "tristate", QUParameter::In }
+    };
+    static const QUMethod slot_2 = {"setValue", 2, param_slot_2 };
+    static const QUParameter param_slot_3[] = {
+	{ "item", &static_QUType_ptr, "ConfigItem", QUParameter::In }
+    };
+    static const QUMethod slot_3 = {"changeValue", 1, param_slot_3 };
+    static const QUMethod slot_4 = {"updateSelection", 0, 0 };
+    static const QUMethod slot_5 = {"saveSettings", 0, 0 };
+    static const QMetaData slot_tbl[] = {
+	{ "setRootMenu(struct menu*)", &slot_0, QMetaData::Public },
+	{ "updateList(ConfigItem*)", &slot_1, QMetaData::Public },
+	{ "setValue(ConfigItem*,tristate)", &slot_2, QMetaData::Public },
+	{ "changeValue(ConfigItem*)", &slot_3, QMetaData::Public },
+	{ "updateSelection()", &slot_4, QMetaData::Public },
+	{ "saveSettings()", &slot_5, QMetaData::Public }
+    };
+    static const QUParameter param_signal_0[] = {
+	{ "menu", &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod signal_0 = {"menuChanged", 1, param_signal_0 };
+    static const QUParameter param_signal_1[] = {
+	{ "menu", &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod signal_1 = {"menuSelected", 1, param_signal_1 };
+    static const QUMethod signal_2 = {"parentSelected", 0, 0 };
+    static const QUParameter param_signal_3[] = {
+	{ 0, &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod signal_3 = {"gotFocus", 1, param_signal_3 };
+    static const QMetaData signal_tbl[] = {
+	{ "menuChanged(struct menu*)", &signal_0, QMetaData::Public },
+	{ "menuSelected(struct menu*)", &signal_1, QMetaData::Public },
+	{ "parentSelected()", &signal_2, QMetaData::Public },
+	{ "gotFocus(struct menu*)", &signal_3, QMetaData::Public }
+    };
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigList", parentObject,
+	slot_tbl, 6,
+	signal_tbl, 4,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigList.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigList::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigList" ) )
+	return this;
+    return Q3ListView::qt_cast( clname );
+}
+
+#include <qobjectdefs.h>
+#include <qsignalslotimp.h>
+
+// SIGNAL menuChanged
+void ConfigList::menuChanged( struct menu* t0 )
+{
+    if ( signalsBlocked() )
+	return;
+    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
+    if ( !clist )
+	return;
+    QUObject o[2];
+    static_QUType_ptr.set(o+1,t0);
+    activate_signal( clist, o );
+}
+
+// SIGNAL menuSelected
+void ConfigList::menuSelected( struct menu* t0 )
+{
+    if ( signalsBlocked() )
+	return;
+    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
+    if ( !clist )
+	return;
+    QUObject o[2];
+    static_QUType_ptr.set(o+1,t0);
+    activate_signal( clist, o );
+}
+
+// SIGNAL parentSelected
+void ConfigList::parentSelected()
+{
+    activate_signal( staticMetaObject()->signalOffset() + 2 );
+}
+
+// SIGNAL gotFocus
+void ConfigList::gotFocus( struct menu* t0 )
+{
+    if ( signalsBlocked() )
+	return;
+    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 3 );
+    if ( !clist )
+	return;
+    QUObject o[2];
+    static_QUType_ptr.set(o+1,t0);
+    activate_signal( clist, o );
+}
+
+bool ConfigList::qt_invoke( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->slotOffset() ) {
+    case 0: setRootMenu((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 1: updateList((ConfigItem*)static_QUType_ptr.get(_o+1)); break;
+    case 2: setValue((ConfigItem*)static_QUType_ptr.get(_o+1),(tristate)(*((tristate*)static_QUType_ptr.get(_o+2)))); break;
+    case 3: changeValue((ConfigItem*)static_QUType_ptr.get(_o+1)); break;
+    case 4: updateSelection(); break;
+    case 5: saveSettings(); break;
+    default:
+	return Q3ListView::qt_invoke( _id, _o );
+    }
+    return TRUE;
+}
+
+bool ConfigList::qt_emit( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->signalOffset() ) {
+    case 0: menuChanged((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 1: menuSelected((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 2: parentSelected(); break;
+    case 3: gotFocus((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    default:
+	return Q3ListView::qt_emit(_id,_o);
+    }
+    return TRUE;
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigList::qt_property( int id, int f, QVariant* v)
+{
+    return Q3ListView::qt_property( id, f, v);
+}
+
+bool ConfigList::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
+
+
+const char *ConfigLineEdit::className() const
+{
+    return "ConfigLineEdit";
+}
+
+QMetaObject *ConfigLineEdit::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigLineEdit( "ConfigLineEdit", &ConfigLineEdit::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigLineEdit::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigLineEdit", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigLineEdit::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigLineEdit", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigLineEdit::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = QLineEdit::staticMetaObject();
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigLineEdit", parentObject,
+	0, 0,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigLineEdit.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigLineEdit::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigLineEdit" ) )
+	return this;
+    return QLineEdit::qt_cast( clname );
+}
+
+bool ConfigLineEdit::qt_invoke( int _id, QUObject* _o )
+{
+    return QLineEdit::qt_invoke(_id,_o);
+}
+
+bool ConfigLineEdit::qt_emit( int _id, QUObject* _o )
+{
+    return QLineEdit::qt_emit(_id,_o);
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigLineEdit::qt_property( int id, int f, QVariant* v)
+{
+    return QLineEdit::qt_property( id, f, v);
+}
+
+bool ConfigLineEdit::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
+
+
+const char *ConfigView::className() const
+{
+    return "ConfigView";
+}
+
+QMetaObject *ConfigView::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigView( "ConfigView", &ConfigView::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigView::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigView", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigView::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigView", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigView::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = Q3VBox::staticMetaObject();
+    static const QUParameter param_slot_0[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod slot_0 = {"setShowName", 1, param_slot_0 };
+    static const QUParameter param_slot_1[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod slot_1 = {"setShowRange", 1, param_slot_1 };
+    static const QUParameter param_slot_2[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod slot_2 = {"setShowData", 1, param_slot_2 };
+    static const QUParameter param_slot_3[] = {
+	{ 0, &static_QUType_ptr, "QAction", QUParameter::In }
+    };
+    static const QUMethod slot_3 = {"setOptionMode", 1, param_slot_3 };
+    static const QMetaData slot_tbl[] = {
+	{ "setShowName(bool)", &slot_0, QMetaData::Public },
+	{ "setShowRange(bool)", &slot_1, QMetaData::Public },
+	{ "setShowData(bool)", &slot_2, QMetaData::Public },
+	{ "setOptionMode(QAction*)", &slot_3, QMetaData::Public }
+    };
+    static const QUParameter param_signal_0[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod signal_0 = {"showNameChanged", 1, param_signal_0 };
+    static const QUParameter param_signal_1[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod signal_1 = {"showRangeChanged", 1, param_signal_1 };
+    static const QUParameter param_signal_2[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod signal_2 = {"showDataChanged", 1, param_signal_2 };
+    static const QMetaData signal_tbl[] = {
+	{ "showNameChanged(bool)", &signal_0, QMetaData::Public },
+	{ "showRangeChanged(bool)", &signal_1, QMetaData::Public },
+	{ "showDataChanged(bool)", &signal_2, QMetaData::Public }
+    };
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigView", parentObject,
+	slot_tbl, 4,
+	signal_tbl, 3,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigView.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigView::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigView" ) )
+	return this;
+    return Q3VBox::qt_cast( clname );
+}
+
+// SIGNAL showNameChanged
+void ConfigView::showNameChanged( bool t0 )
+{
+    activate_signal_bool( staticMetaObject()->signalOffset() + 0, t0 );
+}
+
+// SIGNAL showRangeChanged
+void ConfigView::showRangeChanged( bool t0 )
+{
+    activate_signal_bool( staticMetaObject()->signalOffset() + 1, t0 );
+}
+
+// SIGNAL showDataChanged
+void ConfigView::showDataChanged( bool t0 )
+{
+    activate_signal_bool( staticMetaObject()->signalOffset() + 2, t0 );
+}
+
+bool ConfigView::qt_invoke( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->slotOffset() ) {
+    case 0: setShowName((bool)static_QUType_bool.get(_o+1)); break;
+    case 1: setShowRange((bool)static_QUType_bool.get(_o+1)); break;
+    case 2: setShowData((bool)static_QUType_bool.get(_o+1)); break;
+    case 3: setOptionMode((QAction*)static_QUType_ptr.get(_o+1)); break;
+    default:
+	return Q3VBox::qt_invoke( _id, _o );
+    }
+    return TRUE;
+}
+
+bool ConfigView::qt_emit( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->signalOffset() ) {
+    case 0: showNameChanged((bool)static_QUType_bool.get(_o+1)); break;
+    case 1: showRangeChanged((bool)static_QUType_bool.get(_o+1)); break;
+    case 2: showDataChanged((bool)static_QUType_bool.get(_o+1)); break;
+    default:
+	return Q3VBox::qt_emit(_id,_o);
+    }
+    return TRUE;
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigView::qt_property( int id, int f, QVariant* v)
+{
+    return Q3VBox::qt_property( id, f, v);
+}
+
+bool ConfigView::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
+
+
+const char *ConfigInfoView::className() const
+{
+    return "ConfigInfoView";
+}
+
+QMetaObject *ConfigInfoView::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigInfoView( "ConfigInfoView", &ConfigInfoView::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigInfoView::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigInfoView", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigInfoView::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigInfoView", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigInfoView::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = Q3TextBrowser::staticMetaObject();
+    static const QUParameter param_slot_0[] = {
+	{ "menu", &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod slot_0 = {"setInfo", 1, param_slot_0 };
+    static const QUMethod slot_1 = {"saveSettings", 0, 0 };
+    static const QUParameter param_slot_2[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod slot_2 = {"setShowDebug", 1, param_slot_2 };
+    static const QMetaData slot_tbl[] = {
+	{ "setInfo(struct menu*)", &slot_0, QMetaData::Public },
+	{ "saveSettings()", &slot_1, QMetaData::Public },
+	{ "setShowDebug(bool)", &slot_2, QMetaData::Public }
+    };
+    static const QUParameter param_signal_0[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::In }
+    };
+    static const QUMethod signal_0 = {"showDebugChanged", 1, param_signal_0 };
+    static const QUParameter param_signal_1[] = {
+	{ 0, &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod signal_1 = {"menuSelected", 1, param_signal_1 };
+    static const QMetaData signal_tbl[] = {
+	{ "showDebugChanged(bool)", &signal_0, QMetaData::Public },
+	{ "menuSelected(struct menu*)", &signal_1, QMetaData::Public }
+    };
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigInfoView", parentObject,
+	slot_tbl, 3,
+	signal_tbl, 2,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigInfoView.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigInfoView::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigInfoView" ) )
+	return this;
+    return Q3TextBrowser::qt_cast( clname );
+}
+
+// SIGNAL showDebugChanged
+void ConfigInfoView::showDebugChanged( bool t0 )
+{
+    activate_signal_bool( staticMetaObject()->signalOffset() + 0, t0 );
+}
+
+// SIGNAL menuSelected
+void ConfigInfoView::menuSelected( struct menu* t0 )
+{
+    if ( signalsBlocked() )
+	return;
+    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
+    if ( !clist )
+	return;
+    QUObject o[2];
+    static_QUType_ptr.set(o+1,t0);
+    activate_signal( clist, o );
+}
+
+bool ConfigInfoView::qt_invoke( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->slotOffset() ) {
+    case 0: setInfo((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 1: saveSettings(); break;
+    case 2: setShowDebug((bool)static_QUType_bool.get(_o+1)); break;
+    default:
+	return Q3TextBrowser::qt_invoke( _id, _o );
+    }
+    return TRUE;
+}
+
+bool ConfigInfoView::qt_emit( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->signalOffset() ) {
+    case 0: showDebugChanged((bool)static_QUType_bool.get(_o+1)); break;
+    case 1: menuSelected((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    default:
+	return Q3TextBrowser::qt_emit(_id,_o);
+    }
+    return TRUE;
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigInfoView::qt_property( int id, int f, QVariant* v)
+{
+    return Q3TextBrowser::qt_property( id, f, v);
+}
+
+bool ConfigInfoView::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
+
+
+const char *ConfigSearchWindow::className() const
+{
+    return "ConfigSearchWindow";
+}
+
+QMetaObject *ConfigSearchWindow::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigSearchWindow( "ConfigSearchWindow", &ConfigSearchWindow::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigSearchWindow::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigSearchWindow", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigSearchWindow::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigSearchWindow", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigSearchWindow::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = QDialog::staticMetaObject();
+    static const QUMethod slot_0 = {"saveSettings", 0, 0 };
+    static const QUMethod slot_1 = {"search", 0, 0 };
+    static const QMetaData slot_tbl[] = {
+	{ "saveSettings()", &slot_0, QMetaData::Public },
+	{ "search()", &slot_1, QMetaData::Public }
+    };
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigSearchWindow", parentObject,
+	slot_tbl, 2,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigSearchWindow.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigSearchWindow::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigSearchWindow" ) )
+	return this;
+    return QDialog::qt_cast( clname );
+}
+
+bool ConfigSearchWindow::qt_invoke( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->slotOffset() ) {
+    case 0: saveSettings(); break;
+    case 1: search(); break;
+    default:
+	return QDialog::qt_invoke( _id, _o );
+    }
+    return TRUE;
+}
+
+bool ConfigSearchWindow::qt_emit( int _id, QUObject* _o )
+{
+    return QDialog::qt_emit(_id,_o);
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigSearchWindow::qt_property( int id, int f, QVariant* v)
+{
+    return QDialog::qt_property( id, f, v);
+}
+
+bool ConfigSearchWindow::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
+
+
+const char *ConfigMainWindow::className() const
+{
+    return "ConfigMainWindow";
+}
+
+QMetaObject *ConfigMainWindow::metaObj = 0;
+static QMetaObjectCleanUp cleanUp_ConfigMainWindow( "ConfigMainWindow", &ConfigMainWindow::staticMetaObject );
+
+#ifndef QT_NO_TRANSLATION
+QString ConfigMainWindow::tr( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigMainWindow", s, c, QApplication::DefaultCodec );
+    else
+	return QString::fromLatin1( s );
+}
+#ifndef QT_NO_TRANSLATION_UTF8
+QString ConfigMainWindow::trUtf8( const char *s, const char *c )
+{
+    if ( qApp )
+	return qApp->translate( "ConfigMainWindow", s, c, QApplication::UnicodeUTF8 );
+    else
+	return QString::fromUtf8( s );
+}
+#endif // QT_NO_TRANSLATION_UTF8
+
+#endif // QT_NO_TRANSLATION
+
+QMetaObject* ConfigMainWindow::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    QMetaObject* parentObject = Q3MainWindow::staticMetaObject();
+    static const QUParameter param_slot_0[] = {
+	{ 0, &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod slot_0 = {"changeMenu", 1, param_slot_0 };
+    static const QUParameter param_slot_1[] = {
+	{ 0, &static_QUType_ptr, "struct menu", QUParameter::In }
+    };
+    static const QUMethod slot_1 = {"setMenuLink", 1, param_slot_1 };
+    static const QUMethod slot_2 = {"listFocusChanged", 0, 0 };
+    static const QUMethod slot_3 = {"goBack", 0, 0 };
+    static const QUMethod slot_4 = {"loadConfig", 0, 0 };
+    static const QUParameter param_slot_5[] = {
+	{ 0, &static_QUType_bool, 0, QUParameter::Out }
+    };
+    static const QUMethod slot_5 = {"saveConfig", 1, param_slot_5 };
+    static const QUMethod slot_6 = {"saveConfigAs", 0, 0 };
+    static const QUMethod slot_7 = {"searchConfig", 0, 0 };
+    static const QUMethod slot_8 = {"showSingleView", 0, 0 };
+    static const QUMethod slot_9 = {"showSplitView", 0, 0 };
+    static const QUMethod slot_10 = {"showFullView", 0, 0 };
+    static const QUMethod slot_11 = {"showIntro", 0, 0 };
+    static const QUMethod slot_12 = {"showAbout", 0, 0 };
+    static const QUMethod slot_13 = {"saveSettings", 0, 0 };
+    static const QMetaData slot_tbl[] = {
+	{ "changeMenu(struct menu*)", &slot_0, QMetaData::Public },
+	{ "setMenuLink(struct menu*)", &slot_1, QMetaData::Public },
+	{ "listFocusChanged()", &slot_2, QMetaData::Public },
+	{ "goBack()", &slot_3, QMetaData::Public },
+	{ "loadConfig()", &slot_4, QMetaData::Public },
+	{ "saveConfig()", &slot_5, QMetaData::Public },
+	{ "saveConfigAs()", &slot_6, QMetaData::Public },
+	{ "searchConfig()", &slot_7, QMetaData::Public },
+	{ "showSingleView()", &slot_8, QMetaData::Public },
+	{ "showSplitView()", &slot_9, QMetaData::Public },
+	{ "showFullView()", &slot_10, QMetaData::Public },
+	{ "showIntro()", &slot_11, QMetaData::Public },
+	{ "showAbout()", &slot_12, QMetaData::Public },
+	{ "saveSettings()", &slot_13, QMetaData::Public }
+    };
+    metaObj = QMetaObject::new_metaobject(
+	"ConfigMainWindow", parentObject,
+	slot_tbl, 14,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    cleanUp_ConfigMainWindow.setMetaObject( metaObj );
+    return metaObj;
+}
+
+void* ConfigMainWindow::qt_cast( const char* clname )
+{
+    if ( !qstrcmp( clname, "ConfigMainWindow" ) )
+	return this;
+    return Q3MainWindow::qt_cast( clname );
+}
+
+bool ConfigMainWindow::qt_invoke( int _id, QUObject* _o )
+{
+    switch ( _id - staticMetaObject()->slotOffset() ) {
+    case 0: changeMenu((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 1: setMenuLink((struct menu*)static_QUType_ptr.get(_o+1)); break;
+    case 2: listFocusChanged(); break;
+    case 3: goBack(); break;
+    case 4: loadConfig(); break;
+    case 5: static_QUType_bool.set(_o,saveConfig()); break;
+    case 6: saveConfigAs(); break;
+    case 7: searchConfig(); break;
+    case 8: showSingleView(); break;
+    case 9: showSplitView(); break;
+    case 10: showFullView(); break;
+    case 11: showIntro(); break;
+    case 12: showAbout(); break;
+    case 13: saveSettings(); break;
+    default:
+	return Q3MainWindow::qt_invoke( _id, _o );
+    }
+    return TRUE;
+}
+
+bool ConfigMainWindow::qt_emit( int _id, QUObject* _o )
+{
+    return Q3MainWindow::qt_emit(_id,_o);
+}
+#ifndef QT_NO_PROPERTIES
+
+bool ConfigMainWindow::qt_property( int id, int f, QVariant* v)
+{
+    return Q3MainWindow::qt_property( id, f, v);
+}
+
+bool ConfigMainWindow::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
+#endif // QT_NO_PROPERTIES
diff -uprN linux-3.1.5-orig/scripts/kconfig/.tmp_qtcheck linux-3.1.5/scripts/kconfig/.tmp_qtcheck
--- linux-3.1.5-orig/scripts/kconfig/.tmp_qtcheck	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/scripts/kconfig/.tmp_qtcheck	2012-10-25 16:54:02.431238299 -0600
@@ -0,0 +1,3 @@
+KC_QT_CFLAGS=$(shell pkg-config qt-mt --cflags)
+KC_QT_LIBS=$(shell pkg-config qt-mt --libs)
+KC_QT_MOC=$(shell pkg-config qt-mt --variable=prefix)/bin/moc
Binary files linux-3.1.5-orig/scripts/kconfig/zconf.tab.o and linux-3.1.5/scripts/kconfig/zconf.tab.o differ
diff -uprN linux-3.1.5-orig/scripts/kconfig/.zconf.tab.o.cmd linux-3.1.5/scripts/kconfig/.zconf.tab.o.cmd
--- linux-3.1.5-orig/scripts/kconfig/.zconf.tab.o.cmd	2012-10-25 16:26:53.505583272 -0600
+++ linux-3.1.5/scripts/kconfig/.zconf.tab.o.cmd	1969-12-31 17:00:00.000000000 -0700
@@ -1,91 +0,0 @@
-cmd_scripts/kconfig/zconf.tab.o := gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>" -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
-
-source_scripts/kconfig/zconf.tab.o := scripts/kconfig/zconf.tab.c
-
-deps_scripts/kconfig/zconf.tab.o := \
-  /usr/include/ctype.h \
-  /usr/include/features.h \
-  /usr/include/sys/cdefs.h \
-  /usr/include/bits/wordsize.h \
-  /usr/include/gnu/stubs.h \
-  /usr/include/gnu/stubs-32.h \
-  /usr/include/bits/types.h \
-  /usr/include/bits/typesizes.h \
-  /usr/include/endian.h \
-  /usr/include/bits/endian.h \
-  /usr/include/bits/byteswap.h \
-  /usr/include/xlocale.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdarg.h \
-  /usr/include/stdio.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stddef.h \
-  /usr/include/libio.h \
-  /usr/include/_G_config.h \
-  /usr/include/wchar.h \
-  /usr/include/bits/stdio_lim.h \
-  /usr/include/bits/sys_errlist.h \
-  /usr/include/bits/stdio.h \
-  /usr/include/stdlib.h \
-  /usr/include/bits/waitflags.h \
-  /usr/include/bits/waitstatus.h \
-  /usr/include/sys/types.h \
-  /usr/include/time.h \
-  /usr/include/sys/select.h \
-  /usr/include/bits/select.h \
-  /usr/include/bits/sigset.h \
-  /usr/include/bits/time.h \
-  /usr/include/sys/sysmacros.h \
-  /usr/include/bits/pthreadtypes.h \
-  /usr/include/alloca.h \
-  /usr/include/string.h \
-  /usr/include/bits/string.h \
-  /usr/include/bits/string2.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/stdbool.h \
-  scripts/kconfig/lkc.h \
-    $(wildcard include/config/.h) \
-    $(wildcard include/config/list.h) \
-  scripts/kconfig/expr.h \
-  /usr/include/libintl.h \
-  /usr/include/locale.h \
-  /usr/include/bits/locale.h \
-  scripts/kconfig/lkc_proto.h \
-  scripts/kconfig/zconf.hash.c \
-  scripts/kconfig/zconf.lex.c \
-  /usr/include/errno.h \
-  /usr/include/bits/errno.h \
-  /usr/include/linux/errno.h \
-  /usr/include/asm/errno.h \
-  /usr/include/asm-generic/errno.h \
-  /usr/include/asm-generic/errno-base.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/limits.h \
-  /usr/lib/gcc/i686-redhat-linux/4.5.1/include/syslimits.h \
-  /usr/include/limits.h \
-  /usr/include/bits/posix1_lim.h \
-  /usr/include/bits/local_lim.h \
-  /usr/include/linux/limits.h \
-  /usr/include/bits/posix2_lim.h \
-  /usr/include/unistd.h \
-  /usr/include/bits/posix_opt.h \
-  /usr/include/bits/environments.h \
-  /usr/include/bits/confname.h \
-  /usr/include/getopt.h \
-  scripts/kconfig/util.c \
-  scripts/kconfig/confdata.c \
-    $(wildcard include/config/config.h) \
-    $(wildcard include/config/autoconfig.h) \
-    $(wildcard include/config/overwriteconfig.h) \
-    $(wildcard include/config/autoheader.h) \
-    $(wildcard include/config/tristate.h) \
-  /usr/include/sys/stat.h \
-  /usr/include/bits/stat.h \
-  /usr/include/fcntl.h \
-  /usr/include/bits/fcntl.h \
-  scripts/kconfig/expr.c \
-  scripts/kconfig/symbol.c \
-  /usr/include/regex.h \
-  /usr/include/sys/utsname.h \
-  /usr/include/bits/utsname.h \
-  scripts/kconfig/menu.c \
-
-scripts/kconfig/zconf.tab.o: $(deps_scripts/kconfig/zconf.tab.o)
-
-$(deps_scripts/kconfig/zconf.tab.o):
diff -uprN linux-3.1.5-orig/scripts/mod/elfconfig.h linux-3.1.5/scripts/mod/elfconfig.h
--- linux-3.1.5-orig/scripts/mod/elfconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.5/scripts/mod/elfconfig.h	2012-10-25 20:03:21.873350910 -0600
@@ -0,0 +1,4 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS32
+#define HOST_ELFDATA ELFDATA2LSB
Binary files linux-3.1.5-orig/scripts/mod/mk_elfconfig and linux-3.1.5/scripts/mod/mk_elfconfig differ
Binary files linux-3.1.5-orig/scripts/mod/modpost and linux-3.1.5/scripts/mod/modpost differ
Binary files linux-3.1.5-orig/scripts/pnmtologo and linux-3.1.5/scripts/pnmtologo differ
